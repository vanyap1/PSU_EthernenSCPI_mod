
PSU_ETH_Controller_s21.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004d0c  00000000  00000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     000000f8  20000000  00004d0c  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000a40  200000f8  00004e04  000200f8  2**2
                  ALLOC
  3 .stack        00002000  20000b38  00005844  000200f8  2**0
                  ALLOC
  4 .ARM.attributes 00000028  00000000  00000000  000200f8  2**0
                  CONTENTS, READONLY
  5 .comment      00000059  00000000  00000000  00020120  2**0
                  CONTENTS, READONLY
  6 .debug_info   0003400f  00000000  00000000  00020179  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000046f6  00000000  00000000  00054188  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    00014875  00000000  00000000  0005887e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00000fd8  00000000  00000000  0006d0f3  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00001010  00000000  00000000  0006e0cb  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  000088bd  00000000  00000000  0006f0db  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00012680  00000000  00000000  00077998  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    0005ddc0  00000000  00000000  0008a018  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00002e94  00000000  00000000  000e7dd8  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
	PWM_1_PORT_init();
	pwm_init(&PWM_1, TC7, _tc_get_pwm());
}

void system_init(void)
{
       0:	38 2b 00 20 09 01 00 00 05 01 00 00 05 01 00 00     8+. ............
	...
                                                    bool value)
{
	uint8_t tmp;
	PORT_CRITICAL_SECTION_ENTER();
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
	tmp &= ~PORT_PINCFG_PMUXEN;
      2c:	05 01 00 00 00 00 00 00 00 00 00 00 05 01 00 00     ................

static inline void hri_port_write_WRCONFIG_reg(const void *const hw, uint8_t submodule_index,
                                               hri_port_wrconfig_reg_t data)
{
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
      3c:	05 01 00 00 05 01 00 00 05 01 00 00 05 01 00 00     ................
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
      4c:	c5 0d 00 00 a9 0b 00 00 05 01 00 00 05 01 00 00     ................
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
      5c:	05 01 00 00 05 01 00 00 05 01 00 00 05 01 00 00     ................
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
      6c:	05 01 00 00 05 01 00 00 05 01 00 00 05 01 00 00     ................
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
      7c:	05 01 00 00 05 01 00 00 05 01 00 00 05 01 00 00     ................
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
      8c:	15 1a 00 00 29 1a 00 00 05 01 00 00 05 01 00 00     ....)...........
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
      9c:	05 01 00 00 05 01 00 00                             ........

000000a4 <__do_global_dtors_aux>:
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
      a4:	b510      	push	{r4, lr}
      a6:	4c06      	ldr	r4, [pc, #24]	; (c0 <__do_global_dtors_aux+0x1c>)
      a8:	7823      	ldrb	r3, [r4, #0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
      aa:	2b00      	cmp	r3, #0
      ac:	d107      	bne.n	be <__do_global_dtors_aux+0x1a>
      ae:	4b05      	ldr	r3, [pc, #20]	; (c4 <__do_global_dtors_aux+0x20>)
	tmp &= ~PORT_PINCFG_PMUXEN;
      b0:	2b00      	cmp	r3, #0
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
      b2:	d002      	beq.n	ba <__do_global_dtors_aux+0x16>
      b4:	4804      	ldr	r0, [pc, #16]	; (c8 <__do_global_dtors_aux+0x24>)
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
      b6:	e000      	b.n	ba <__do_global_dtors_aux+0x16>
      b8:	bf00      	nop
      ba:	2301      	movs	r3, #1
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
      bc:	7023      	strb	r3, [r4, #0]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
      be:	bd10      	pop	{r4, pc}
      c0:	200000f8 	.word	0x200000f8
      c4:	00000000 	.word	0x00000000
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
      c8:	00004d0c 	.word	0x00004d0c

000000cc <frame_dummy>:
      cc:	4b08      	ldr	r3, [pc, #32]	; (f0 <frame_dummy+0x24>)
	tmp &= ~PORT_PINCFG_PMUXEN;
      ce:	b510      	push	{r4, lr}
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
      d0:	2b00      	cmp	r3, #0
      d2:	d003      	beq.n	dc <frame_dummy+0x10>
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
      d4:	4907      	ldr	r1, [pc, #28]	; (f4 <frame_dummy+0x28>)
      d6:	4808      	ldr	r0, [pc, #32]	; (f8 <frame_dummy+0x2c>)
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
      d8:	e000      	b.n	dc <frame_dummy+0x10>
      da:	bf00      	nop
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
      dc:	4807      	ldr	r0, [pc, #28]	; (fc <frame_dummy+0x30>)
      de:	6803      	ldr	r3, [r0, #0]
      e0:	2b00      	cmp	r3, #0
      e2:	d100      	bne.n	e6 <frame_dummy+0x1a>
      e4:	bd10      	pop	{r4, pc}
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
      e6:	4b06      	ldr	r3, [pc, #24]	; (100 <frame_dummy+0x34>)
      e8:	2b00      	cmp	r3, #0
	tmp &= ~PORT_PINCFG_PMUXEN;
      ea:	d0fb      	beq.n	e4 <frame_dummy+0x18>
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
      ec:	4798      	blx	r3
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
      ee:	e7f9      	b.n	e4 <frame_dummy+0x18>
      f0:	00000000 	.word	0x00000000
      f4:	200000fc 	.word	0x200000fc
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
      f8:	00004d0c 	.word	0x00004d0c
      fc:	00004d0c 	.word	0x00004d0c
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     100:	00000000 	.word	0x00000000

00000104 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
     104:	e7fe      	b.n	104 <Dummy_Handler>
	...

00000108 <Reset_Handler>:
{
     108:	b510      	push	{r4, lr}
        if (pSrc != pDest) {
     10a:	4a12      	ldr	r2, [pc, #72]	; (154 <Reset_Handler+0x4c>)
     10c:	4b12      	ldr	r3, [pc, #72]	; (158 <Reset_Handler+0x50>)
     10e:	429a      	cmp	r2, r3
     110:	d009      	beq.n	126 <Reset_Handler+0x1e>
     112:	4b11      	ldr	r3, [pc, #68]	; (158 <Reset_Handler+0x50>)
     114:	4a0f      	ldr	r2, [pc, #60]	; (154 <Reset_Handler+0x4c>)
     116:	e003      	b.n	120 <Reset_Handler+0x18>
                        *pDest++ = *pSrc++;
     118:	6811      	ldr	r1, [r2, #0]
     11a:	6019      	str	r1, [r3, #0]
     11c:	3304      	adds	r3, #4
     11e:	3204      	adds	r2, #4
                for (; pDest < &_erelocate;) {
     120:	490e      	ldr	r1, [pc, #56]	; (15c <Reset_Handler+0x54>)
     122:	428b      	cmp	r3, r1
     124:	d3f8      	bcc.n	118 <Reset_Handler+0x10>
                        *pDest++ = *pSrc++;
     126:	4b0e      	ldr	r3, [pc, #56]	; (160 <Reset_Handler+0x58>)
     128:	e002      	b.n	130 <Reset_Handler+0x28>
                *pDest++ = 0;
     12a:	2200      	movs	r2, #0
     12c:	601a      	str	r2, [r3, #0]
     12e:	3304      	adds	r3, #4
        for (pDest = &_szero; pDest < &_ezero;) {
     130:	4a0c      	ldr	r2, [pc, #48]	; (164 <Reset_Handler+0x5c>)
     132:	4293      	cmp	r3, r2
     134:	d3f9      	bcc.n	12a <Reset_Handler+0x22>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
     136:	4a0c      	ldr	r2, [pc, #48]	; (168 <Reset_Handler+0x60>)
     138:	21ff      	movs	r1, #255	; 0xff
     13a:	4b0c      	ldr	r3, [pc, #48]	; (16c <Reset_Handler+0x64>)
     13c:	438b      	bics	r3, r1
     13e:	6093      	str	r3, [r2, #8]
        NVMCTRL->CTRLB.bit.MANW = 1;
     140:	4a0b      	ldr	r2, [pc, #44]	; (170 <Reset_Handler+0x68>)
     142:	6851      	ldr	r1, [r2, #4]
     144:	2380      	movs	r3, #128	; 0x80
     146:	430b      	orrs	r3, r1
     148:	6053      	str	r3, [r2, #4]
        __libc_init_array();
     14a:	4b0a      	ldr	r3, [pc, #40]	; (174 <Reset_Handler+0x6c>)
     14c:	4798      	blx	r3
        main();
     14e:	4b0a      	ldr	r3, [pc, #40]	; (178 <Reset_Handler+0x70>)
     150:	4798      	blx	r3
     152:	e7fe      	b.n	152 <Reset_Handler+0x4a>
     154:	00004d0c 	.word	0x00004d0c
     158:	20000000 	.word	0x20000000
     15c:	200000f8 	.word	0x200000f8
     160:	200000f8 	.word	0x200000f8
     164:	20000b38 	.word	0x20000b38
     168:	e000ed00 	.word	0xe000ed00
     16c:	00000000 	.word	0x00000000
     170:	41004000 	.word	0x41004000
     174:	00004001 	.word	0x00004001
     178:	00003b39 	.word	0x00003b39

0000017c <atomic_enter_critical>:
	TIMER_0_init();

	PWM_0_init();

	PWM_1_init();
}
     17c:	f3ef 8310 	mrs	r3, PRIMASK
     180:	6003      	str	r3, [r0, #0]
     182:	b672      	cpsid	i
     184:	f3bf 8f5f 	dmb	sy
     188:	4770      	bx	lr

0000018a <atomic_leave_critical>:
     18a:	f3bf 8f5f 	dmb	sy
     18e:	6803      	ldr	r3, [r0, #0]
     190:	f383 8810 	msr	PRIMASK, r3
     194:	4770      	bx	lr
	...

00000198 <delay_ms>:
     198:	b510      	push	{r4, lr}
     19a:	4b04      	ldr	r3, [pc, #16]	; (1ac <delay_ms+0x14>)
     19c:	681c      	ldr	r4, [r3, #0]
     19e:	4b04      	ldr	r3, [pc, #16]	; (1b0 <delay_ms+0x18>)
     1a0:	4798      	blx	r3
     1a2:	0001      	movs	r1, r0
     1a4:	0020      	movs	r0, r4
     1a6:	4b03      	ldr	r3, [pc, #12]	; (1b4 <delay_ms+0x1c>)
/**
 * \brief Perform delay in ms
 */
void delay_ms(const uint16_t ms)
{
	_delay_cycles(hardware, _get_cycles_for_ms(ms));
     1a8:	4798      	blx	r3
}
     1aa:	bd10      	pop	{r4, pc}
     1ac:	20000114 	.word	0x20000114
     1b0:	00000a71 	.word	0x00000a71
     1b4:	00000a8d 	.word	0x00000a8d

000001b8 <process_ext_irq>:
 * \brief Interrupt processing routine
 *
 * \param[in] pin The pin which triggered the interrupt
 */
static void process_ext_irq(const uint32_t pin)
{
     1b8:	b570      	push	{r4, r5, r6, lr}
	uint8_t lower = 0, middle, upper = EXT_IRQ_AMOUNT;
     1ba:	2501      	movs	r5, #1
     1bc:	2400      	movs	r4, #0

	while (upper >= lower) {
     1be:	e007      	b.n	1d0 <process_ext_irq+0x18>
		if (middle >= EXT_IRQ_AMOUNT) {
			return;
		}

		if (ext_irqs[middle].pin == pin) {
			if (ext_irqs[middle].cb) {
     1c0:	4a0d      	ldr	r2, [pc, #52]	; (1f8 <process_ext_irq+0x40>)
     1c2:	58b3      	ldr	r3, [r6, r2]
     1c4:	2b00      	cmp	r3, #0
     1c6:	d000      	beq.n	1ca <process_ext_irq+0x12>
				ext_irqs[middle].cb();
     1c8:	4798      	blx	r3
			lower = middle + 1;
		} else {
			upper = middle - 1;
		}
	}
}
     1ca:	bd70      	pop	{r4, r5, r6, pc}
			upper = middle - 1;
     1cc:	3a01      	subs	r2, #1
     1ce:	b2d5      	uxtb	r5, r2
	while (upper >= lower) {
     1d0:	42ac      	cmp	r4, r5
     1d2:	d8fa      	bhi.n	1ca <process_ext_irq+0x12>
		middle = (upper + lower) >> 1;
     1d4:	192b      	adds	r3, r5, r4
     1d6:	105b      	asrs	r3, r3, #1
     1d8:	b2da      	uxtb	r2, r3
		if (middle >= EXT_IRQ_AMOUNT) {
     1da:	2a00      	cmp	r2, #0
     1dc:	d1f5      	bne.n	1ca <process_ext_irq+0x12>
     1de:	21ff      	movs	r1, #255	; 0xff
     1e0:	400b      	ands	r3, r1
		if (ext_irqs[middle].pin == pin) {
     1e2:	00de      	lsls	r6, r3, #3
     1e4:	4904      	ldr	r1, [pc, #16]	; (1f8 <process_ext_irq+0x40>)
     1e6:	1989      	adds	r1, r1, r6
     1e8:	6849      	ldr	r1, [r1, #4]
     1ea:	4281      	cmp	r1, r0
     1ec:	d0e8      	beq.n	1c0 <process_ext_irq+0x8>
		if (ext_irqs[middle].pin < pin) {
     1ee:	d2ed      	bcs.n	1cc <process_ext_irq+0x14>
			lower = middle + 1;
     1f0:	3201      	adds	r2, #1
     1f2:	b2d4      	uxtb	r4, r2
     1f4:	e7ec      	b.n	1d0 <process_ext_irq+0x18>
     1f6:	46c0      	nop			; (mov r8, r8)
     1f8:	20000118 	.word	0x20000118

000001fc <ext_irq_init>:
{
     1fc:	b510      	push	{r4, lr}
	for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
     1fe:	2300      	movs	r3, #0
     200:	2b00      	cmp	r3, #0
     202:	d003      	beq.n	20c <ext_irq_init+0x10>
	return _ext_irq_init(process_ext_irq);
     204:	4807      	ldr	r0, [pc, #28]	; (224 <ext_irq_init+0x28>)
     206:	4b08      	ldr	r3, [pc, #32]	; (228 <ext_irq_init+0x2c>)
     208:	4798      	blx	r3
}
     20a:	bd10      	pop	{r4, pc}
		ext_irqs[i].pin = 0xFFFFFFFF;
     20c:	4a07      	ldr	r2, [pc, #28]	; (22c <ext_irq_init+0x30>)
     20e:	00d9      	lsls	r1, r3, #3
     210:	1850      	adds	r0, r2, r1
     212:	2401      	movs	r4, #1
     214:	4264      	negs	r4, r4
     216:	6044      	str	r4, [r0, #4]
		ext_irqs[i].cb  = NULL;
     218:	2000      	movs	r0, #0
     21a:	5088      	str	r0, [r1, r2]
	for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
     21c:	3301      	adds	r3, #1
     21e:	b29b      	uxth	r3, r3
     220:	e7ee      	b.n	200 <ext_irq_init+0x4>
     222:	46c0      	nop			; (mov r8, r8)
     224:	000001b9 	.word	0x000001b9
     228:	00000acd 	.word	0x00000acd
     22c:	20000118 	.word	0x20000118

00000230 <ext_irq_register>:
{
     230:	b5f0      	push	{r4, r5, r6, r7, lr}
     232:	46c6      	mov	lr, r8
     234:	b500      	push	{lr}
     236:	b084      	sub	sp, #16
     238:	9001      	str	r0, [sp, #4]
	uint8_t i = 0, j = 0;
     23a:	2300      	movs	r3, #0
	for (; i < EXT_IRQ_AMOUNT; i++) {
     23c:	2b00      	cmp	r3, #0
     23e:	d010      	beq.n	262 <ext_irq_register+0x32>
	bool    found = false;
     240:	2300      	movs	r3, #0
     242:	4698      	mov	r8, r3
	if (NULL == cb) {
     244:	2900      	cmp	r1, #0
     246:	d01b      	beq.n	280 <ext_irq_register+0x50>
	if (!found) {
     248:	4643      	mov	r3, r8
     24a:	2b00      	cmp	r3, #0
     24c:	d146      	bne.n	2dc <ext_irq_register+0xac>
		for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
     24e:	2b00      	cmp	r3, #0
     250:	d124      	bne.n	29c <ext_irq_register+0x6c>
			if (NULL == ext_irqs[i].cb) {
     252:	00da      	lsls	r2, r3, #3
     254:	4c2a      	ldr	r4, [pc, #168]	; (300 <ext_irq_register+0xd0>)
     256:	5912      	ldr	r2, [r2, r4]
     258:	2a00      	cmp	r2, #0
     25a:	d018      	beq.n	28e <ext_irq_register+0x5e>
		for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
     25c:	3301      	adds	r3, #1
     25e:	b2db      	uxtb	r3, r3
     260:	e7f5      	b.n	24e <ext_irq_register+0x1e>
		if (ext_irqs[i].pin == pin) {
     262:	00dc      	lsls	r4, r3, #3
     264:	4a26      	ldr	r2, [pc, #152]	; (300 <ext_irq_register+0xd0>)
     266:	1912      	adds	r2, r2, r4
     268:	6852      	ldr	r2, [r2, #4]
     26a:	9801      	ldr	r0, [sp, #4]
     26c:	4282      	cmp	r2, r0
     26e:	d002      	beq.n	276 <ext_irq_register+0x46>
	for (; i < EXT_IRQ_AMOUNT; i++) {
     270:	3301      	adds	r3, #1
     272:	b2db      	uxtb	r3, r3
     274:	e7e2      	b.n	23c <ext_irq_register+0xc>
			ext_irqs[i].cb = cb;
     276:	4b22      	ldr	r3, [pc, #136]	; (300 <ext_irq_register+0xd0>)
     278:	50e1      	str	r1, [r4, r3]
			found          = true;
     27a:	2301      	movs	r3, #1
     27c:	4698      	mov	r8, r3
			break;
     27e:	e7e1      	b.n	244 <ext_irq_register+0x14>
		if (!found) {
     280:	4643      	mov	r3, r8
     282:	2b00      	cmp	r3, #0
     284:	d035      	beq.n	2f2 <ext_irq_register+0xc2>
		return _ext_irq_enable(pin, false);
     286:	9801      	ldr	r0, [sp, #4]
     288:	4b1e      	ldr	r3, [pc, #120]	; (304 <ext_irq_register+0xd4>)
     28a:	4798      	blx	r3
     28c:	e02d      	b.n	2ea <ext_irq_register+0xba>
				ext_irqs[i].cb  = cb;
     28e:	00dd      	lsls	r5, r3, #3
     290:	5129      	str	r1, [r5, r4]
				ext_irqs[i].pin = pin;
     292:	1965      	adds	r5, r4, r5
     294:	9a01      	ldr	r2, [sp, #4]
     296:	606a      	str	r2, [r5, #4]
				found           = true;
     298:	2201      	movs	r2, #1
     29a:	4690      	mov	r8, r2
     29c:	2200      	movs	r2, #0
     29e:	e001      	b.n	2a4 <ext_irq_register+0x74>
		for (; (j < EXT_IRQ_AMOUNT) && (i < EXT_IRQ_AMOUNT); j++) {
     2a0:	3201      	adds	r2, #1
     2a2:	b2d2      	uxtb	r2, r2
     2a4:	0019      	movs	r1, r3
     2a6:	4311      	orrs	r1, r2
     2a8:	d118      	bne.n	2dc <ext_irq_register+0xac>
			if ((ext_irqs[i].pin < ext_irqs[j].pin) && (ext_irqs[j].pin != 0xFFFFFFFF)) {
     2aa:	4915      	ldr	r1, [pc, #84]	; (300 <ext_irq_register+0xd0>)
     2ac:	00dc      	lsls	r4, r3, #3
     2ae:	190c      	adds	r4, r1, r4
     2b0:	6867      	ldr	r7, [r4, #4]
     2b2:	00d4      	lsls	r4, r2, #3
     2b4:	1909      	adds	r1, r1, r4
     2b6:	6849      	ldr	r1, [r1, #4]
     2b8:	428f      	cmp	r7, r1
     2ba:	d2f1      	bcs.n	2a0 <ext_irq_register+0x70>
     2bc:	1c4c      	adds	r4, r1, #1
     2be:	d0ef      	beq.n	2a0 <ext_irq_register+0x70>
				struct ext_irq tmp = ext_irqs[j];
     2c0:	a902      	add	r1, sp, #8
     2c2:	468c      	mov	ip, r1
     2c4:	4f0e      	ldr	r7, [pc, #56]	; (300 <ext_irq_register+0xd0>)
     2c6:	00d1      	lsls	r1, r2, #3
     2c8:	1879      	adds	r1, r7, r1
     2ca:	4664      	mov	r4, ip
     2cc:	c941      	ldmia	r1!, {r0, r6}
     2ce:	c441      	stmia	r4!, {r0, r6}
				ext_irqs[i] = tmp;
     2d0:	00dd      	lsls	r5, r3, #3
     2d2:	197d      	adds	r5, r7, r5
     2d4:	4661      	mov	r1, ip
     2d6:	c911      	ldmia	r1!, {r0, r4}
     2d8:	c511      	stmia	r5!, {r0, r4}
     2da:	e7e1      	b.n	2a0 <ext_irq_register+0x70>
	if (!found) {
     2dc:	4643      	mov	r3, r8
     2de:	2b00      	cmp	r3, #0
     2e0:	d00a      	beq.n	2f8 <ext_irq_register+0xc8>
	return _ext_irq_enable(pin, true);
     2e2:	2101      	movs	r1, #1
     2e4:	9801      	ldr	r0, [sp, #4]
     2e6:	4b07      	ldr	r3, [pc, #28]	; (304 <ext_irq_register+0xd4>)
     2e8:	4798      	blx	r3
}
     2ea:	b004      	add	sp, #16
     2ec:	bc04      	pop	{r2}
     2ee:	4690      	mov	r8, r2
     2f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
			return ERR_INVALID_ARG;
     2f2:	200d      	movs	r0, #13
     2f4:	4240      	negs	r0, r0
     2f6:	e7f8      	b.n	2ea <ext_irq_register+0xba>
		return ERR_INVALID_ARG;
     2f8:	200d      	movs	r0, #13
     2fa:	4240      	negs	r0, r0
     2fc:	e7f5      	b.n	2ea <ext_irq_register+0xba>
     2fe:	46c0      	nop			; (mov r8, r8)
     300:	20000118 	.word	0x20000118
     304:	00000b5d 	.word	0x00000b5d

00000308 <i2c_m_sync_write>:

/**
 * \brief Sync version of I2C I/O write
 */
static int32_t i2c_m_sync_write(struct io_descriptor *io, const uint8_t *buf, const uint16_t n)
{
     308:	b510      	push	{r4, lr}
     30a:	b084      	sub	sp, #16
	struct i2c_m_sync_desc *i2c = CONTAINER_OF(io, struct i2c_m_sync_desc, io);
	struct _i2c_m_msg       msg;
	int32_t                 ret;

	msg.addr   = i2c->slave_addr;
     30c:	3814      	subs	r0, #20
     30e:	8b84      	ldrh	r4, [r0, #28]
     310:	ab01      	add	r3, sp, #4
     312:	801c      	strh	r4, [r3, #0]
	msg.len    = n;
     314:	0014      	movs	r4, r2
     316:	9202      	str	r2, [sp, #8]
	msg.flags  = I2C_M_STOP;
     318:	4a06      	ldr	r2, [pc, #24]	; (334 <i2c_m_sync_write+0x2c>)
     31a:	805a      	strh	r2, [r3, #2]
	msg.buffer = (uint8_t *)buf;
     31c:	9103      	str	r1, [sp, #12]

	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
     31e:	0019      	movs	r1, r3
     320:	4b05      	ldr	r3, [pc, #20]	; (338 <i2c_m_sync_write+0x30>)
     322:	4798      	blx	r3

	if (ret) {
     324:	2800      	cmp	r0, #0
     326:	d102      	bne.n	32e <i2c_m_sync_write+0x26>
		return ret;
	}

	return n;
}
     328:	0020      	movs	r0, r4
     32a:	b004      	add	sp, #16
     32c:	bd10      	pop	{r4, pc}
		return ret;
     32e:	0004      	movs	r4, r0
     330:	e7fa      	b.n	328 <i2c_m_sync_write+0x20>
     332:	46c0      	nop			; (mov r8, r8)
     334:	ffff8000 	.word	0xffff8000
     338:	00001231 	.word	0x00001231

0000033c <i2c_m_sync_read>:
{
     33c:	b510      	push	{r4, lr}
     33e:	b084      	sub	sp, #16
	msg.addr   = i2c->slave_addr;
     340:	3814      	subs	r0, #20
     342:	8b84      	ldrh	r4, [r0, #28]
     344:	ab01      	add	r3, sp, #4
     346:	801c      	strh	r4, [r3, #0]
	msg.len    = n;
     348:	0014      	movs	r4, r2
     34a:	9202      	str	r2, [sp, #8]
	msg.flags  = I2C_M_STOP | I2C_M_RD;
     34c:	4a06      	ldr	r2, [pc, #24]	; (368 <i2c_m_sync_read+0x2c>)
     34e:	805a      	strh	r2, [r3, #2]
	msg.buffer = buf;
     350:	9103      	str	r1, [sp, #12]
	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
     352:	0019      	movs	r1, r3
     354:	4b05      	ldr	r3, [pc, #20]	; (36c <i2c_m_sync_read+0x30>)
     356:	4798      	blx	r3
	if (ret) {
     358:	2800      	cmp	r0, #0
     35a:	d102      	bne.n	362 <i2c_m_sync_read+0x26>
}
     35c:	0020      	movs	r0, r4
     35e:	b004      	add	sp, #16
     360:	bd10      	pop	{r4, pc}
		return ret;
     362:	0004      	movs	r4, r0
     364:	e7fa      	b.n	35c <i2c_m_sync_read+0x20>
     366:	46c0      	nop			; (mov r8, r8)
     368:	ffff8001 	.word	0xffff8001
     36c:	00001231 	.word	0x00001231

00000370 <i2c_m_sync_init>:

/**
 * \brief Sync version of i2c initialize
 */
int32_t i2c_m_sync_init(struct i2c_m_sync_desc *i2c, void *hw)
{
     370:	b570      	push	{r4, r5, r6, lr}
     372:	0004      	movs	r4, r0
     374:	000d      	movs	r5, r1
	int32_t init_status;
	ASSERT(i2c);
     376:	1e43      	subs	r3, r0, #1
     378:	4198      	sbcs	r0, r3
     37a:	b2c0      	uxtb	r0, r0
     37c:	225e      	movs	r2, #94	; 0x5e
     37e:	4907      	ldr	r1, [pc, #28]	; (39c <i2c_m_sync_init+0x2c>)
     380:	4b07      	ldr	r3, [pc, #28]	; (3a0 <i2c_m_sync_init+0x30>)
     382:	4798      	blx	r3

	init_status = _i2c_m_sync_init(&i2c->device, hw);
     384:	0029      	movs	r1, r5
     386:	0020      	movs	r0, r4
     388:	4b06      	ldr	r3, [pc, #24]	; (3a4 <i2c_m_sync_init+0x34>)
     38a:	4798      	blx	r3
	if (init_status) {
     38c:	2800      	cmp	r0, #0
     38e:	d103      	bne.n	398 <i2c_m_sync_init+0x28>
		return init_status;
	}

	/* Init I/O */
	i2c->io.read  = i2c_m_sync_read;
     390:	4b05      	ldr	r3, [pc, #20]	; (3a8 <i2c_m_sync_init+0x38>)
     392:	61a3      	str	r3, [r4, #24]
	i2c->io.write = i2c_m_sync_write;
     394:	4b05      	ldr	r3, [pc, #20]	; (3ac <i2c_m_sync_init+0x3c>)
     396:	6163      	str	r3, [r4, #20]

	return ERR_NONE;
}
     398:	bd70      	pop	{r4, r5, r6, pc}
     39a:	46c0      	nop			; (mov r8, r8)
     39c:	0000496c 	.word	0x0000496c
     3a0:	000009e5 	.word	0x000009e5
     3a4:	0000110d 	.word	0x0000110d
     3a8:	0000033d 	.word	0x0000033d
     3ac:	00000309 	.word	0x00000309

000003b0 <i2c_m_sync_enable>:

/**
 * \brief Sync version of i2c enable
 */
int32_t i2c_m_sync_enable(struct i2c_m_sync_desc *i2c)
{
     3b0:	b510      	push	{r4, lr}
	return _i2c_m_sync_enable(&i2c->device);
     3b2:	4b01      	ldr	r3, [pc, #4]	; (3b8 <i2c_m_sync_enable+0x8>)
     3b4:	4798      	blx	r3
}
     3b6:	bd10      	pop	{r4, pc}
     3b8:	000011b9 	.word	0x000011b9

000003bc <i2c_m_sync_get_io_descriptor>:
/**
 * \brief Retrieve I/O descriptor
 */
int32_t i2c_m_sync_get_io_descriptor(struct i2c_m_sync_desc *const i2c, struct io_descriptor **io)
{
	*io = &i2c->io;
     3bc:	3014      	adds	r0, #20
     3be:	6008      	str	r0, [r1, #0]
	return ERR_NONE;
}
     3c0:	2000      	movs	r0, #0
     3c2:	4770      	bx	lr

000003c4 <io_write>:

/**
 * \brief I/O write interface
 */
int32_t io_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
     3c4:	b570      	push	{r4, r5, r6, lr}
     3c6:	0004      	movs	r4, r0
     3c8:	000d      	movs	r5, r1
     3ca:	0016      	movs	r6, r2
	ASSERT(io_descr && buf);
     3cc:	2800      	cmp	r0, #0
     3ce:	d00e      	beq.n	3ee <io_write+0x2a>
     3d0:	2900      	cmp	r1, #0
     3d2:	d00a      	beq.n	3ea <io_write+0x26>
     3d4:	2001      	movs	r0, #1
     3d6:	2234      	movs	r2, #52	; 0x34
     3d8:	4906      	ldr	r1, [pc, #24]	; (3f4 <io_write+0x30>)
     3da:	4b07      	ldr	r3, [pc, #28]	; (3f8 <io_write+0x34>)
     3dc:	4798      	blx	r3
	return io_descr->write(io_descr, buf, length);
     3de:	6823      	ldr	r3, [r4, #0]
     3e0:	0032      	movs	r2, r6
     3e2:	0029      	movs	r1, r5
     3e4:	0020      	movs	r0, r4
     3e6:	4798      	blx	r3
}
     3e8:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(io_descr && buf);
     3ea:	2000      	movs	r0, #0
     3ec:	e7f3      	b.n	3d6 <io_write+0x12>
     3ee:	2000      	movs	r0, #0
     3f0:	e7f1      	b.n	3d6 <io_write+0x12>
     3f2:	46c0      	nop			; (mov r8, r8)
     3f4:	00004988 	.word	0x00004988
     3f8:	000009e5 	.word	0x000009e5

000003fc <io_read>:

/**
 * \brief I/O read interface
 */
int32_t io_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
     3fc:	b570      	push	{r4, r5, r6, lr}
     3fe:	0004      	movs	r4, r0
     400:	000d      	movs	r5, r1
     402:	0016      	movs	r6, r2
	ASSERT(io_descr && buf);
     404:	2800      	cmp	r0, #0
     406:	d00e      	beq.n	426 <io_read+0x2a>
     408:	2900      	cmp	r1, #0
     40a:	d00a      	beq.n	422 <io_read+0x26>
     40c:	2001      	movs	r0, #1
     40e:	223d      	movs	r2, #61	; 0x3d
     410:	4906      	ldr	r1, [pc, #24]	; (42c <io_read+0x30>)
     412:	4b07      	ldr	r3, [pc, #28]	; (430 <io_read+0x34>)
     414:	4798      	blx	r3
	return io_descr->read(io_descr, buf, length);
     416:	6863      	ldr	r3, [r4, #4]
     418:	0032      	movs	r2, r6
     41a:	0029      	movs	r1, r5
     41c:	0020      	movs	r0, r4
     41e:	4798      	blx	r3
}
     420:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(io_descr && buf);
     422:	2000      	movs	r0, #0
     424:	e7f3      	b.n	40e <io_read+0x12>
     426:	2000      	movs	r0, #0
     428:	e7f1      	b.n	40e <io_read+0x12>
     42a:	46c0      	nop			; (mov r8, r8)
     42c:	00004988 	.word	0x00004988
     430:	000009e5 	.word	0x000009e5

00000434 <pwm_period_expired>:

/**
 * \internal Process interrupts caused by period experied
 */
static void pwm_period_expired(struct _pwm_device *device)
{
     434:	b510      	push	{r4, lr}
	struct pwm_descriptor *const descr = CONTAINER_OF(device, struct pwm_descriptor, device);

	if (descr->pwm_cb.period) {
     436:	6943      	ldr	r3, [r0, #20]
     438:	2b00      	cmp	r3, #0
     43a:	d000      	beq.n	43e <pwm_period_expired+0xa>
		descr->pwm_cb.period(descr);
     43c:	4798      	blx	r3
	}
}
     43e:	bd10      	pop	{r4, pc}

00000440 <pwm_detect_fault>:

/**
 * \internal Process interrupts caused by pwm fault
 */
static void pwm_detect_fault(struct _pwm_device *device)
{
     440:	b510      	push	{r4, lr}
	struct pwm_descriptor *const descr = CONTAINER_OF(device, struct pwm_descriptor, device);

	if (descr->pwm_cb.error) {
     442:	6983      	ldr	r3, [r0, #24]
     444:	2b00      	cmp	r3, #0
     446:	d000      	beq.n	44a <pwm_detect_fault+0xa>
		descr->pwm_cb.error(descr);
     448:	4798      	blx	r3
	}
}
     44a:	bd10      	pop	{r4, pc}

0000044c <pwm_init>:
{
     44c:	b570      	push	{r4, r5, r6, lr}
     44e:	0004      	movs	r4, r0
     450:	000d      	movs	r5, r1
	ASSERT(descr && hw);
     452:	2800      	cmp	r0, #0
     454:	d012      	beq.n	47c <pwm_init+0x30>
     456:	2900      	cmp	r1, #0
     458:	d00e      	beq.n	478 <pwm_init+0x2c>
     45a:	2001      	movs	r0, #1
     45c:	2233      	movs	r2, #51	; 0x33
     45e:	4908      	ldr	r1, [pc, #32]	; (480 <pwm_init+0x34>)
     460:	4b08      	ldr	r3, [pc, #32]	; (484 <pwm_init+0x38>)
     462:	4798      	blx	r3
	_pwm_init(&descr->device, hw);
     464:	0029      	movs	r1, r5
     466:	0020      	movs	r0, r4
     468:	4b07      	ldr	r3, [pc, #28]	; (488 <pwm_init+0x3c>)
     46a:	4798      	blx	r3
	descr->device.callback.pwm_period_cb = pwm_period_expired;
     46c:	4b07      	ldr	r3, [pc, #28]	; (48c <pwm_init+0x40>)
     46e:	6023      	str	r3, [r4, #0]
	descr->device.callback.pwm_error_cb  = pwm_detect_fault;
     470:	4b07      	ldr	r3, [pc, #28]	; (490 <pwm_init+0x44>)
     472:	6063      	str	r3, [r4, #4]
}
     474:	2000      	movs	r0, #0
     476:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && hw);
     478:	2000      	movs	r0, #0
     47a:	e7ef      	b.n	45c <pwm_init+0x10>
     47c:	2000      	movs	r0, #0
     47e:	e7ed      	b.n	45c <pwm_init+0x10>
     480:	0000499c 	.word	0x0000499c
     484:	000009e5 	.word	0x000009e5
     488:	000018a9 	.word	0x000018a9
     48c:	00000435 	.word	0x00000435
     490:	00000441 	.word	0x00000441

00000494 <pwm_enable>:
{
     494:	b510      	push	{r4, lr}
     496:	0004      	movs	r4, r0
	ASSERT(descr);
     498:	1e43      	subs	r3, r0, #1
     49a:	4198      	sbcs	r0, r3
     49c:	b2c0      	uxtb	r0, r0
     49e:	224a      	movs	r2, #74	; 0x4a
     4a0:	4907      	ldr	r1, [pc, #28]	; (4c0 <pwm_enable+0x2c>)
     4a2:	4b08      	ldr	r3, [pc, #32]	; (4c4 <pwm_enable+0x30>)
     4a4:	4798      	blx	r3
	if (_pwm_is_enabled(&descr->device)) {
     4a6:	0020      	movs	r0, r4
     4a8:	4b07      	ldr	r3, [pc, #28]	; (4c8 <pwm_enable+0x34>)
     4aa:	4798      	blx	r3
     4ac:	2800      	cmp	r0, #0
     4ae:	d104      	bne.n	4ba <pwm_enable+0x26>
	_pwm_enable(&descr->device);
     4b0:	0020      	movs	r0, r4
     4b2:	4b06      	ldr	r3, [pc, #24]	; (4cc <pwm_enable+0x38>)
     4b4:	4798      	blx	r3
	return ERR_NONE;
     4b6:	2000      	movs	r0, #0
}
     4b8:	bd10      	pop	{r4, pc}
		return ERR_DENIED;
     4ba:	2011      	movs	r0, #17
     4bc:	4240      	negs	r0, r0
     4be:	e7fb      	b.n	4b8 <pwm_enable+0x24>
     4c0:	0000499c 	.word	0x0000499c
     4c4:	000009e5 	.word	0x000009e5
     4c8:	00001a05 	.word	0x00001a05
     4cc:	0000199d 	.word	0x0000199d

000004d0 <pwm_set_parameters>:
{
     4d0:	b570      	push	{r4, r5, r6, lr}
     4d2:	0004      	movs	r4, r0
     4d4:	000d      	movs	r5, r1
     4d6:	0016      	movs	r6, r2
	ASSERT(descr);
     4d8:	1e43      	subs	r3, r0, #1
     4da:	4198      	sbcs	r0, r3
     4dc:	b2c0      	uxtb	r0, r0
     4de:	227c      	movs	r2, #124	; 0x7c
     4e0:	4904      	ldr	r1, [pc, #16]	; (4f4 <pwm_set_parameters+0x24>)
     4e2:	4b05      	ldr	r3, [pc, #20]	; (4f8 <pwm_set_parameters+0x28>)
     4e4:	4798      	blx	r3
	_pwm_set_param(&descr->device, period, duty_cycle);
     4e6:	0032      	movs	r2, r6
     4e8:	0029      	movs	r1, r5
     4ea:	0020      	movs	r0, r4
     4ec:	4b03      	ldr	r3, [pc, #12]	; (4fc <pwm_set_parameters+0x2c>)
     4ee:	4798      	blx	r3
}
     4f0:	2000      	movs	r0, #0
     4f2:	bd70      	pop	{r4, r5, r6, pc}
     4f4:	0000499c 	.word	0x0000499c
     4f8:	000009e5 	.word	0x000009e5
     4fc:	000019ad 	.word	0x000019ad

00000500 <spi_m_sync_init>:
	ASSERT(spi);
	spi->func = (struct _spi_m_sync_hpl_interface *)func;
}

int32_t spi_m_sync_init(struct spi_m_sync_descriptor *spi, void *const hw)
{
     500:	b570      	push	{r4, r5, r6, lr}
     502:	0004      	movs	r4, r0
     504:	000d      	movs	r5, r1
	int32_t rc = 0;
	ASSERT(spi && hw);
     506:	2800      	cmp	r0, #0
     508:	d017      	beq.n	53a <spi_m_sync_init+0x3a>
     50a:	2900      	cmp	r1, #0
     50c:	d013      	beq.n	536 <spi_m_sync_init+0x36>
     50e:	2001      	movs	r0, #1
     510:	2240      	movs	r2, #64	; 0x40
     512:	490b      	ldr	r1, [pc, #44]	; (540 <spi_m_sync_init+0x40>)
     514:	4b0b      	ldr	r3, [pc, #44]	; (544 <spi_m_sync_init+0x44>)
     516:	4798      	blx	r3
	spi->dev.prvt = (void *)hw;
     518:	6065      	str	r5, [r4, #4]
	rc            = _spi_m_sync_init(&spi->dev, hw);
     51a:	1d20      	adds	r0, r4, #4
     51c:	0029      	movs	r1, r5
     51e:	4b0a      	ldr	r3, [pc, #40]	; (548 <spi_m_sync_init+0x48>)
     520:	4798      	blx	r3

	if (rc < 0) {
     522:	2800      	cmp	r0, #0
     524:	db06      	blt.n	534 <spi_m_sync_init+0x34>
		return rc;
	}

	spi->flags    = SPI_DEACTIVATE_NEXT;
     526:	4b09      	ldr	r3, [pc, #36]	; (54c <spi_m_sync_init+0x4c>)
     528:	82a3      	strh	r3, [r4, #20]
	spi->io.read  = _spi_m_sync_io_read;
     52a:	4b09      	ldr	r3, [pc, #36]	; (550 <spi_m_sync_init+0x50>)
     52c:	6123      	str	r3, [r4, #16]
	spi->io.write = _spi_m_sync_io_write;
     52e:	4b09      	ldr	r3, [pc, #36]	; (554 <spi_m_sync_init+0x54>)
     530:	60e3      	str	r3, [r4, #12]

	return ERR_NONE;
     532:	2000      	movs	r0, #0
}
     534:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(spi && hw);
     536:	2000      	movs	r0, #0
     538:	e7ea      	b.n	510 <spi_m_sync_init+0x10>
     53a:	2000      	movs	r0, #0
     53c:	e7e8      	b.n	510 <spi_m_sync_init+0x10>
     53e:	46c0      	nop			; (mov r8, r8)
     540:	000049b4 	.word	0x000049b4
     544:	000009e5 	.word	0x000009e5
     548:	0000144d 	.word	0x0000144d
     54c:	ffff8000 	.word	0xffff8000
     550:	00000605 	.word	0x00000605
     554:	000005c9 	.word	0x000005c9

00000558 <spi_m_sync_enable>:
	ASSERT(spi);
	_spi_m_sync_deinit(&spi->dev);
}

void spi_m_sync_enable(struct spi_m_sync_descriptor *spi)
{
     558:	b510      	push	{r4, lr}
     55a:	0004      	movs	r4, r0
	ASSERT(spi);
     55c:	1e43      	subs	r3, r0, #1
     55e:	4198      	sbcs	r0, r3
     560:	b2c0      	uxtb	r0, r0
     562:	2257      	movs	r2, #87	; 0x57
     564:	4903      	ldr	r1, [pc, #12]	; (574 <spi_m_sync_enable+0x1c>)
     566:	4b04      	ldr	r3, [pc, #16]	; (578 <spi_m_sync_enable+0x20>)
     568:	4798      	blx	r3
	_spi_m_sync_enable(&spi->dev);
     56a:	1d20      	adds	r0, r4, #4
     56c:	4b03      	ldr	r3, [pc, #12]	; (57c <spi_m_sync_enable+0x24>)
     56e:	4798      	blx	r3
}
     570:	bd10      	pop	{r4, pc}
     572:	46c0      	nop			; (mov r8, r8)
     574:	000049b4 	.word	0x000049b4
     578:	000009e5 	.word	0x000009e5
     57c:	0000160d 	.word	0x0000160d

00000580 <spi_m_sync_transfer>:

	return spi_m_sync_transfer(spi, &xfer);
}

int32_t spi_m_sync_transfer(struct spi_m_sync_descriptor *spi, const struct spi_xfer *p_xfer)
{
     580:	b530      	push	{r4, r5, lr}
     582:	b087      	sub	sp, #28
     584:	0004      	movs	r4, r0
     586:	000d      	movs	r5, r1
	struct spi_msg msg;

	ASSERT(spi && p_xfer);
     588:	2800      	cmp	r0, #0
     58a:	d015      	beq.n	5b8 <spi_m_sync_transfer+0x38>
     58c:	2900      	cmp	r1, #0
     58e:	d011      	beq.n	5b4 <spi_m_sync_transfer+0x34>
     590:	2001      	movs	r0, #1
     592:	22b3      	movs	r2, #179	; 0xb3
     594:	4909      	ldr	r1, [pc, #36]	; (5bc <spi_m_sync_transfer+0x3c>)
     596:	4b0a      	ldr	r3, [pc, #40]	; (5c0 <spi_m_sync_transfer+0x40>)
     598:	4798      	blx	r3

	msg.txbuf = p_xfer->txbuf;
     59a:	682b      	ldr	r3, [r5, #0]
     59c:	9303      	str	r3, [sp, #12]
	msg.rxbuf = p_xfer->rxbuf;
     59e:	686b      	ldr	r3, [r5, #4]
     5a0:	9304      	str	r3, [sp, #16]
	msg.size  = p_xfer->size;
     5a2:	68ab      	ldr	r3, [r5, #8]
     5a4:	9301      	str	r3, [sp, #4]
     5a6:	9305      	str	r3, [sp, #20]
	return _spi_m_sync_trans(&spi->dev, &msg);
     5a8:	1d20      	adds	r0, r4, #4
     5aa:	a903      	add	r1, sp, #12
     5ac:	4b05      	ldr	r3, [pc, #20]	; (5c4 <spi_m_sync_transfer+0x44>)
     5ae:	4798      	blx	r3
}
     5b0:	b007      	add	sp, #28
     5b2:	bd30      	pop	{r4, r5, pc}
	ASSERT(spi && p_xfer);
     5b4:	2000      	movs	r0, #0
     5b6:	e7ec      	b.n	592 <spi_m_sync_transfer+0x12>
     5b8:	2000      	movs	r0, #0
     5ba:	e7ea      	b.n	592 <spi_m_sync_transfer+0x12>
     5bc:	000049b4 	.word	0x000049b4
     5c0:	000009e5 	.word	0x000009e5
     5c4:	00001645 	.word	0x00001645

000005c8 <_spi_m_sync_io_write>:
{
     5c8:	b570      	push	{r4, r5, r6, lr}
     5ca:	b084      	sub	sp, #16
     5cc:	0004      	movs	r4, r0
     5ce:	000e      	movs	r6, r1
     5d0:	0015      	movs	r5, r2
	ASSERT(io);
     5d2:	1e43      	subs	r3, r0, #1
     5d4:	4198      	sbcs	r0, r3
     5d6:	b2c0      	uxtb	r0, r0
     5d8:	22a3      	movs	r2, #163	; 0xa3
     5da:	4907      	ldr	r1, [pc, #28]	; (5f8 <_spi_m_sync_io_write+0x30>)
     5dc:	4b07      	ldr	r3, [pc, #28]	; (5fc <_spi_m_sync_io_write+0x34>)
     5de:	4798      	blx	r3
	struct spi_m_sync_descriptor *spi = CONTAINER_OF(io, struct spi_m_sync_descriptor, io);
     5e0:	0020      	movs	r0, r4
     5e2:	380c      	subs	r0, #12
	xfer.rxbuf = 0;
     5e4:	2300      	movs	r3, #0
     5e6:	9302      	str	r3, [sp, #8]
	xfer.txbuf = (uint8_t *)buf;
     5e8:	9601      	str	r6, [sp, #4]
	xfer.size  = length;
     5ea:	9503      	str	r5, [sp, #12]
	return spi_m_sync_transfer(spi, &xfer);
     5ec:	a901      	add	r1, sp, #4
     5ee:	4b04      	ldr	r3, [pc, #16]	; (600 <_spi_m_sync_io_write+0x38>)
     5f0:	4798      	blx	r3
}
     5f2:	b004      	add	sp, #16
     5f4:	bd70      	pop	{r4, r5, r6, pc}
     5f6:	46c0      	nop			; (mov r8, r8)
     5f8:	000049b4 	.word	0x000049b4
     5fc:	000009e5 	.word	0x000009e5
     600:	00000581 	.word	0x00000581

00000604 <_spi_m_sync_io_read>:
{
     604:	b570      	push	{r4, r5, r6, lr}
     606:	b084      	sub	sp, #16
     608:	0004      	movs	r4, r0
     60a:	000e      	movs	r6, r1
     60c:	0015      	movs	r5, r2
	ASSERT(io);
     60e:	1e43      	subs	r3, r0, #1
     610:	4198      	sbcs	r0, r3
     612:	b2c0      	uxtb	r0, r0
     614:	2287      	movs	r2, #135	; 0x87
     616:	4907      	ldr	r1, [pc, #28]	; (634 <_spi_m_sync_io_read+0x30>)
     618:	4b07      	ldr	r3, [pc, #28]	; (638 <_spi_m_sync_io_read+0x34>)
     61a:	4798      	blx	r3
	struct spi_m_sync_descriptor *spi = CONTAINER_OF(io, struct spi_m_sync_descriptor, io);
     61c:	0020      	movs	r0, r4
     61e:	380c      	subs	r0, #12
	xfer.rxbuf = buf;
     620:	9602      	str	r6, [sp, #8]
	xfer.txbuf = 0;
     622:	2300      	movs	r3, #0
     624:	9301      	str	r3, [sp, #4]
	xfer.size  = length;
     626:	9503      	str	r5, [sp, #12]
	return spi_m_sync_transfer(spi, &xfer);
     628:	a901      	add	r1, sp, #4
     62a:	4b04      	ldr	r3, [pc, #16]	; (63c <_spi_m_sync_io_read+0x38>)
     62c:	4798      	blx	r3
}
     62e:	b004      	add	sp, #16
     630:	bd70      	pop	{r4, r5, r6, pc}
     632:	46c0      	nop			; (mov r8, r8)
     634:	000049b4 	.word	0x000049b4
     638:	000009e5 	.word	0x000009e5
     63c:	00000581 	.word	0x00000581

00000640 <spi_m_sync_get_io_descriptor>:

int32_t spi_m_sync_get_io_descriptor(struct spi_m_sync_descriptor *const spi, struct io_descriptor **io)
{
     640:	b570      	push	{r4, r5, r6, lr}
     642:	0004      	movs	r4, r0
     644:	000d      	movs	r5, r1
	ASSERT(spi && io);
     646:	2800      	cmp	r0, #0
     648:	d00c      	beq.n	664 <spi_m_sync_get_io_descriptor+0x24>
     64a:	2900      	cmp	r1, #0
     64c:	d008      	beq.n	660 <spi_m_sync_get_io_descriptor+0x20>
     64e:	2001      	movs	r0, #1
     650:	22bd      	movs	r2, #189	; 0xbd
     652:	4905      	ldr	r1, [pc, #20]	; (668 <spi_m_sync_get_io_descriptor+0x28>)
     654:	4b05      	ldr	r3, [pc, #20]	; (66c <spi_m_sync_get_io_descriptor+0x2c>)
     656:	4798      	blx	r3
	*io = &spi->io;
     658:	340c      	adds	r4, #12
     65a:	602c      	str	r4, [r5, #0]
	return 0;
}
     65c:	2000      	movs	r0, #0
     65e:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(spi && io);
     660:	2000      	movs	r0, #0
     662:	e7f5      	b.n	650 <spi_m_sync_get_io_descriptor+0x10>
     664:	2000      	movs	r0, #0
     666:	e7f3      	b.n	650 <spi_m_sync_get_io_descriptor+0x10>
     668:	000049b4 	.word	0x000049b4
     66c:	000009e5 	.word	0x000009e5

00000670 <timer_add_timer_task>:
 * \param[in] head The pointer to the head of timer task list
 * \param[in] task The pointer to task to add
 * \param[in] time Current timer time
 */
static void timer_add_timer_task(struct list_descriptor *list, struct timer_task *const new_task, const uint32_t time)
{
     670:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 * \return A pointer to the head of the given list or NULL if the list is
 * empty
 */
static inline void *list_get_head(const struct list_descriptor *const list)
{
	return (void *)list->head;
     672:	6806      	ldr	r6, [r0, #0]
	struct timer_task *it, *prev = NULL, *head = (struct timer_task *)list_get_head(list);

	if (!head) {
     674:	2e00      	cmp	r6, #0
     676:	d002      	beq.n	67e <timer_add_timer_task+0xe>
     678:	0033      	movs	r3, r6
     67a:	2500      	movs	r5, #0
     67c:	e00c      	b.n	698 <timer_add_timer_task+0x28>
		list_insert_as_head(list, new_task);
     67e:	4b10      	ldr	r3, [pc, #64]	; (6c0 <timer_add_timer_task+0x50>)
     680:	4798      	blx	r3
		return;
     682:	e018      	b.n	6b6 <timer_add_timer_task+0x46>
		uint32_t time_left;

		if (it->time_label <= time) {
			time_left = it->interval - (time - it->time_label);
		} else {
			time_left = it->interval - (0xFFFFFFFF - it->time_label) - time;
     684:	689f      	ldr	r7, [r3, #8]
     686:	46bc      	mov	ip, r7
     688:	4464      	add	r4, ip
     68a:	1aa4      	subs	r4, r4, r2
     68c:	3401      	adds	r4, #1
		}
		if (time_left >= new_task->interval)
     68e:	688f      	ldr	r7, [r1, #8]
     690:	42bc      	cmp	r4, r7
     692:	d20b      	bcs.n	6ac <timer_add_timer_task+0x3c>
			break;
		prev = it;
     694:	001d      	movs	r5, r3
	for (it = head; it; it = (struct timer_task *)list_get_next_element(it)) {
     696:	681b      	ldr	r3, [r3, #0]
     698:	2b00      	cmp	r3, #0
     69a:	d007      	beq.n	6ac <timer_add_timer_task+0x3c>
		if (it->time_label <= time) {
     69c:	685c      	ldr	r4, [r3, #4]
     69e:	4294      	cmp	r4, r2
     6a0:	d8f0      	bhi.n	684 <timer_add_timer_task+0x14>
			time_left = it->interval - (time - it->time_label);
     6a2:	1aa4      	subs	r4, r4, r2
     6a4:	689f      	ldr	r7, [r3, #8]
     6a6:	46bc      	mov	ip, r7
     6a8:	4464      	add	r4, ip
     6aa:	e7f0      	b.n	68e <timer_add_timer_task+0x1e>
	}

	if (it == head) {
     6ac:	42b3      	cmp	r3, r6
     6ae:	d003      	beq.n	6b8 <timer_add_timer_task+0x48>
		list_insert_as_head(list, new_task);
	} else {
		list_insert_after(prev, new_task);
     6b0:	0028      	movs	r0, r5
     6b2:	4b04      	ldr	r3, [pc, #16]	; (6c4 <timer_add_timer_task+0x54>)
     6b4:	4798      	blx	r3
	}
}
     6b6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		list_insert_as_head(list, new_task);
     6b8:	4b01      	ldr	r3, [pc, #4]	; (6c0 <timer_add_timer_task+0x50>)
     6ba:	4798      	blx	r3
     6bc:	e7fb      	b.n	6b6 <timer_add_timer_task+0x46>
     6be:	46c0      	nop			; (mov r8, r8)
     6c0:	00000a05 	.word	0x00000a05
     6c4:	00000a31 	.word	0x00000a31

000006c8 <timer_process_counted>:

/**
 * \internal Process interrupts
 */
static void timer_process_counted(struct _timer_device *device)
{
     6c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     6ca:	0005      	movs	r5, r0
     6cc:	6944      	ldr	r4, [r0, #20]
	struct timer_descriptor *timer = CONTAINER_OF(device, struct timer_descriptor, device);
	struct timer_task *      it    = (struct timer_task *)list_get_head(&timer->tasks);
	uint32_t                 time  = ++timer->time;
     6ce:	6903      	ldr	r3, [r0, #16]
     6d0:	1c5e      	adds	r6, r3, #1
     6d2:	6106      	str	r6, [r0, #16]

	if ((timer->flags & TIMER_FLAG_QUEUE_IS_TAKEN) || (timer->flags & TIMER_FLAG_INTERRUPT_TRIGERRED)) {
     6d4:	7e03      	ldrb	r3, [r0, #24]
     6d6:	07db      	lsls	r3, r3, #31
     6d8:	d402      	bmi.n	6e0 <timer_process_counted+0x18>
     6da:	7e03      	ldrb	r3, [r0, #24]
     6dc:	079b      	lsls	r3, r3, #30
     6de:	d50a      	bpl.n	6f6 <timer_process_counted+0x2e>
		timer->flags |= TIMER_FLAG_INTERRUPT_TRIGERRED;
     6e0:	7e2b      	ldrb	r3, [r5, #24]
     6e2:	2202      	movs	r2, #2
     6e4:	4313      	orrs	r3, r2
     6e6:	b2db      	uxtb	r3, r3
     6e8:	762b      	strb	r3, [r5, #24]
		}
		it = (struct timer_task *)list_get_head(&timer->tasks);

		tmp->cb(tmp);
	}
}
     6ea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     6ec:	696f      	ldr	r7, [r5, #20]
		tmp->cb(tmp);
     6ee:	68e3      	ldr	r3, [r4, #12]
     6f0:	0020      	movs	r0, r4
     6f2:	4798      	blx	r3
		it = (struct timer_task *)list_get_head(&timer->tasks);
     6f4:	003c      	movs	r4, r7
	while (it && ((time - it->time_label) >= it->interval)) {
     6f6:	2c00      	cmp	r4, #0
     6f8:	d0f7      	beq.n	6ea <timer_process_counted+0x22>
     6fa:	6863      	ldr	r3, [r4, #4]
     6fc:	1af3      	subs	r3, r6, r3
     6fe:	68a2      	ldr	r2, [r4, #8]
     700:	4293      	cmp	r3, r2
     702:	d3f2      	bcc.n	6ea <timer_process_counted+0x22>
		list_remove_head(&timer->tasks);
     704:	002f      	movs	r7, r5
     706:	3714      	adds	r7, #20
     708:	0038      	movs	r0, r7
     70a:	4b06      	ldr	r3, [pc, #24]	; (724 <timer_process_counted+0x5c>)
     70c:	4798      	blx	r3
		if (TIMER_TASK_REPEAT == tmp->mode) {
     70e:	7c23      	ldrb	r3, [r4, #16]
     710:	2b01      	cmp	r3, #1
     712:	d1eb      	bne.n	6ec <timer_process_counted+0x24>
			tmp->time_label = time;
     714:	6066      	str	r6, [r4, #4]
			timer_add_timer_task(&timer->tasks, tmp, time);
     716:	0032      	movs	r2, r6
     718:	0021      	movs	r1, r4
     71a:	0038      	movs	r0, r7
     71c:	4b02      	ldr	r3, [pc, #8]	; (728 <timer_process_counted+0x60>)
     71e:	4798      	blx	r3
     720:	e7e4      	b.n	6ec <timer_process_counted+0x24>
     722:	46c0      	nop			; (mov r8, r8)
     724:	00000a39 	.word	0x00000a39
     728:	00000671 	.word	0x00000671

0000072c <timer_init>:
{
     72c:	b570      	push	{r4, r5, r6, lr}
     72e:	0004      	movs	r4, r0
     730:	000d      	movs	r5, r1
	ASSERT(descr && hw);
     732:	2800      	cmp	r0, #0
     734:	d012      	beq.n	75c <timer_init+0x30>
     736:	2900      	cmp	r1, #0
     738:	d00e      	beq.n	758 <timer_init+0x2c>
     73a:	2001      	movs	r0, #1
     73c:	223b      	movs	r2, #59	; 0x3b
     73e:	4908      	ldr	r1, [pc, #32]	; (760 <timer_init+0x34>)
     740:	4b08      	ldr	r3, [pc, #32]	; (764 <timer_init+0x38>)
     742:	4798      	blx	r3
	_timer_init(&descr->device, hw);
     744:	0029      	movs	r1, r5
     746:	0020      	movs	r0, r4
     748:	4b07      	ldr	r3, [pc, #28]	; (768 <timer_init+0x3c>)
     74a:	4798      	blx	r3
	descr->time                           = 0;
     74c:	2300      	movs	r3, #0
     74e:	6123      	str	r3, [r4, #16]
	descr->device.timer_cb.period_expired = timer_process_counted;
     750:	4b06      	ldr	r3, [pc, #24]	; (76c <timer_init+0x40>)
     752:	6023      	str	r3, [r4, #0]
}
     754:	2000      	movs	r0, #0
     756:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && hw);
     758:	2000      	movs	r0, #0
     75a:	e7ef      	b.n	73c <timer_init+0x10>
     75c:	2000      	movs	r0, #0
     75e:	e7ed      	b.n	73c <timer_init+0x10>
     760:	000049d0 	.word	0x000049d0
     764:	000009e5 	.word	0x000009e5
     768:	00000cf9 	.word	0x00000cf9
     76c:	000006c9 	.word	0x000006c9

00000770 <timer_start>:
{
     770:	b510      	push	{r4, lr}
     772:	0004      	movs	r4, r0
	ASSERT(descr);
     774:	1e43      	subs	r3, r0, #1
     776:	4198      	sbcs	r0, r3
     778:	b2c0      	uxtb	r0, r0
     77a:	2253      	movs	r2, #83	; 0x53
     77c:	4907      	ldr	r1, [pc, #28]	; (79c <timer_start+0x2c>)
     77e:	4b08      	ldr	r3, [pc, #32]	; (7a0 <timer_start+0x30>)
     780:	4798      	blx	r3
	if (_timer_is_started(&descr->device)) {
     782:	0020      	movs	r0, r4
     784:	4b07      	ldr	r3, [pc, #28]	; (7a4 <timer_start+0x34>)
     786:	4798      	blx	r3
     788:	2800      	cmp	r0, #0
     78a:	d104      	bne.n	796 <timer_start+0x26>
	_timer_start(&descr->device);
     78c:	0020      	movs	r0, r4
     78e:	4b06      	ldr	r3, [pc, #24]	; (7a8 <timer_start+0x38>)
     790:	4798      	blx	r3
	return ERR_NONE;
     792:	2000      	movs	r0, #0
}
     794:	bd10      	pop	{r4, pc}
		return ERR_DENIED;
     796:	2011      	movs	r0, #17
     798:	4240      	negs	r0, r0
     79a:	e7fb      	b.n	794 <timer_start+0x24>
     79c:	000049d0 	.word	0x000049d0
     7a0:	000009e5 	.word	0x000009e5
     7a4:	00000dad 	.word	0x00000dad
     7a8:	00000d55 	.word	0x00000d55

000007ac <timer_add_task>:
{
     7ac:	b570      	push	{r4, r5, r6, lr}
     7ae:	b082      	sub	sp, #8
     7b0:	0004      	movs	r4, r0
     7b2:	000d      	movs	r5, r1
	ASSERT(descr && task);
     7b4:	2800      	cmp	r0, #0
     7b6:	d026      	beq.n	806 <timer_add_task+0x5a>
     7b8:	2900      	cmp	r1, #0
     7ba:	d022      	beq.n	802 <timer_add_task+0x56>
     7bc:	2001      	movs	r0, #1
     7be:	227a      	movs	r2, #122	; 0x7a
     7c0:	491f      	ldr	r1, [pc, #124]	; (840 <timer_add_task+0x94>)
     7c2:	4b20      	ldr	r3, [pc, #128]	; (844 <timer_add_task+0x98>)
     7c4:	4798      	blx	r3
	descr->flags |= TIMER_FLAG_QUEUE_IS_TAKEN;
     7c6:	7e23      	ldrb	r3, [r4, #24]
     7c8:	2201      	movs	r2, #1
     7ca:	4313      	orrs	r3, r2
     7cc:	b2db      	uxtb	r3, r3
     7ce:	7623      	strb	r3, [r4, #24]
	if (is_list_element(&descr->tasks, task)) {
     7d0:	0026      	movs	r6, r4
     7d2:	3614      	adds	r6, #20
     7d4:	0029      	movs	r1, r5
     7d6:	0030      	movs	r0, r6
     7d8:	4b1b      	ldr	r3, [pc, #108]	; (848 <timer_add_task+0x9c>)
     7da:	4798      	blx	r3
     7dc:	2800      	cmp	r0, #0
     7de:	d114      	bne.n	80a <timer_add_task+0x5e>
	task->time_label = descr->time;
     7e0:	6923      	ldr	r3, [r4, #16]
     7e2:	606b      	str	r3, [r5, #4]
	timer_add_timer_task(&descr->tasks, task, descr->time);
     7e4:	6922      	ldr	r2, [r4, #16]
     7e6:	0029      	movs	r1, r5
     7e8:	0030      	movs	r0, r6
     7ea:	4b18      	ldr	r3, [pc, #96]	; (84c <timer_add_task+0xa0>)
     7ec:	4798      	blx	r3
	descr->flags &= ~TIMER_FLAG_QUEUE_IS_TAKEN;
     7ee:	7e23      	ldrb	r3, [r4, #24]
     7f0:	2201      	movs	r2, #1
     7f2:	4393      	bics	r3, r2
     7f4:	7623      	strb	r3, [r4, #24]
	if (descr->flags & TIMER_FLAG_INTERRUPT_TRIGERRED) {
     7f6:	7e23      	ldrb	r3, [r4, #24]
     7f8:	079b      	lsls	r3, r3, #30
     7fa:	d412      	bmi.n	822 <timer_add_task+0x76>
	return ERR_NONE;
     7fc:	2000      	movs	r0, #0
}
     7fe:	b002      	add	sp, #8
     800:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && task);
     802:	2000      	movs	r0, #0
     804:	e7db      	b.n	7be <timer_add_task+0x12>
     806:	2000      	movs	r0, #0
     808:	e7d9      	b.n	7be <timer_add_task+0x12>
		descr->flags &= ~TIMER_FLAG_QUEUE_IS_TAKEN;
     80a:	7e23      	ldrb	r3, [r4, #24]
     80c:	2201      	movs	r2, #1
     80e:	4393      	bics	r3, r2
     810:	7623      	strb	r3, [r4, #24]
		ASSERT(false);
     812:	327e      	adds	r2, #126	; 0x7e
     814:	490a      	ldr	r1, [pc, #40]	; (840 <timer_add_task+0x94>)
     816:	2000      	movs	r0, #0
     818:	4b0a      	ldr	r3, [pc, #40]	; (844 <timer_add_task+0x98>)
     81a:	4798      	blx	r3
		return ERR_ALREADY_INITIALIZED;
     81c:	2012      	movs	r0, #18
     81e:	4240      	negs	r0, r0
     820:	e7ed      	b.n	7fe <timer_add_task+0x52>
		CRITICAL_SECTION_ENTER()
     822:	a801      	add	r0, sp, #4
     824:	4b0a      	ldr	r3, [pc, #40]	; (850 <timer_add_task+0xa4>)
     826:	4798      	blx	r3
		descr->flags &= ~TIMER_FLAG_INTERRUPT_TRIGERRED;
     828:	7e23      	ldrb	r3, [r4, #24]
     82a:	2202      	movs	r2, #2
     82c:	4393      	bics	r3, r2
     82e:	7623      	strb	r3, [r4, #24]
		_timer_set_irq(&descr->device);
     830:	0020      	movs	r0, r4
     832:	4b08      	ldr	r3, [pc, #32]	; (854 <timer_add_task+0xa8>)
     834:	4798      	blx	r3
		CRITICAL_SECTION_LEAVE()
     836:	a801      	add	r0, sp, #4
     838:	4b07      	ldr	r3, [pc, #28]	; (858 <timer_add_task+0xac>)
     83a:	4798      	blx	r3
	return ERR_NONE;
     83c:	2000      	movs	r0, #0
     83e:	e7de      	b.n	7fe <timer_add_task+0x52>
     840:	000049d0 	.word	0x000049d0
     844:	000009e5 	.word	0x000009e5
     848:	000009ed 	.word	0x000009ed
     84c:	00000671 	.word	0x00000671
     850:	0000017d 	.word	0x0000017d
     854:	00000dbf 	.word	0x00000dbf
     858:	0000018b 	.word	0x0000018b

0000085c <usart_sync_write>:
 * \param[in] length The number of bytes to write
 *
 * \return The number of bytes written.
 */
static int32_t usart_sync_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
     85c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     85e:	0005      	movs	r5, r0
     860:	000e      	movs	r6, r1
     862:	0017      	movs	r7, r2
	uint32_t                      offset = 0;
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);

	ASSERT(io_descr && buf && length);
     864:	2800      	cmp	r0, #0
     866:	d023      	beq.n	8b0 <usart_sync_write+0x54>
     868:	2900      	cmp	r1, #0
     86a:	d023      	beq.n	8b4 <usart_sync_write+0x58>
     86c:	2a00      	cmp	r2, #0
     86e:	d123      	bne.n	8b8 <usart_sync_write+0x5c>
     870:	2000      	movs	r0, #0
     872:	22f1      	movs	r2, #241	; 0xf1
     874:	4911      	ldr	r1, [pc, #68]	; (8bc <usart_sync_write+0x60>)
     876:	4b12      	ldr	r3, [pc, #72]	; (8c0 <usart_sync_write+0x64>)
     878:	4798      	blx	r3
	while (!_usart_sync_is_ready_to_send(&descr->device))
     87a:	002c      	movs	r4, r5
     87c:	3408      	adds	r4, #8
     87e:	0020      	movs	r0, r4
     880:	4b10      	ldr	r3, [pc, #64]	; (8c4 <usart_sync_write+0x68>)
     882:	4798      	blx	r3
     884:	2800      	cmp	r0, #0
     886:	d0f8      	beq.n	87a <usart_sync_write+0x1e>
     888:	2500      	movs	r5, #0
		;
	do {
		_usart_sync_write_byte(&descr->device, buf[offset]);
     88a:	5d71      	ldrb	r1, [r6, r5]
     88c:	0020      	movs	r0, r4
     88e:	4b0e      	ldr	r3, [pc, #56]	; (8c8 <usart_sync_write+0x6c>)
     890:	4798      	blx	r3
		while (!_usart_sync_is_ready_to_send(&descr->device))
     892:	0020      	movs	r0, r4
     894:	4b0b      	ldr	r3, [pc, #44]	; (8c4 <usart_sync_write+0x68>)
     896:	4798      	blx	r3
     898:	2800      	cmp	r0, #0
     89a:	d0fa      	beq.n	892 <usart_sync_write+0x36>
			;
	} while (++offset < length);
     89c:	3501      	adds	r5, #1
     89e:	42bd      	cmp	r5, r7
     8a0:	d3f3      	bcc.n	88a <usart_sync_write+0x2e>
	while (!_usart_sync_is_transmit_done(&descr->device))
     8a2:	0020      	movs	r0, r4
     8a4:	4b09      	ldr	r3, [pc, #36]	; (8cc <usart_sync_write+0x70>)
     8a6:	4798      	blx	r3
     8a8:	2800      	cmp	r0, #0
     8aa:	d0fa      	beq.n	8a2 <usart_sync_write+0x46>
		;
	return (int32_t)offset;
}
     8ac:	0028      	movs	r0, r5
     8ae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	ASSERT(io_descr && buf && length);
     8b0:	2000      	movs	r0, #0
     8b2:	e7de      	b.n	872 <usart_sync_write+0x16>
     8b4:	2000      	movs	r0, #0
     8b6:	e7dc      	b.n	872 <usart_sync_write+0x16>
     8b8:	2001      	movs	r0, #1
     8ba:	e7da      	b.n	872 <usart_sync_write+0x16>
     8bc:	000049e8 	.word	0x000049e8
     8c0:	000009e5 	.word	0x000009e5
     8c4:	000010eb 	.word	0x000010eb
     8c8:	000010db 	.word	0x000010db
     8cc:	000010f5 	.word	0x000010f5

000008d0 <usart_sync_read>:
 * \param[in] length The size of a buffer
 *
 * \return The number of bytes read.
 */
static int32_t usart_sync_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
     8d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     8d2:	46ce      	mov	lr, r9
     8d4:	4647      	mov	r7, r8
     8d6:	b580      	push	{r7, lr}
     8d8:	1e05      	subs	r5, r0, #0
     8da:	4688      	mov	r8, r1
     8dc:	4691      	mov	r9, r2
	uint32_t                      offset = 0;
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);

	ASSERT(io_descr && buf && length);
     8de:	d01f      	beq.n	920 <usart_sync_read+0x50>
     8e0:	2900      	cmp	r1, #0
     8e2:	d01f      	beq.n	924 <usart_sync_read+0x54>
     8e4:	2a00      	cmp	r2, #0
     8e6:	d11f      	bne.n	928 <usart_sync_read+0x58>
     8e8:	2000      	movs	r0, #0
     8ea:	2286      	movs	r2, #134	; 0x86
     8ec:	0052      	lsls	r2, r2, #1
     8ee:	490f      	ldr	r1, [pc, #60]	; (92c <usart_sync_read+0x5c>)
     8f0:	4b0f      	ldr	r3, [pc, #60]	; (930 <usart_sync_read+0x60>)
     8f2:	4798      	blx	r3
	uint32_t                      offset = 0;
     8f4:	2600      	movs	r6, #0
	do {
		while (!_usart_sync_is_byte_received(&descr->device))
     8f6:	002c      	movs	r4, r5
     8f8:	3408      	adds	r4, #8
     8fa:	0020      	movs	r0, r4
     8fc:	4b0d      	ldr	r3, [pc, #52]	; (934 <usart_sync_read+0x64>)
     8fe:	4798      	blx	r3
     900:	2800      	cmp	r0, #0
     902:	d0f8      	beq.n	8f6 <usart_sync_read+0x26>
			;
		buf[offset] = _usart_sync_read_byte(&descr->device);
     904:	4643      	mov	r3, r8
     906:	199f      	adds	r7, r3, r6
     908:	0020      	movs	r0, r4
     90a:	4b0b      	ldr	r3, [pc, #44]	; (938 <usart_sync_read+0x68>)
     90c:	4798      	blx	r3
     90e:	7038      	strb	r0, [r7, #0]
	} while (++offset < length);
     910:	3601      	adds	r6, #1
     912:	454e      	cmp	r6, r9
     914:	d3ef      	bcc.n	8f6 <usart_sync_read+0x26>

	return (int32_t)offset;
}
     916:	0030      	movs	r0, r6
     918:	bc0c      	pop	{r2, r3}
     91a:	4690      	mov	r8, r2
     91c:	4699      	mov	r9, r3
     91e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	ASSERT(io_descr && buf && length);
     920:	2000      	movs	r0, #0
     922:	e7e2      	b.n	8ea <usart_sync_read+0x1a>
     924:	2000      	movs	r0, #0
     926:	e7e0      	b.n	8ea <usart_sync_read+0x1a>
     928:	2001      	movs	r0, #1
     92a:	e7de      	b.n	8ea <usart_sync_read+0x1a>
     92c:	000049e8 	.word	0x000049e8
     930:	000009e5 	.word	0x000009e5
     934:	00001101 	.word	0x00001101
     938:	000010e3 	.word	0x000010e3

0000093c <usart_sync_init>:
{
     93c:	b570      	push	{r4, r5, r6, lr}
     93e:	0004      	movs	r4, r0
     940:	000d      	movs	r5, r1
	ASSERT(descr && hw);
     942:	2800      	cmp	r0, #0
     944:	d014      	beq.n	970 <usart_sync_init+0x34>
     946:	2900      	cmp	r1, #0
     948:	d010      	beq.n	96c <usart_sync_init+0x30>
     94a:	2001      	movs	r0, #1
     94c:	2234      	movs	r2, #52	; 0x34
     94e:	4909      	ldr	r1, [pc, #36]	; (974 <usart_sync_init+0x38>)
     950:	4b09      	ldr	r3, [pc, #36]	; (978 <usart_sync_init+0x3c>)
     952:	4798      	blx	r3
	init_status = _usart_sync_init(&descr->device, hw);
     954:	0020      	movs	r0, r4
     956:	3008      	adds	r0, #8
     958:	0029      	movs	r1, r5
     95a:	4b08      	ldr	r3, [pc, #32]	; (97c <usart_sync_init+0x40>)
     95c:	4798      	blx	r3
	if (init_status) {
     95e:	2800      	cmp	r0, #0
     960:	d103      	bne.n	96a <usart_sync_init+0x2e>
	descr->io.read  = usart_sync_read;
     962:	4b07      	ldr	r3, [pc, #28]	; (980 <usart_sync_init+0x44>)
     964:	6063      	str	r3, [r4, #4]
	descr->io.write = usart_sync_write;
     966:	4b07      	ldr	r3, [pc, #28]	; (984 <usart_sync_init+0x48>)
     968:	6023      	str	r3, [r4, #0]
}
     96a:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && hw);
     96c:	2000      	movs	r0, #0
     96e:	e7ed      	b.n	94c <usart_sync_init+0x10>
     970:	2000      	movs	r0, #0
     972:	e7eb      	b.n	94c <usart_sync_init+0x10>
     974:	000049e8 	.word	0x000049e8
     978:	000009e5 	.word	0x000009e5
     97c:	0000109d 	.word	0x0000109d
     980:	000008d1 	.word	0x000008d1
     984:	0000085d 	.word	0x0000085d

00000988 <usart_sync_enable>:
{
     988:	b510      	push	{r4, lr}
     98a:	0004      	movs	r4, r0
	ASSERT(descr);
     98c:	1e43      	subs	r3, r0, #1
     98e:	4198      	sbcs	r0, r3
     990:	b2c0      	uxtb	r0, r0
     992:	2253      	movs	r2, #83	; 0x53
     994:	4904      	ldr	r1, [pc, #16]	; (9a8 <usart_sync_enable+0x20>)
     996:	4b05      	ldr	r3, [pc, #20]	; (9ac <usart_sync_enable+0x24>)
     998:	4798      	blx	r3
	_usart_sync_enable(&descr->device);
     99a:	0020      	movs	r0, r4
     99c:	3008      	adds	r0, #8
     99e:	4b04      	ldr	r3, [pc, #16]	; (9b0 <usart_sync_enable+0x28>)
     9a0:	4798      	blx	r3
}
     9a2:	2000      	movs	r0, #0
     9a4:	bd10      	pop	{r4, pc}
     9a6:	46c0      	nop			; (mov r8, r8)
     9a8:	000049e8 	.word	0x000049e8
     9ac:	000009e5 	.word	0x000009e5
     9b0:	000010c9 	.word	0x000010c9

000009b4 <usart_sync_get_io_descriptor>:
{
     9b4:	b570      	push	{r4, r5, r6, lr}
     9b6:	0004      	movs	r4, r0
     9b8:	000d      	movs	r5, r1
	ASSERT(descr && io);
     9ba:	2800      	cmp	r0, #0
     9bc:	d00b      	beq.n	9d6 <usart_sync_get_io_descriptor+0x22>
     9be:	2900      	cmp	r1, #0
     9c0:	d007      	beq.n	9d2 <usart_sync_get_io_descriptor+0x1e>
     9c2:	2001      	movs	r0, #1
     9c4:	2269      	movs	r2, #105	; 0x69
     9c6:	4905      	ldr	r1, [pc, #20]	; (9dc <usart_sync_get_io_descriptor+0x28>)
     9c8:	4b05      	ldr	r3, [pc, #20]	; (9e0 <usart_sync_get_io_descriptor+0x2c>)
     9ca:	4798      	blx	r3
	*io = &descr->io;
     9cc:	602c      	str	r4, [r5, #0]
}
     9ce:	2000      	movs	r0, #0
     9d0:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && io);
     9d2:	2000      	movs	r0, #0
     9d4:	e7f6      	b.n	9c4 <usart_sync_get_io_descriptor+0x10>
     9d6:	2000      	movs	r0, #0
     9d8:	e7f4      	b.n	9c4 <usart_sync_get_io_descriptor+0x10>
     9da:	46c0      	nop			; (mov r8, r8)
     9dc:	000049e8 	.word	0x000049e8
     9e0:	000009e5 	.word	0x000009e5

000009e4 <assert>:
/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
	if (!(condition)) {
     9e4:	2800      	cmp	r0, #0
     9e6:	d100      	bne.n	9ea <assert+0x6>
		__asm("BKPT #0");
     9e8:	be00      	bkpt	0x0000
	}
	(void)file;
	(void)line;
}
     9ea:	4770      	bx	lr

000009ec <is_list_element>:
 * \brief Check whether element belongs to list
 */
bool is_list_element(const struct list_descriptor *const list, const void *const element)
{
	struct list_element *it;
	for (it = list->head; it; it = it->next) {
     9ec:	6803      	ldr	r3, [r0, #0]
     9ee:	2b00      	cmp	r3, #0
     9f0:	d003      	beq.n	9fa <is_list_element+0xe>
		if (it == element) {
     9f2:	428b      	cmp	r3, r1
     9f4:	d003      	beq.n	9fe <is_list_element+0x12>
	for (it = list->head; it; it = it->next) {
     9f6:	681b      	ldr	r3, [r3, #0]
     9f8:	e7f9      	b.n	9ee <is_list_element+0x2>
			return true;
		}
	}

	return false;
     9fa:	2000      	movs	r0, #0
}
     9fc:	4770      	bx	lr
			return true;
     9fe:	2001      	movs	r0, #1
     a00:	e7fc      	b.n	9fc <is_list_element+0x10>
	...

00000a04 <list_insert_as_head>:

/**
 * \brief Insert an element as list head
 */
void list_insert_as_head(struct list_descriptor *const list, void *const element)
{
     a04:	b570      	push	{r4, r5, r6, lr}
     a06:	0004      	movs	r4, r0
     a08:	000d      	movs	r5, r1
	ASSERT(!is_list_element(list, element));
     a0a:	4b06      	ldr	r3, [pc, #24]	; (a24 <list_insert_as_head+0x20>)
     a0c:	4798      	blx	r3
     a0e:	2301      	movs	r3, #1
     a10:	4058      	eors	r0, r3
     a12:	b2c0      	uxtb	r0, r0
     a14:	2239      	movs	r2, #57	; 0x39
     a16:	4904      	ldr	r1, [pc, #16]	; (a28 <list_insert_as_head+0x24>)
     a18:	4b04      	ldr	r3, [pc, #16]	; (a2c <list_insert_as_head+0x28>)
     a1a:	4798      	blx	r3

	((struct list_element *)element)->next = list->head;
     a1c:	6823      	ldr	r3, [r4, #0]
     a1e:	602b      	str	r3, [r5, #0]
	list->head                             = (struct list_element *)element;
     a20:	6025      	str	r5, [r4, #0]
}
     a22:	bd70      	pop	{r4, r5, r6, pc}
     a24:	000009ed 	.word	0x000009ed
     a28:	00004a04 	.word	0x00004a04
     a2c:	000009e5 	.word	0x000009e5

00000a30 <list_insert_after>:
/**
 * \brief Insert an element after the given list element
 */
void list_insert_after(void *const after, void *const element)
{
	((struct list_element *)element)->next = ((struct list_element *)after)->next;
     a30:	6803      	ldr	r3, [r0, #0]
     a32:	600b      	str	r3, [r1, #0]
	((struct list_element *)after)->next   = (struct list_element *)element;
     a34:	6001      	str	r1, [r0, #0]
}
     a36:	4770      	bx	lr

00000a38 <list_remove_head>:
/**
 * \brief Removes list head
 */
void *list_remove_head(struct list_descriptor *const list)
{
	if (list->head) {
     a38:	6803      	ldr	r3, [r0, #0]
     a3a:	2b00      	cmp	r3, #0
     a3c:	d003      	beq.n	a46 <list_remove_head+0xe>
		struct list_element *tmp = list->head;

		list->head = list->head->next;
     a3e:	681a      	ldr	r2, [r3, #0]
     a40:	6002      	str	r2, [r0, #0]
		return (void *)tmp;
     a42:	0018      	movs	r0, r3
	}

	return NULL;
}
     a44:	4770      	bx	lr
	return NULL;
     a46:	2000      	movs	r0, #0
     a48:	e7fc      	b.n	a44 <list_remove_head+0xc>
	...

00000a4c <_sbrk>:

/**
 * \brief Replacement of C library of _sbrk
 */
extern caddr_t _sbrk(int incr)
{
     a4c:	0003      	movs	r3, r0
	static unsigned char *heap = NULL;
	unsigned char *       prev_heap;

	if (heap == NULL) {
     a4e:	4a06      	ldr	r2, [pc, #24]	; (a68 <_sbrk+0x1c>)
     a50:	6812      	ldr	r2, [r2, #0]
     a52:	2a00      	cmp	r2, #0
     a54:	d004      	beq.n	a60 <_sbrk+0x14>
		heap = (unsigned char *)&_end;
	}
	prev_heap = heap;
     a56:	4a04      	ldr	r2, [pc, #16]	; (a68 <_sbrk+0x1c>)
     a58:	6810      	ldr	r0, [r2, #0]

	heap += incr;
     a5a:	18c3      	adds	r3, r0, r3
     a5c:	6013      	str	r3, [r2, #0]

	return (caddr_t)prev_heap;
}
     a5e:	4770      	bx	lr
		heap = (unsigned char *)&_end;
     a60:	4902      	ldr	r1, [pc, #8]	; (a6c <_sbrk+0x20>)
     a62:	4a01      	ldr	r2, [pc, #4]	; (a68 <_sbrk+0x1c>)
     a64:	6011      	str	r1, [r2, #0]
     a66:	e7f6      	b.n	a56 <_sbrk+0xa>
     a68:	20000120 	.word	0x20000120
     a6c:	20002b38 	.word	0x20002b38

00000a70 <_get_cycles_for_ms>:

/**
 * \brief Retrieve the amount of cycles to delay for the given amount of ms
 */
uint32_t _get_cycles_for_ms(const uint16_t ms)
{
     a70:	b510      	push	{r4, lr}
		return (ms * (freq / 100000) + 2) / 3 * 100;
     a72:	0103      	lsls	r3, r0, #4
     a74:	1a1b      	subs	r3, r3, r0
     a76:	0158      	lsls	r0, r3, #5
     a78:	3002      	adds	r0, #2
     a7a:	2103      	movs	r1, #3
     a7c:	4b02      	ldr	r3, [pc, #8]	; (a88 <_get_cycles_for_ms+0x18>)
     a7e:	4798      	blx	r3
     a80:	2364      	movs	r3, #100	; 0x64
     a82:	4358      	muls	r0, r3
	return _get_cycles_for_ms_internal(ms, CONF_CPU_FREQUENCY, CPU_FREQ_POWER);
}
     a84:	bd10      	pop	{r4, pc}
     a86:	46c0      	nop			; (mov r8, r8)
     a88:	00003e95 	.word	0x00003e95

00000a8c <_delay_cycles>:
{
#ifndef _UNIT_TEST_
	(void)hw;
	(void)cycles;
#if defined __GNUC__
	__asm(".syntax unified\n"
     a8c:	3901      	subs	r1, #1
     a8e:	d8fd      	bhi.n	a8c <_delay_cycles>
	__asm("__delay:\n"
	      "subs r1, r1, #1\n"
	      "bhi __delay\n");
#endif
#endif
}
     a90:	4770      	bx	lr
	...

00000a94 <_init_chip>:

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
     a94:	b510      	push	{r4, lr}
}

static inline void hri_nvmctrl_set_CTRLB_RWS_bf(const void *const hw, hri_nvmctrl_ctrlb_reg_t mask)
{
	NVMCTRL_CRITICAL_SECTION_ENTER();
	((Nvmctrl *)hw)->CTRLB.reg |= NVMCTRL_CTRLB_RWS(mask);
     a96:	4a08      	ldr	r2, [pc, #32]	; (ab8 <_init_chip+0x24>)
     a98:	6853      	ldr	r3, [r2, #4]
     a9a:	2106      	movs	r1, #6
     a9c:	430b      	orrs	r3, r1
     a9e:	6053      	str	r3, [r2, #4]
	hri_nvmctrl_set_CTRLB_RWS_bf(NVMCTRL, CONF_NVM_WAIT_STATE);

	_pm_init();
     aa0:	4b06      	ldr	r3, [pc, #24]	; (abc <_init_chip+0x28>)
     aa2:	4798      	blx	r3
	_sysctrl_init_sources();
     aa4:	4b06      	ldr	r3, [pc, #24]	; (ac0 <_init_chip+0x2c>)
     aa6:	4798      	blx	r3
#if _GCLK_INIT_1ST
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
     aa8:	2008      	movs	r0, #8
     aaa:	4c06      	ldr	r4, [pc, #24]	; (ac4 <_init_chip+0x30>)
     aac:	47a0      	blx	r4
#endif
	_sysctrl_init_referenced_generators();
     aae:	4b06      	ldr	r3, [pc, #24]	; (ac8 <_init_chip+0x34>)
     ab0:	4798      	blx	r3
	_gclk_init_generators_by_fref(_GCLK_INIT_LAST);
     ab2:	20f7      	movs	r0, #247	; 0xf7
     ab4:	47a0      	blx	r4
}
     ab6:	bd10      	pop	{r4, pc}
     ab8:	41004000 	.word	0x41004000
     abc:	00000cbd 	.word	0x00000cbd
     ac0:	0000172d 	.word	0x0000172d
     ac4:	00000c61 	.word	0x00000c61
     ac8:	00001779 	.word	0x00001779

00000acc <_ext_irq_init>:
typedef uint8_t  hri_eic_nmiflag_reg_t;
typedef uint8_t  hri_eic_status_reg_t;

static inline void hri_eic_wait_for_sync(const void *const hw)
{
	while (((const Eic *)hw)->STATUS.bit.SYNCBUSY)
     acc:	4b20      	ldr	r3, [pc, #128]	; (b50 <_ext_irq_init+0x84>)
     ace:	785b      	ldrb	r3, [r3, #1]
     ad0:	09db      	lsrs	r3, r3, #7
     ad2:	d1fb      	bne.n	acc <_ext_irq_init>
     ad4:	4b1e      	ldr	r3, [pc, #120]	; (b50 <_ext_irq_init+0x84>)
     ad6:	785b      	ldrb	r3, [r3, #1]
     ad8:	09db      	lsrs	r3, r3, #7
     ada:	d1fb      	bne.n	ad4 <_ext_irq_init+0x8>

static inline hri_eic_ctrl_reg_t hri_eic_get_CTRL_reg(const void *const hw, hri_eic_ctrl_reg_t mask)
{
	uint8_t tmp;
	hri_eic_wait_for_sync(hw);
	tmp = ((Eic *)hw)->CTRL.reg;
     adc:	4b1c      	ldr	r3, [pc, #112]	; (b50 <_ext_irq_init+0x84>)
     ade:	781b      	ldrb	r3, [r3, #0]
 * \brief Initialize external interrupt module
 */
int32_t _ext_irq_init(void (*cb)(const uint32_t pin))
{
	hri_eic_wait_for_sync(EIC);
	if (hri_eic_get_CTRL_reg(EIC, EIC_CTRL_ENABLE)) {
     ae0:	079b      	lsls	r3, r3, #30
     ae2:	d50a      	bpl.n	afa <_ext_irq_init+0x2e>
}

static inline void hri_eic_write_CTRL_reg(const void *const hw, hri_eic_ctrl_reg_t data)
{
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->CTRL.reg = data;
     ae4:	2200      	movs	r2, #0
     ae6:	4b1a      	ldr	r3, [pc, #104]	; (b50 <_ext_irq_init+0x84>)
     ae8:	701a      	strb	r2, [r3, #0]
	while (((const Eic *)hw)->STATUS.bit.SYNCBUSY)
     aea:	4b19      	ldr	r3, [pc, #100]	; (b50 <_ext_irq_init+0x84>)
     aec:	785b      	ldrb	r3, [r3, #1]
     aee:	09db      	lsrs	r3, r3, #7
     af0:	d1fb      	bne.n	aea <_ext_irq_init+0x1e>
     af2:	4b17      	ldr	r3, [pc, #92]	; (b50 <_ext_irq_init+0x84>)
     af4:	785b      	ldrb	r3, [r3, #1]
     af6:	09db      	lsrs	r3, r3, #7
     af8:	d1fb      	bne.n	af2 <_ext_irq_init+0x26>
	((Eic *)hw)->CTRL.reg = data;
     afa:	2201      	movs	r2, #1
     afc:	4b14      	ldr	r3, [pc, #80]	; (b50 <_ext_irq_init+0x84>)
     afe:	701a      	strb	r2, [r3, #0]
	while (((const Eic *)hw)->STATUS.bit.SYNCBUSY)
     b00:	4b13      	ldr	r3, [pc, #76]	; (b50 <_ext_irq_init+0x84>)
     b02:	785b      	ldrb	r3, [r3, #1]
     b04:	09db      	lsrs	r3, r3, #7
     b06:	d1fb      	bne.n	b00 <_ext_irq_init+0x34>
     b08:	4b11      	ldr	r3, [pc, #68]	; (b50 <_ext_irq_init+0x84>)
     b0a:	785b      	ldrb	r3, [r3, #1]
     b0c:	09db      	lsrs	r3, r3, #7
     b0e:	d1fb      	bne.n	b08 <_ext_irq_init+0x3c>
}

static inline void hri_eic_write_NMICTRL_reg(const void *const hw, hri_eic_nmictrl_reg_t data)
{
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->NMICTRL.reg = data;
     b10:	4b0f      	ldr	r3, [pc, #60]	; (b50 <_ext_irq_init+0x84>)
     b12:	2200      	movs	r2, #0
     b14:	709a      	strb	r2, [r3, #2]
}

static inline void hri_eic_write_EVCTRL_reg(const void *const hw, hri_eic_evctrl_reg_t data)
{
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->EVCTRL.reg = data;
     b16:	605a      	str	r2, [r3, #4]
}

static inline void hri_eic_write_WAKEUP_reg(const void *const hw, hri_eic_wakeup_reg_t data)
{
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->WAKEUP.reg = data;
     b18:	615a      	str	r2, [r3, #20]
}

static inline void hri_eic_write_CONFIG_reg(const void *const hw, uint8_t index, hri_eic_config_reg_t data)
{
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->CONFIG[index].reg = data;
     b1a:	619a      	str	r2, [r3, #24]
     b1c:	61da      	str	r2, [r3, #28]
	((Eic *)hw)->CTRL.reg |= EIC_CTRL_ENABLE;
     b1e:	781a      	ldrb	r2, [r3, #0]
     b20:	2102      	movs	r1, #2
     b22:	430a      	orrs	r2, r1
     b24:	b2d2      	uxtb	r2, r2
     b26:	701a      	strb	r2, [r3, #0]
	while (((const Eic *)hw)->STATUS.bit.SYNCBUSY)
     b28:	4b09      	ldr	r3, [pc, #36]	; (b50 <_ext_irq_init+0x84>)
     b2a:	785b      	ldrb	r3, [r3, #1]
     b2c:	09db      	lsrs	r3, r3, #7
     b2e:	d1fb      	bne.n	b28 <_ext_irq_init+0x5c>
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
     b30:	4b08      	ldr	r3, [pc, #32]	; (b54 <_ext_irq_init+0x88>)
     b32:	2210      	movs	r2, #16
     b34:	2180      	movs	r1, #128	; 0x80
     b36:	505a      	str	r2, [r3, r1]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
     b38:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
     b3c:	f3bf 8f6f 	isb	sy
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
     b40:	3101      	adds	r1, #1
     b42:	31ff      	adds	r1, #255	; 0xff
     b44:	505a      	str	r2, [r3, r1]
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
     b46:	601a      	str	r2, [r3, #0]

	NVIC_DisableIRQ(EIC_IRQn);
	NVIC_ClearPendingIRQ(EIC_IRQn);
	NVIC_EnableIRQ(EIC_IRQn);

	callback = cb;
     b48:	4b03      	ldr	r3, [pc, #12]	; (b58 <_ext_irq_init+0x8c>)
     b4a:	6018      	str	r0, [r3, #0]

	return ERR_NONE;
}
     b4c:	2000      	movs	r0, #0
     b4e:	4770      	bx	lr
     b50:	40001800 	.word	0x40001800
     b54:	e000e100 	.word	0xe000e100
     b58:	20000124 	.word	0x20000124

00000b5c <_ext_irq_enable>:
 * \brief Enable / disable external irq
 */
int32_t _ext_irq_enable(const uint32_t pin, const bool enable)
{
	uint8_t extint = INVALID_EXTINT_NUMBER;
	uint8_t i      = 0;
     b5c:	2300      	movs	r3, #0

	for (; i < ARRAY_SIZE(_map); i++) {
     b5e:	2b00      	cmp	r3, #0
     b60:	d00b      	beq.n	b7a <_ext_irq_enable+0x1e>
	uint8_t extint = INVALID_EXTINT_NUMBER;
     b62:	22ff      	movs	r2, #255	; 0xff
		if (_map[i].pin == pin) {
			extint = _map[i].extint;
			break;
		}
	}
	if (INVALID_EXTINT_NUMBER == extint) {
     b64:	2aff      	cmp	r2, #255	; 0xff
     b66:	d017      	beq.n	b98 <_ext_irq_enable+0x3c>
		return ERR_INVALID_ARG;
	}

	if (enable) {
     b68:	2900      	cmp	r1, #0
     b6a:	d10f      	bne.n	b8c <_ext_irq_enable+0x30>
		hri_eic_set_INTEN_reg(EIC, 1ul << extint);
	} else {
		hri_eic_clear_INTEN_reg(EIC, 1ul << extint);
     b6c:	2301      	movs	r3, #1
     b6e:	4093      	lsls	r3, r2
	((Eic *)hw)->INTENCLR.reg = mask;
     b70:	4a0b      	ldr	r2, [pc, #44]	; (ba0 <_ext_irq_enable+0x44>)
     b72:	6093      	str	r3, [r2, #8]
	((Eic *)hw)->INTFLAG.reg = mask;
     b74:	6113      	str	r3, [r2, #16]
		hri_eic_clear_INTFLAG_reg(EIC, 1ul << extint);
	}

	return ERR_NONE;
     b76:	2000      	movs	r0, #0
}
     b78:	4770      	bx	lr
		if (_map[i].pin == pin) {
     b7a:	2828      	cmp	r0, #40	; 0x28
     b7c:	d002      	beq.n	b84 <_ext_irq_enable+0x28>
	for (; i < ARRAY_SIZE(_map); i++) {
     b7e:	3301      	adds	r3, #1
     b80:	b2db      	uxtb	r3, r3
     b82:	e7ec      	b.n	b5e <_ext_irq_enable+0x2>
			extint = _map[i].extint;
     b84:	00da      	lsls	r2, r3, #3
     b86:	4b07      	ldr	r3, [pc, #28]	; (ba4 <_ext_irq_enable+0x48>)
     b88:	5cd2      	ldrb	r2, [r2, r3]
			break;
     b8a:	e7eb      	b.n	b64 <_ext_irq_enable+0x8>
		hri_eic_set_INTEN_reg(EIC, 1ul << extint);
     b8c:	2301      	movs	r3, #1
     b8e:	4093      	lsls	r3, r2
	((Eic *)hw)->INTENSET.reg = mask;
     b90:	4a03      	ldr	r2, [pc, #12]	; (ba0 <_ext_irq_enable+0x44>)
     b92:	60d3      	str	r3, [r2, #12]
	return ERR_NONE;
     b94:	2000      	movs	r0, #0
     b96:	e7ef      	b.n	b78 <_ext_irq_enable+0x1c>
		return ERR_INVALID_ARG;
     b98:	200d      	movs	r0, #13
     b9a:	4240      	negs	r0, r0
     b9c:	e7ec      	b.n	b78 <_ext_irq_enable+0x1c>
     b9e:	46c0      	nop			; (mov r8, r8)
     ba0:	40001800 	.word	0x40001800
     ba4:	00004a24 	.word	0x00004a24

00000ba8 <EIC_Handler>:

/**
 * \brief EIC interrupt handler
 */
void EIC_Handler(void)
{
     ba8:	b570      	push	{r4, r5, r6, lr}
     baa:	b082      	sub	sp, #8
	return ((Eic *)hw)->INTFLAG.reg;
     bac:	4b26      	ldr	r3, [pc, #152]	; (c48 <EIC_Handler+0xa0>)
     bae:	691a      	ldr	r2, [r3, #16]
	return ((Eic *)hw)->INTENSET.reg;
     bb0:	68d9      	ldr	r1, [r3, #12]
	volatile uint32_t flags = hri_eic_read_INTFLAG_reg(EIC) & hri_eic_read_INTEN_reg(EIC);
     bb2:	400a      	ands	r2, r1
     bb4:	9201      	str	r2, [sp, #4]
	int8_t            pos;
	uint32_t          pin = INVALID_PIN_NUMBER;

	hri_eic_clear_INTFLAG_reg(EIC, flags);
     bb6:	9a01      	ldr	r2, [sp, #4]
	((Eic *)hw)->INTFLAG.reg = mask;
     bb8:	611a      	str	r2, [r3, #16]

	ASSERT(callback);
     bba:	4b24      	ldr	r3, [pc, #144]	; (c4c <EIC_Handler+0xa4>)
     bbc:	6818      	ldr	r0, [r3, #0]
     bbe:	1e43      	subs	r3, r0, #1
     bc0:	4198      	sbcs	r0, r3
     bc2:	b2c0      	uxtb	r0, r0
     bc4:	22d2      	movs	r2, #210	; 0xd2
     bc6:	4922      	ldr	r1, [pc, #136]	; (c50 <EIC_Handler+0xa8>)
     bc8:	4b22      	ldr	r3, [pc, #136]	; (c54 <EIC_Handler+0xac>)
     bca:	4798      	blx	r3
	uint32_t          pin = INVALID_PIN_NUMBER;
     bcc:	2501      	movs	r5, #1
     bce:	426d      	negs	r5, r5

	while (flags) {
     bd0:	e02e      	b.n	c30 <EIC_Handler+0x88>
					break;
				}
				if (_map[middle].extint < pos) {
					lower = middle + 1;
				} else {
					upper = middle - 1;
     bd2:	3901      	subs	r1, #1
     bd4:	b2ce      	uxtb	r6, r1
			while (upper >= lower) {
     bd6:	42b0      	cmp	r0, r6
     bd8:	d80e      	bhi.n	bf8 <EIC_Handler+0x50>
				middle = (upper + lower) >> 1;
     bda:	1832      	adds	r2, r6, r0
     bdc:	1052      	asrs	r2, r2, #1
     bde:	b2d1      	uxtb	r1, r2
				if (_map[middle].extint == pos) {
     be0:	23ff      	movs	r3, #255	; 0xff
     be2:	4013      	ands	r3, r2
     be4:	00db      	lsls	r3, r3, #3
     be6:	4a1c      	ldr	r2, [pc, #112]	; (c58 <EIC_Handler+0xb0>)
     be8:	5c9b      	ldrb	r3, [r3, r2]
     bea:	42a3      	cmp	r3, r4
     bec:	d003      	beq.n	bf6 <EIC_Handler+0x4e>
				if (_map[middle].extint < pos) {
     bee:	daf0      	bge.n	bd2 <EIC_Handler+0x2a>
					lower = middle + 1;
     bf0:	3101      	adds	r1, #1
     bf2:	b2c8      	uxtb	r0, r1
     bf4:	e7ef      	b.n	bd6 <EIC_Handler+0x2e>
					pin = _map[middle].pin;
     bf6:	2528      	movs	r5, #40	; 0x28
				}
			}

			if (INVALID_PIN_NUMBER != pin) {
     bf8:	1c6b      	adds	r3, r5, #1
     bfa:	d003      	beq.n	c04 <EIC_Handler+0x5c>
				callback(pin);
     bfc:	4b13      	ldr	r3, [pc, #76]	; (c4c <EIC_Handler+0xa4>)
     bfe:	681b      	ldr	r3, [r3, #0]
     c00:	0028      	movs	r0, r5
     c02:	4798      	blx	r3
			}
			flags &= ~(1ul << pos);
     c04:	2201      	movs	r2, #1
     c06:	40a2      	lsls	r2, r4
     c08:	9b01      	ldr	r3, [sp, #4]
     c0a:	4393      	bics	r3, r2
     c0c:	9301      	str	r3, [sp, #4]
			pos = ffs(flags) - 1;
     c0e:	9801      	ldr	r0, [sp, #4]
     c10:	4b12      	ldr	r3, [pc, #72]	; (c5c <EIC_Handler+0xb4>)
     c12:	4798      	blx	r3
     c14:	3801      	subs	r0, #1
     c16:	b244      	sxtb	r4, r0
		while (-1 != pos) {
     c18:	1c63      	adds	r3, r4, #1
     c1a:	d002      	beq.n	c22 <EIC_Handler+0x7a>
     c1c:	2601      	movs	r6, #1
     c1e:	2000      	movs	r0, #0
     c20:	e7d9      	b.n	bd6 <EIC_Handler+0x2e>
	return ((Eic *)hw)->INTFLAG.reg;
     c22:	4b09      	ldr	r3, [pc, #36]	; (c48 <EIC_Handler+0xa0>)
     c24:	691a      	ldr	r2, [r3, #16]
	return ((Eic *)hw)->INTENSET.reg;
     c26:	68d9      	ldr	r1, [r3, #12]
		}
		flags = hri_eic_read_INTFLAG_reg(EIC) & hri_eic_read_INTEN_reg(EIC);
     c28:	400a      	ands	r2, r1
     c2a:	9201      	str	r2, [sp, #4]
		hri_eic_clear_INTFLAG_reg(EIC, flags);
     c2c:	9a01      	ldr	r2, [sp, #4]
	((Eic *)hw)->INTFLAG.reg = mask;
     c2e:	611a      	str	r2, [r3, #16]
	while (flags) {
     c30:	9b01      	ldr	r3, [sp, #4]
     c32:	2b00      	cmp	r3, #0
     c34:	d005      	beq.n	c42 <EIC_Handler+0x9a>
		pos = ffs(flags) - 1;
     c36:	9801      	ldr	r0, [sp, #4]
     c38:	4b08      	ldr	r3, [pc, #32]	; (c5c <EIC_Handler+0xb4>)
     c3a:	4798      	blx	r3
     c3c:	3801      	subs	r0, #1
     c3e:	b244      	sxtb	r4, r0
		while (-1 != pos) {
     c40:	e7ea      	b.n	c18 <EIC_Handler+0x70>
	}
}
     c42:	b002      	add	sp, #8
     c44:	bd70      	pop	{r4, r5, r6, pc}
     c46:	46c0      	nop			; (mov r8, r8)
     c48:	40001800 	.word	0x40001800
     c4c:	20000124 	.word	0x20000124
     c50:	00004a2c 	.word	0x00004a2c
     c54:	000009e5 	.word	0x000009e5
     c58:	00004a24 	.word	0x00004a24
     c5c:	00003fad 	.word	0x00003fad

00000c60 <_gclk_init_generators_by_fref>:

void _gclk_init_generators_by_fref(uint32_t bm)
{

#if CONF_GCLK_GENERATOR_0_CONFIG == 1
	if (bm & (1ul << 0)) {
     c60:	07c3      	lsls	r3, r0, #31
     c62:	d509      	bpl.n	c78 <_gclk_init_generators_by_fref+0x18>
}

static inline void hri_gclk_write_GENDIV_reg(const void *const hw, hri_gclk_gendiv_reg_t data)
{
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->GENDIV.reg = data;
     c64:	4b11      	ldr	r3, [pc, #68]	; (cac <_gclk_init_generators_by_fref+0x4c>)
     c66:	2280      	movs	r2, #128	; 0x80
     c68:	0052      	lsls	r2, r2, #1
     c6a:	609a      	str	r2, [r3, #8]
	((Gclk *)hw)->GENCTRL.reg = data;
     c6c:	4a10      	ldr	r2, [pc, #64]	; (cb0 <_gclk_init_generators_by_fref+0x50>)
     c6e:	605a      	str	r2, [r3, #4]
	while (((const Gclk *)hw)->STATUS.bit.SYNCBUSY)
     c70:	4b0e      	ldr	r3, [pc, #56]	; (cac <_gclk_init_generators_by_fref+0x4c>)
     c72:	785b      	ldrb	r3, [r3, #1]
     c74:	09db      	lsrs	r3, r3, #7
     c76:	d1fb      	bne.n	c70 <_gclk_init_generators_by_fref+0x10>
		        | (CONF_GCLK_GENERATOR_0_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_0_SRC | GCLK_GENCTRL_ID(0));
	}
#endif

#if CONF_GCLK_GENERATOR_1_CONFIG == 1
	if (bm & (1ul << 1)) {
     c78:	0783      	lsls	r3, r0, #30
     c7a:	d509      	bpl.n	c90 <_gclk_init_generators_by_fref+0x30>
	((Gclk *)hw)->GENDIV.reg = data;
     c7c:	4b0b      	ldr	r3, [pc, #44]	; (cac <_gclk_init_generators_by_fref+0x4c>)
     c7e:	2202      	movs	r2, #2
     c80:	32ff      	adds	r2, #255	; 0xff
     c82:	609a      	str	r2, [r3, #8]
	((Gclk *)hw)->GENCTRL.reg = data;
     c84:	4a0b      	ldr	r2, [pc, #44]	; (cb4 <_gclk_init_generators_by_fref+0x54>)
     c86:	605a      	str	r2, [r3, #4]
	while (((const Gclk *)hw)->STATUS.bit.SYNCBUSY)
     c88:	4b08      	ldr	r3, [pc, #32]	; (cac <_gclk_init_generators_by_fref+0x4c>)
     c8a:	785b      	ldrb	r3, [r3, #1]
     c8c:	09db      	lsrs	r3, r3, #7
     c8e:	d1fb      	bne.n	c88 <_gclk_init_generators_by_fref+0x28>
		        | (CONF_GCLK_GENERATOR_2_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_2_SRC | GCLK_GENCTRL_ID(2));
	}
#endif

#if CONF_GCLK_GENERATOR_3_CONFIG == 1
	if (bm & (1ul << 3)) {
     c90:	0703      	lsls	r3, r0, #28
     c92:	d509      	bpl.n	ca8 <_gclk_init_generators_by_fref+0x48>
	((Gclk *)hw)->GENDIV.reg = data;
     c94:	4b05      	ldr	r3, [pc, #20]	; (cac <_gclk_init_generators_by_fref+0x4c>)
     c96:	2204      	movs	r2, #4
     c98:	32ff      	adds	r2, #255	; 0xff
     c9a:	609a      	str	r2, [r3, #8]
	((Gclk *)hw)->GENCTRL.reg = data;
     c9c:	4a06      	ldr	r2, [pc, #24]	; (cb8 <_gclk_init_generators_by_fref+0x58>)
     c9e:	605a      	str	r2, [r3, #4]
	while (((const Gclk *)hw)->STATUS.bit.SYNCBUSY)
     ca0:	4b02      	ldr	r3, [pc, #8]	; (cac <_gclk_init_generators_by_fref+0x4c>)
     ca2:	785b      	ldrb	r3, [r3, #1]
     ca4:	09db      	lsrs	r3, r3, #7
     ca6:	d1fb      	bne.n	ca0 <_gclk_init_generators_by_fref+0x40>
		        | (CONF_GCLK_GEN_7_DIVSEL << GCLK_GENCTRL_DIVSEL_Pos) | (CONF_GCLK_GEN_7_OE << GCLK_GENCTRL_OE_Pos)
		        | (CONF_GCLK_GEN_7_OOV << GCLK_GENCTRL_OOV_Pos) | (CONF_GCLK_GEN_7_IDC << GCLK_GENCTRL_IDC_Pos)
		        | (CONF_GCLK_GENERATOR_7_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_7_SRC | GCLK_GENCTRL_ID(7));
	}
#endif
}
     ca8:	4770      	bx	lr
     caa:	46c0      	nop			; (mov r8, r8)
     cac:	40000c00 	.word	0x40000c00
     cb0:	00010700 	.word	0x00010700
     cb4:	00010601 	.word	0x00010601
     cb8:	00010303 	.word	0x00010303

00000cbc <_pm_init>:
}

static inline void hri_pm_set_CPUSEL_CPUDIV_bf(const void *const hw, hri_pm_cpusel_reg_t mask)
{
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->CPUSEL.reg |= PM_CPUSEL_CPUDIV(mask);
     cbc:	4b06      	ldr	r3, [pc, #24]	; (cd8 <_pm_init+0x1c>)
     cbe:	7a1a      	ldrb	r2, [r3, #8]
     cc0:	b2d2      	uxtb	r2, r2
     cc2:	721a      	strb	r2, [r3, #8]
}

static inline void hri_pm_set_APBASEL_APBADIV_bf(const void *const hw, hri_pm_apbasel_reg_t mask)
{
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->APBASEL.reg |= PM_APBASEL_APBADIV(mask);
     cc4:	7a5a      	ldrb	r2, [r3, #9]
     cc6:	b2d2      	uxtb	r2, r2
     cc8:	725a      	strb	r2, [r3, #9]
}

static inline void hri_pm_set_APBBSEL_APBBDIV_bf(const void *const hw, hri_pm_apbbsel_reg_t mask)
{
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->APBBSEL.reg |= PM_APBBSEL_APBBDIV(mask);
     cca:	7a9a      	ldrb	r2, [r3, #10]
     ccc:	b2d2      	uxtb	r2, r2
     cce:	729a      	strb	r2, [r3, #10]
}

static inline void hri_pm_set_APBCSEL_APBCDIV_bf(const void *const hw, hri_pm_apbcsel_reg_t mask)
{
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->APBCSEL.reg |= PM_APBCSEL_APBCDIV(mask);
     cd0:	7ada      	ldrb	r2, [r3, #11]
     cd2:	b2d2      	uxtb	r2, r2
     cd4:	72da      	strb	r2, [r3, #11]
{
	hri_pm_set_CPUSEL_CPUDIV_bf(PM, CONF_CPU_DIV);
	hri_pm_set_APBASEL_APBADIV_bf(PM, CONF_APBA_DIV);
	hri_pm_set_APBBSEL_APBBDIV_bf(PM, CONF_APBB_DIV);
	hri_pm_set_APBCSEL_APBCDIV_bf(PM, CONF_APBC_DIV);
}
     cd6:	4770      	bx	lr
     cd8:	40000400 	.word	0x40000400

00000cdc <_rtc_timer_interrupt_handler>:
 * \brief RTC Timer interrupt handler
 *
 * \param[in] p The pointer to calendar device struct
 */
static void _rtc_timer_interrupt_handler(struct _timer_device *dev)
{
     cdc:	b510      	push	{r4, lr}
     cde:	0004      	movs	r4, r0
	return tmp;
}

static inline hri_rtcmode0_intflag_reg_t hri_rtcmode0_read_INTFLAG_reg(const void *const hw)
{
	return ((Rtc *)hw)->MODE0.INTFLAG.reg;
     ce0:	68c3      	ldr	r3, [r0, #12]
     ce2:	7a1b      	ldrb	r3, [r3, #8]
	/* Read and mask interrupt flag register */
	uint16_t flag = hri_rtcmode0_read_INTFLAG_reg(dev->hw);

	if (flag & RTC_MODE0_INTFLAG_CMP0) {
     ce4:	07db      	lsls	r3, r3, #31
     ce6:	d506      	bpl.n	cf6 <_rtc_timer_interrupt_handler+0x1a>
		if (dev->timer_cb.period_expired) {
     ce8:	6803      	ldr	r3, [r0, #0]
     cea:	2b00      	cmp	r3, #0
     cec:	d000      	beq.n	cf0 <_rtc_timer_interrupt_handler+0x14>
			dev->timer_cb.period_expired(dev);
     cee:	4798      	blx	r3
		}

		/* Clear interrupt flag */
		hri_rtcmode0_clear_interrupt_CMP0_bit(dev->hw);
     cf0:	68e3      	ldr	r3, [r4, #12]
	((Rtc *)hw)->MODE0.INTFLAG.reg = RTC_MODE0_INTFLAG_CMP0;
     cf2:	2201      	movs	r2, #1
     cf4:	721a      	strb	r2, [r3, #8]
	}
}
     cf6:	bd10      	pop	{r4, pc}

00000cf8 <_timer_init>:
{
     cf8:	b570      	push	{r4, r5, r6, lr}
     cfa:	0004      	movs	r4, r0
     cfc:	000d      	movs	r5, r1
	ASSERT(dev);
     cfe:	1e43      	subs	r3, r0, #1
     d00:	4198      	sbcs	r0, r3
     d02:	b2c0      	uxtb	r0, r0
     d04:	2230      	movs	r2, #48	; 0x30
     d06:	4910      	ldr	r1, [pc, #64]	; (d48 <_timer_init+0x50>)
     d08:	4b10      	ldr	r3, [pc, #64]	; (d4c <_timer_init+0x54>)
     d0a:	4798      	blx	r3
	dev->hw = hw;
     d0c:	60e5      	str	r5, [r4, #12]
}

static inline void hri_rtcmode0_write_CTRL_reg(const void *const hw, hri_rtcmode0_ctrl_reg_t data)
{
	RTC_CRITICAL_SECTION_ENTER();
	((Rtc *)hw)->MODE0.CTRL.reg = data;
     d0e:	2301      	movs	r3, #1
     d10:	802b      	strh	r3, [r5, #0]
	while (((const Rtc *)hw)->MODE0.STATUS.bit.SYNCBUSY)
     d12:	7aab      	ldrb	r3, [r5, #10]
     d14:	09db      	lsrs	r3, r3, #7
     d16:	d1fc      	bne.n	d12 <_timer_init+0x1a>
	hri_rtcmode0_wait_for_sync(dev->hw);
     d18:	68e2      	ldr	r2, [r4, #12]
     d1a:	7a93      	ldrb	r3, [r2, #10]
     d1c:	09db      	lsrs	r3, r3, #7
     d1e:	d1fc      	bne.n	d1a <_timer_init+0x22>
	((Rtc *)hw)->MODE0.CTRL.reg = data;
     d20:	3380      	adds	r3, #128	; 0x80
     d22:	8013      	strh	r3, [r2, #0]
	while (((const Rtc *)hw)->MODE0.STATUS.bit.SYNCBUSY)
     d24:	7a93      	ldrb	r3, [r2, #10]
     d26:	09db      	lsrs	r3, r3, #7
     d28:	d1fc      	bne.n	d24 <_timer_init+0x2c>
	hri_rtcmode0_write_COMP_COMP_bf(dev->hw, 0, CONF_RTC_COMP_VAL);
     d2a:	68e2      	ldr	r2, [r4, #12]

static inline void hri_rtcmode0_write_COMP_COMP_bf(const void *const hw, uint8_t index, hri_rtcmode0_comp_reg_t data)
{
	uint32_t tmp;
	RTC_CRITICAL_SECTION_ENTER();
	tmp = ((Rtc *)hw)->MODE0.COMP[index].reg;
     d2c:	6993      	ldr	r3, [r2, #24]
	tmp &= ~RTC_MODE0_COMP_COMP_Msk;
	tmp |= RTC_MODE0_COMP_COMP(data);
	((Rtc *)hw)->MODE0.COMP[index].reg = tmp;
     d2e:	2301      	movs	r3, #1
     d30:	6193      	str	r3, [r2, #24]
	while (((const Rtc *)hw)->MODE0.STATUS.bit.SYNCBUSY)
     d32:	7a93      	ldrb	r3, [r2, #10]
     d34:	09db      	lsrs	r3, r3, #7
     d36:	d1fc      	bne.n	d32 <_timer_init+0x3a>
	((Rtc *)hw)->MODE0.INTENSET.reg = RTC_MODE0_INTENSET_CMP0;
     d38:	3301      	adds	r3, #1
     d3a:	68e2      	ldr	r2, [r4, #12]
     d3c:	71d3      	strb	r3, [r2, #7]
	_rtc_dev = dev;
     d3e:	4b04      	ldr	r3, [pc, #16]	; (d50 <_timer_init+0x58>)
     d40:	601c      	str	r4, [r3, #0]
}
     d42:	2000      	movs	r0, #0
     d44:	bd70      	pop	{r4, r5, r6, pc}
     d46:	46c0      	nop			; (mov r8, r8)
     d48:	00004a44 	.word	0x00004a44
     d4c:	000009e5 	.word	0x000009e5
     d50:	20000128 	.word	0x20000128

00000d54 <_timer_start>:
{
     d54:	b510      	push	{r4, lr}
     d56:	1e04      	subs	r4, r0, #0
	ASSERT(dev && dev->hw);
     d58:	d020      	beq.n	d9c <_timer_start+0x48>
     d5a:	68c3      	ldr	r3, [r0, #12]
     d5c:	2b00      	cmp	r3, #0
     d5e:	d01b      	beq.n	d98 <_timer_start+0x44>
     d60:	2001      	movs	r0, #1
     d62:	2267      	movs	r2, #103	; 0x67
     d64:	490e      	ldr	r1, [pc, #56]	; (da0 <_timer_start+0x4c>)
     d66:	4b0f      	ldr	r3, [pc, #60]	; (da4 <_timer_start+0x50>)
     d68:	4798      	blx	r3
     d6a:	2208      	movs	r2, #8
     d6c:	4b0e      	ldr	r3, [pc, #56]	; (da8 <_timer_start+0x54>)
     d6e:	601a      	str	r2, [r3, #0]
	hri_rtcmode0_write_COUNT_COUNT_bf(dev->hw, 0);
     d70:	68e2      	ldr	r2, [r4, #12]
	tmp = ((Rtc *)hw)->MODE0.COUNT.reg;
     d72:	6913      	ldr	r3, [r2, #16]
	((Rtc *)hw)->MODE0.COUNT.reg = tmp;
     d74:	2300      	movs	r3, #0
     d76:	6113      	str	r3, [r2, #16]
	while (((const Rtc *)hw)->MODE0.STATUS.bit.SYNCBUSY)
     d78:	7a93      	ldrb	r3, [r2, #10]
     d7a:	09db      	lsrs	r3, r3, #7
     d7c:	d1fc      	bne.n	d78 <_timer_start+0x24>
	hri_rtcmode0_wait_for_sync(dev->hw);
     d7e:	68e2      	ldr	r2, [r4, #12]
     d80:	7a93      	ldrb	r3, [r2, #10]
     d82:	09db      	lsrs	r3, r3, #7
     d84:	d1fc      	bne.n	d80 <_timer_start+0x2c>
	((Rtc *)hw)->MODE0.CTRL.reg |= RTC_MODE0_CTRL_ENABLE;
     d86:	8813      	ldrh	r3, [r2, #0]
     d88:	2102      	movs	r1, #2
     d8a:	430b      	orrs	r3, r1
     d8c:	b29b      	uxth	r3, r3
     d8e:	8013      	strh	r3, [r2, #0]
	while (((const Rtc *)hw)->MODE0.STATUS.bit.SYNCBUSY)
     d90:	7a93      	ldrb	r3, [r2, #10]
     d92:	09db      	lsrs	r3, r3, #7
     d94:	d1fc      	bne.n	d90 <_timer_start+0x3c>
}
     d96:	bd10      	pop	{r4, pc}
	ASSERT(dev && dev->hw);
     d98:	2000      	movs	r0, #0
     d9a:	e7e2      	b.n	d62 <_timer_start+0xe>
     d9c:	2000      	movs	r0, #0
     d9e:	e7e0      	b.n	d62 <_timer_start+0xe>
     da0:	00004a44 	.word	0x00004a44
     da4:	000009e5 	.word	0x000009e5
     da8:	e000e100 	.word	0xe000e100

00000dac <_timer_is_started>:
	return hri_rtcmode0_get_CTRL_ENABLE_bit(dev->hw);
     dac:	68c2      	ldr	r2, [r0, #12]
     dae:	7a93      	ldrb	r3, [r2, #10]
     db0:	09db      	lsrs	r3, r3, #7
     db2:	d1fc      	bne.n	dae <_timer_is_started+0x2>
	tmp = ((Rtc *)hw)->MODE0.CTRL.reg;
     db4:	8813      	ldrh	r3, [r2, #0]
	tmp = (tmp & RTC_MODE0_CTRL_ENABLE) >> RTC_MODE0_CTRL_ENABLE_Pos;
     db6:	085b      	lsrs	r3, r3, #1
	return (bool)tmp;
     db8:	2001      	movs	r0, #1
     dba:	4018      	ands	r0, r3
}
     dbc:	4770      	bx	lr

00000dbe <_timer_set_irq>:
}
     dbe:	4770      	bx	lr

00000dc0 <_rtc_get_timer>:
 * \brief Retrieve timer helper functions
 */
struct _timer_hpl_interface *_rtc_get_timer(void)
{
	return NULL;
}
     dc0:	2000      	movs	r0, #0
     dc2:	4770      	bx	lr

00000dc4 <RTC_Handler>:

/**
 * \brief Rtc interrupt handler
 */
void RTC_Handler(void)
{
     dc4:	b510      	push	{r4, lr}
	_rtc_timer_interrupt_handler(_rtc_dev);
     dc6:	4b02      	ldr	r3, [pc, #8]	; (dd0 <RTC_Handler+0xc>)
     dc8:	6818      	ldr	r0, [r3, #0]
     dca:	4b02      	ldr	r3, [pc, #8]	; (dd4 <RTC_Handler+0x10>)
     dcc:	4798      	blx	r3
}
     dce:	bd10      	pop	{r4, pc}
     dd0:	20000128 	.word	0x20000128
     dd4:	00000cdd 	.word	0x00000cdd

00000dd8 <_sercom_get_hardware_index>:
{
#ifdef _UNIT_TEST_
	return ((uint32_t)hw - (uint32_t)SERCOM0) / sizeof(Sercom);
#endif

	return ((uint32_t)hw - (uint32_t)SERCOM0) >> 10;
     dd8:	4b02      	ldr	r3, [pc, #8]	; (de4 <_sercom_get_hardware_index+0xc>)
     dda:	469c      	mov	ip, r3
     ddc:	4460      	add	r0, ip
     dde:	0a80      	lsrs	r0, r0, #10
     de0:	b2c0      	uxtb	r0, r0
}
     de2:	4770      	bx	lr
     de4:	bdfff800 	.word	0xbdfff800

00000de8 <_spi_sync_enable>:
		;
}

static inline bool hri_sercomspi_is_syncing(const void *const hw)
{
	return ((const Sercom *)hw)->SPI.STATUS.bit.SYNCBUSY;
     de8:	8a03      	ldrh	r3, [r0, #16]
     dea:	0bdb      	lsrs	r3, r3, #15
 *
 * \return Enabling status
 */
static int32_t _spi_sync_enable(void *const hw)
{
	if (hri_sercomspi_is_syncing(hw)) {
     dec:	d108      	bne.n	e00 <_spi_sync_enable+0x18>
}

static inline void hri_sercomspi_set_CTRLA_ENABLE_bit(const void *const hw)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.CTRLA.reg |= SERCOM_SPI_CTRLA_ENABLE;
     dee:	6803      	ldr	r3, [r0, #0]
     df0:	2202      	movs	r2, #2
     df2:	4313      	orrs	r3, r2
     df4:	6003      	str	r3, [r0, #0]
	while (((const Sercom *)hw)->SPI.STATUS.bit.SYNCBUSY)
     df6:	8a03      	ldrh	r3, [r0, #16]
     df8:	0bdb      	lsrs	r3, r3, #15
     dfa:	d1fc      	bne.n	df6 <_spi_sync_enable+0xe>
		return ERR_BUSY;
	}

	hri_sercomspi_set_CTRLA_ENABLE_bit(hw);

	return ERR_NONE;
     dfc:	2000      	movs	r0, #0
}
     dfe:	4770      	bx	lr
		return ERR_BUSY;
     e00:	2004      	movs	r0, #4
     e02:	4240      	negs	r0, r0
     e04:	e7fb      	b.n	dfe <_spi_sync_enable+0x16>
	...

00000e08 <_get_sercom_index>:
{
     e08:	b510      	push	{r4, lr}
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
     e0a:	4b0a      	ldr	r3, [pc, #40]	; (e34 <_get_sercom_index+0x2c>)
     e0c:	4798      	blx	r3
     e0e:	0003      	movs	r3, r0
	for (i = 0; i < ARRAY_SIZE(_usarts); i++) {
     e10:	2000      	movs	r0, #0
     e12:	2800      	cmp	r0, #0
     e14:	d006      	beq.n	e24 <_get_sercom_index+0x1c>
	ASSERT(false);
     e16:	4a08      	ldr	r2, [pc, #32]	; (e38 <_get_sercom_index+0x30>)
     e18:	4908      	ldr	r1, [pc, #32]	; (e3c <_get_sercom_index+0x34>)
     e1a:	2000      	movs	r0, #0
     e1c:	4b08      	ldr	r3, [pc, #32]	; (e40 <_get_sercom_index+0x38>)
     e1e:	4798      	blx	r3
	return 0;
     e20:	2000      	movs	r0, #0
}
     e22:	bd10      	pop	{r4, pc}
		if (_usarts[i].number == sercom_offset) {
     e24:	0102      	lsls	r2, r0, #4
     e26:	4907      	ldr	r1, [pc, #28]	; (e44 <_get_sercom_index+0x3c>)
     e28:	5c52      	ldrb	r2, [r2, r1]
     e2a:	4293      	cmp	r3, r2
     e2c:	d0f9      	beq.n	e22 <_get_sercom_index+0x1a>
	for (i = 0; i < ARRAY_SIZE(_usarts); i++) {
     e2e:	3001      	adds	r0, #1
     e30:	b2c0      	uxtb	r0, r0
     e32:	e7ee      	b.n	e12 <_get_sercom_index+0xa>
     e34:	00000dd9 	.word	0x00000dd9
     e38:	0000022a 	.word	0x0000022a
     e3c:	00004ab4 	.word	0x00004ab4
     e40:	000009e5 	.word	0x000009e5
     e44:	00004a5c 	.word	0x00004a5c

00000e48 <_usart_init>:
{
     e48:	b510      	push	{r4, lr}
     e4a:	0004      	movs	r4, r0
	uint8_t i = _get_sercom_index(hw);
     e4c:	4b19      	ldr	r3, [pc, #100]	; (eb4 <_usart_init+0x6c>)
     e4e:	4798      	blx	r3
	while (((const Sercom *)hw)->USART.STATUS.bit.SYNCBUSY)
     e50:	8a23      	ldrh	r3, [r4, #16]
     e52:	0bdb      	lsrs	r3, r3, #15
     e54:	d1fc      	bne.n	e50 <_usart_init+0x8>
     e56:	8a23      	ldrh	r3, [r4, #16]
     e58:	0bdb      	lsrs	r3, r3, #15
     e5a:	d1fc      	bne.n	e56 <_usart_init+0xe>
static inline hri_sercomusart_ctrla_reg_t hri_sercomusart_get_CTRLA_reg(const void *const           hw,
                                                                        hri_sercomusart_ctrla_reg_t mask)
{
	uint32_t tmp;
	hri_sercomusart_wait_for_sync(hw);
	tmp = ((Sercom *)hw)->USART.CTRLA.reg;
     e5c:	6823      	ldr	r3, [r4, #0]
	if (hri_sercomusart_get_CTRLA_reg(hw, SERCOM_USART_CTRLA_ENABLE)) {
     e5e:	079b      	lsls	r3, r3, #30
     e60:	d507      	bpl.n	e72 <_usart_init+0x2a>
}

static inline void hri_sercomusart_write_CTRLA_reg(const void *const hw, hri_sercomusart_ctrla_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLA.reg = data;
     e62:	2300      	movs	r3, #0
     e64:	6023      	str	r3, [r4, #0]
	while (((const Sercom *)hw)->USART.STATUS.bit.SYNCBUSY)
     e66:	8a23      	ldrh	r3, [r4, #16]
     e68:	0bdb      	lsrs	r3, r3, #15
     e6a:	d1fc      	bne.n	e66 <_usart_init+0x1e>
     e6c:	8a23      	ldrh	r3, [r4, #16]
     e6e:	0bdb      	lsrs	r3, r3, #15
     e70:	d1fc      	bne.n	e6c <_usart_init+0x24>
	((Sercom *)hw)->USART.CTRLA.reg = data;
     e72:	2301      	movs	r3, #1
     e74:	6023      	str	r3, [r4, #0]
	while (((const Sercom *)hw)->USART.STATUS.bit.SYNCBUSY)
     e76:	8a23      	ldrh	r3, [r4, #16]
     e78:	0bdb      	lsrs	r3, r3, #15
     e7a:	d1fc      	bne.n	e76 <_usart_init+0x2e>
     e7c:	8a23      	ldrh	r3, [r4, #16]
     e7e:	0bdb      	lsrs	r3, r3, #15
     e80:	d1fc      	bne.n	e7c <_usart_init+0x34>
	hri_sercomusart_write_CTRLA_reg(hw, _usarts[i].ctrl_a);
     e82:	0102      	lsls	r2, r0, #4
     e84:	4b0c      	ldr	r3, [pc, #48]	; (eb8 <_usart_init+0x70>)
     e86:	189b      	adds	r3, r3, r2
     e88:	685b      	ldr	r3, [r3, #4]
	((Sercom *)hw)->USART.CTRLA.reg = data;
     e8a:	6023      	str	r3, [r4, #0]
	while (((const Sercom *)hw)->USART.STATUS.bit.SYNCBUSY)
     e8c:	8a23      	ldrh	r3, [r4, #16]
     e8e:	0bdb      	lsrs	r3, r3, #15
     e90:	d1fc      	bne.n	e8c <_usart_init+0x44>
	hri_sercomusart_write_CTRLB_reg(hw, _usarts[i].ctrl_b);
     e92:	0102      	lsls	r2, r0, #4
     e94:	4b08      	ldr	r3, [pc, #32]	; (eb8 <_usart_init+0x70>)
     e96:	189b      	adds	r3, r3, r2
     e98:	689b      	ldr	r3, [r3, #8]
}

static inline void hri_sercomusart_write_CTRLB_reg(const void *const hw, hri_sercomusart_ctrlb_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLB.reg = data;
     e9a:	6063      	str	r3, [r4, #4]
	while (((const Sercom *)hw)->USART.STATUS.bit.SYNCBUSY)
     e9c:	8a23      	ldrh	r3, [r4, #16]
     e9e:	0bdb      	lsrs	r3, r3, #15
     ea0:	d1fc      	bne.n	e9c <_usart_init+0x54>
	hri_sercomusart_write_BAUD_reg(hw, _usarts[i].baud);
     ea2:	0100      	lsls	r0, r0, #4
     ea4:	4b04      	ldr	r3, [pc, #16]	; (eb8 <_usart_init+0x70>)
     ea6:	1818      	adds	r0, r3, r0
     ea8:	8983      	ldrh	r3, [r0, #12]
}

static inline void hri_sercomusart_write_BAUD_reg(const void *const hw, hri_sercomusart_baud_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.BAUD.reg = data;
     eaa:	8163      	strh	r3, [r4, #10]
	hri_sercomusart_write_DBGCTRL_reg(hw, _usarts[i].debug_ctrl);
     eac:	7b83      	ldrb	r3, [r0, #14]
	((Sercom *)hw)->USART.DBGCTRL.reg = data;
     eae:	7223      	strb	r3, [r4, #8]
}
     eb0:	2000      	movs	r0, #0
     eb2:	bd10      	pop	{r4, pc}
     eb4:	00000e09 	.word	0x00000e09
     eb8:	00004a5c 	.word	0x00004a5c

00000ebc <_get_i2cm_index>:
{
     ebc:	b510      	push	{r4, lr}
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
     ebe:	4b0c      	ldr	r3, [pc, #48]	; (ef0 <_get_i2cm_index+0x34>)
     ec0:	4798      	blx	r3
     ec2:	0002      	movs	r2, r0
	for (i = 0; i < ARRAY_SIZE(_i2cms); i++) {
     ec4:	2000      	movs	r0, #0
     ec6:	2800      	cmp	r0, #0
     ec8:	d006      	beq.n	ed8 <_get_i2cm_index+0x1c>
	ASSERT(false);
     eca:	4a0a      	ldr	r2, [pc, #40]	; (ef4 <_get_i2cm_index+0x38>)
     ecc:	490a      	ldr	r1, [pc, #40]	; (ef8 <_get_i2cm_index+0x3c>)
     ece:	2000      	movs	r0, #0
     ed0:	4b0a      	ldr	r3, [pc, #40]	; (efc <_get_i2cm_index+0x40>)
     ed2:	4798      	blx	r3
	return 0;
     ed4:	2000      	movs	r0, #0
}
     ed6:	bd10      	pop	{r4, pc}
		if (_i2cms[i].number == sercom_offset) {
     ed8:	0043      	lsls	r3, r0, #1
     eda:	181b      	adds	r3, r3, r0
     edc:	00d9      	lsls	r1, r3, #3
     ede:	4b08      	ldr	r3, [pc, #32]	; (f00 <_get_i2cm_index+0x44>)
     ee0:	185b      	adds	r3, r3, r1
     ee2:	7c1b      	ldrb	r3, [r3, #16]
     ee4:	429a      	cmp	r2, r3
     ee6:	d0f6      	beq.n	ed6 <_get_i2cm_index+0x1a>
	for (i = 0; i < ARRAY_SIZE(_i2cms); i++) {
     ee8:	3001      	adds	r0, #1
     eea:	b2c0      	uxtb	r0, r0
     eec:	e7eb      	b.n	ec6 <_get_i2cm_index+0xa>
     eee:	46c0      	nop			; (mov r8, r8)
     ef0:	00000dd9 	.word	0x00000dd9
     ef4:	00000366 	.word	0x00000366
     ef8:	00004ab4 	.word	0x00004ab4
     efc:	000009e5 	.word	0x000009e5
     f00:	00004a5c 	.word	0x00004a5c

00000f04 <_sercom_i2c_sync_send_address>:
{
     f04:	b570      	push	{r4, r5, r6, lr}
     f06:	0005      	movs	r5, r0
	void *             hw  = i2c_dev->hw;
     f08:	6904      	ldr	r4, [r0, #16]
	ASSERT(i2c_dev);
     f0a:	1e43      	subs	r3, r0, #1
     f0c:	4198      	sbcs	r0, r3
     f0e:	b2c0      	uxtb	r0, r0
     f10:	4a5c      	ldr	r2, [pc, #368]	; (1084 <_sercom_i2c_sync_send_address+0x180>)
     f12:	495d      	ldr	r1, [pc, #372]	; (1088 <_sercom_i2c_sync_send_address+0x184>)
     f14:	4b5d      	ldr	r3, [pc, #372]	; (108c <_sercom_i2c_sync_send_address+0x188>)
     f16:	4798      	blx	r3
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
     f18:	6863      	ldr	r3, [r4, #4]
     f1a:	4a5d      	ldr	r2, [pc, #372]	; (1090 <_sercom_i2c_sync_send_address+0x18c>)
     f1c:	4013      	ands	r3, r2
     f1e:	6063      	str	r3, [r4, #4]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     f20:	8a23      	ldrh	r3, [r4, #16]
     f22:	0bdb      	lsrs	r3, r3, #15
     f24:	d1fc      	bne.n	f20 <_sercom_i2c_sync_send_address+0x1c>
	hri_sercomi2cm_write_ADDR_reg(hw, ((msg->addr & SEVEN_ADDR_MASK) << 1) | (msg->flags & I2C_M_RD ? I2C_M_RD : 0x0));
     f26:	882a      	ldrh	r2, [r5, #0]
     f28:	0052      	lsls	r2, r2, #1
     f2a:	886b      	ldrh	r3, [r5, #2]
     f2c:	2101      	movs	r1, #1
     f2e:	400b      	ands	r3, r1
     f30:	4313      	orrs	r3, r2
     f32:	b2db      	uxtb	r3, r3
}

static inline void hri_sercomi2cm_write_ADDR_reg(const void *const hw, hri_sercomi2cm_addr_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.ADDR.reg = data;
     f34:	7523      	strb	r3, [r4, #20]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     f36:	8a23      	ldrh	r3, [r4, #16]
     f38:	0bdb      	lsrs	r3, r3, #15
     f3a:	d1fc      	bne.n	f36 <_sercom_i2c_sync_send_address+0x32>
	void *   hw      = i2c_dev->hw;
     f3c:	692e      	ldr	r6, [r5, #16]
	uint32_t timeout = 65535;
     f3e:	4a55      	ldr	r2, [pc, #340]	; (1094 <_sercom_i2c_sync_send_address+0x190>)
	return ((Sercom *)hw)->I2CM.INTFLAG.reg;
     f40:	7bb3      	ldrb	r3, [r6, #14]
     f42:	b2db      	uxtb	r3, r3
		*flags = hri_sercomi2cm_read_INTFLAG_reg(hw);
     f44:	0018      	movs	r0, r3
		if (timeout-- == 0) {
     f46:	1e51      	subs	r1, r2, #1
     f48:	2a00      	cmp	r2, #0
     f4a:	d002      	beq.n	f52 <_sercom_i2c_sync_send_address+0x4e>
     f4c:	000a      	movs	r2, r1
	} while (!(*flags & MB_FLAG) && !(*flags & SB_FLAG));
     f4e:	079b      	lsls	r3, r3, #30
     f50:	d0f6      	beq.n	f40 <_sercom_i2c_sync_send_address+0x3c>
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     f52:	8a23      	ldrh	r3, [r4, #16]
     f54:	0bdb      	lsrs	r3, r3, #15
     f56:	d1fc      	bne.n	f52 <_sercom_i2c_sync_send_address+0x4e>
}

static inline hri_sercomi2cm_status_reg_t hri_sercomi2cm_read_STATUS_reg(const void *const hw)
{
	hri_sercomi2cm_wait_for_sync(hw);
	return ((Sercom *)hw)->I2CM.STATUS.reg;
     f58:	8a23      	ldrh	r3, [r4, #16]
     f5a:	b29b      	uxth	r3, r3
	if (flags & MB_FLAG) {
     f5c:	07c2      	lsls	r2, r0, #31
     f5e:	d550      	bpl.n	1002 <_sercom_i2c_sync_send_address+0xfe>
		if (status & SERCOM_I2CM_STATUS_ARBLOST) {
     f60:	079a      	lsls	r2, r3, #30
     f62:	d510      	bpl.n	f86 <_sercom_i2c_sync_send_address+0x82>
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_MB;
     f64:	2201      	movs	r2, #1
     f66:	73a2      	strb	r2, [r4, #14]
			msg->flags |= I2C_M_FAIL;
     f68:	886a      	ldrh	r2, [r5, #2]
     f6a:	2180      	movs	r1, #128	; 0x80
     f6c:	0149      	lsls	r1, r1, #5
     f6e:	430a      	orrs	r2, r1
     f70:	806a      	strh	r2, [r5, #2]
			msg->flags &= ~I2C_M_BUSY;
     f72:	886a      	ldrh	r2, [r5, #2]
     f74:	4948      	ldr	r1, [pc, #288]	; (1098 <_sercom_i2c_sync_send_address+0x194>)
     f76:	400a      	ands	r2, r1
     f78:	806a      	strh	r2, [r5, #2]
			if (status & SERCOM_I2CM_STATUS_BUSERR) {
     f7a:	07db      	lsls	r3, r3, #31
     f7c:	d400      	bmi.n	f80 <_sercom_i2c_sync_send_address+0x7c>
     f7e:	e07c      	b.n	107a <_sercom_i2c_sync_send_address+0x176>
				return I2C_ERR_BUS;
     f80:	2005      	movs	r0, #5
     f82:	4240      	negs	r0, r0
     f84:	e063      	b.n	104e <_sercom_i2c_sync_send_address+0x14a>
			if (status & SERCOM_I2CM_STATUS_RXNACK) {
     f86:	075b      	lsls	r3, r3, #29
     f88:	d40b      	bmi.n	fa2 <_sercom_i2c_sync_send_address+0x9e>
			if (msg->len == 0) {
     f8a:	6868      	ldr	r0, [r5, #4]
     f8c:	2800      	cmp	r0, #0
     f8e:	d12d      	bne.n	fec <_sercom_i2c_sync_send_address+0xe8>
				if (msg->flags & I2C_M_STOP) {
     f90:	886b      	ldrh	r3, [r5, #2]
     f92:	b21b      	sxth	r3, r3
     f94:	2b00      	cmp	r3, #0
     f96:	db20      	blt.n	fda <_sercom_i2c_sync_send_address+0xd6>
				msg->flags &= ~I2C_M_BUSY;
     f98:	886b      	ldrh	r3, [r5, #2]
     f9a:	4a3f      	ldr	r2, [pc, #252]	; (1098 <_sercom_i2c_sync_send_address+0x194>)
     f9c:	4013      	ands	r3, r2
     f9e:	806b      	strh	r3, [r5, #2]
     fa0:	e055      	b.n	104e <_sercom_i2c_sync_send_address+0x14a>
				if (msg->len > 0) {
     fa2:	686b      	ldr	r3, [r5, #4]
     fa4:	2b00      	cmp	r3, #0
     fa6:	dd04      	ble.n	fb2 <_sercom_i2c_sync_send_address+0xae>
					msg->flags |= I2C_M_FAIL;
     fa8:	886b      	ldrh	r3, [r5, #2]
     faa:	2280      	movs	r2, #128	; 0x80
     fac:	0152      	lsls	r2, r2, #5
     fae:	4313      	orrs	r3, r2
     fb0:	806b      	strh	r3, [r5, #2]
				if (msg->flags & I2C_M_STOP) {
     fb2:	886b      	ldrh	r3, [r5, #2]
     fb4:	b21b      	sxth	r3, r3
     fb6:	2b00      	cmp	r3, #0
     fb8:	db06      	blt.n	fc8 <_sercom_i2c_sync_send_address+0xc4>
				msg->flags &= ~I2C_M_BUSY;
     fba:	886b      	ldrh	r3, [r5, #2]
     fbc:	4a36      	ldr	r2, [pc, #216]	; (1098 <_sercom_i2c_sync_send_address+0x194>)
     fbe:	4013      	ands	r3, r2
     fc0:	806b      	strh	r3, [r5, #2]
				return I2C_NACK;
     fc2:	2002      	movs	r0, #2
     fc4:	4240      	negs	r0, r0
     fc6:	e042      	b.n	104e <_sercom_i2c_sync_send_address+0x14a>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
     fc8:	6862      	ldr	r2, [r4, #4]
     fca:	23c0      	movs	r3, #192	; 0xc0
     fcc:	029b      	lsls	r3, r3, #10
     fce:	4313      	orrs	r3, r2
     fd0:	6063      	str	r3, [r4, #4]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     fd2:	8a23      	ldrh	r3, [r4, #16]
     fd4:	0bdb      	lsrs	r3, r3, #15
     fd6:	d1fc      	bne.n	fd2 <_sercom_i2c_sync_send_address+0xce>
     fd8:	e7ef      	b.n	fba <_sercom_i2c_sync_send_address+0xb6>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
     fda:	6862      	ldr	r2, [r4, #4]
     fdc:	23c0      	movs	r3, #192	; 0xc0
     fde:	029b      	lsls	r3, r3, #10
     fe0:	4313      	orrs	r3, r2
     fe2:	6063      	str	r3, [r4, #4]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
     fe4:	8a23      	ldrh	r3, [r4, #16]
     fe6:	0bdb      	lsrs	r3, r3, #15
     fe8:	d1fc      	bne.n	fe4 <_sercom_i2c_sync_send_address+0xe0>
     fea:	e7d5      	b.n	f98 <_sercom_i2c_sync_send_address+0x94>
				hri_sercomi2cm_write_DATA_reg(hw, *msg->buffer);
     fec:	68ab      	ldr	r3, [r5, #8]
     fee:	781b      	ldrb	r3, [r3, #0]
	((Sercom *)hw)->I2CM.DATA.reg = data;
     ff0:	7623      	strb	r3, [r4, #24]
				msg->buffer++;
     ff2:	68ab      	ldr	r3, [r5, #8]
     ff4:	3301      	adds	r3, #1
     ff6:	60ab      	str	r3, [r5, #8]
				msg->len--;
     ff8:	686b      	ldr	r3, [r5, #4]
     ffa:	3b01      	subs	r3, #1
     ffc:	606b      	str	r3, [r5, #4]
			return I2C_OK;
     ffe:	2000      	movs	r0, #0
    1000:	e025      	b.n	104e <_sercom_i2c_sync_send_address+0x14a>
	} else if (flags & SB_FLAG) {
    1002:	0782      	lsls	r2, r0, #30
    1004:	d53c      	bpl.n	1080 <_sercom_i2c_sync_send_address+0x17c>
		if ((msg->len) && !(status & SERCOM_I2CM_STATUS_RXNACK)) {
    1006:	686a      	ldr	r2, [r5, #4]
    1008:	2a00      	cmp	r2, #0
    100a:	d031      	beq.n	1070 <_sercom_i2c_sync_send_address+0x16c>
    100c:	075b      	lsls	r3, r3, #29
    100e:	d42f      	bmi.n	1070 <_sercom_i2c_sync_send_address+0x16c>
			msg->len--;
    1010:	3a01      	subs	r2, #1
    1012:	606a      	str	r2, [r5, #4]
			if (msg->len == 0) {
    1014:	2a00      	cmp	r2, #0
    1016:	d107      	bne.n	1028 <_sercom_i2c_sync_send_address+0x124>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
    1018:	6862      	ldr	r2, [r4, #4]
    101a:	2380      	movs	r3, #128	; 0x80
    101c:	02db      	lsls	r3, r3, #11
    101e:	4313      	orrs	r3, r2
    1020:	6063      	str	r3, [r4, #4]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
    1022:	8a23      	ldrh	r3, [r4, #16]
    1024:	0bdb      	lsrs	r3, r3, #15
    1026:	d1fc      	bne.n	1022 <_sercom_i2c_sync_send_address+0x11e>
			if (msg->len == 0) {
    1028:	686b      	ldr	r3, [r5, #4]
    102a:	2b00      	cmp	r3, #0
    102c:	d107      	bne.n	103e <_sercom_i2c_sync_send_address+0x13a>
				if (msg->flags & I2C_M_STOP) {
    102e:	886b      	ldrh	r3, [r5, #2]
    1030:	b21b      	sxth	r3, r3
    1032:	2b00      	cmp	r3, #0
    1034:	db0c      	blt.n	1050 <_sercom_i2c_sync_send_address+0x14c>
				msg->flags &= ~I2C_M_BUSY;
    1036:	886b      	ldrh	r3, [r5, #2]
    1038:	4a17      	ldr	r2, [pc, #92]	; (1098 <_sercom_i2c_sync_send_address+0x194>)
    103a:	4013      	ands	r3, r2
    103c:	806b      	strh	r3, [r5, #2]
			*msg->buffer++ = hri_sercomi2cm_read_DATA_reg(hw);
    103e:	68ab      	ldr	r3, [r5, #8]
    1040:	1c5a      	adds	r2, r3, #1
    1042:	60aa      	str	r2, [r5, #8]
	return ((Sercom *)hw)->I2CM.DATA.reg;
    1044:	7e22      	ldrb	r2, [r4, #24]
    1046:	701a      	strb	r2, [r3, #0]
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
    1048:	2302      	movs	r3, #2
    104a:	73a3      	strb	r3, [r4, #14]
	return I2C_OK;
    104c:	2000      	movs	r0, #0
}
    104e:	bd70      	pop	{r4, r5, r6, pc}
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_SMEN;
    1050:	6863      	ldr	r3, [r4, #4]
    1052:	4a11      	ldr	r2, [pc, #68]	; (1098 <_sercom_i2c_sync_send_address+0x194>)
    1054:	4013      	ands	r3, r2
    1056:	6063      	str	r3, [r4, #4]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
    1058:	8a23      	ldrh	r3, [r4, #16]
    105a:	0bdb      	lsrs	r3, r3, #15
    105c:	d1fc      	bne.n	1058 <_sercom_i2c_sync_send_address+0x154>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
    105e:	6862      	ldr	r2, [r4, #4]
    1060:	23c0      	movs	r3, #192	; 0xc0
    1062:	029b      	lsls	r3, r3, #10
    1064:	4313      	orrs	r3, r2
    1066:	6063      	str	r3, [r4, #4]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
    1068:	8a23      	ldrh	r3, [r4, #16]
    106a:	0bdb      	lsrs	r3, r3, #15
    106c:	d1fc      	bne.n	1068 <_sercom_i2c_sync_send_address+0x164>
    106e:	e7e2      	b.n	1036 <_sercom_i2c_sync_send_address+0x132>
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
    1070:	2302      	movs	r3, #2
    1072:	73a3      	strb	r3, [r4, #14]
			return I2C_NACK;
    1074:	2002      	movs	r0, #2
    1076:	4240      	negs	r0, r0
    1078:	e7e9      	b.n	104e <_sercom_i2c_sync_send_address+0x14a>
			return I2C_ERR_BAD_ADDRESS;
    107a:	2004      	movs	r0, #4
    107c:	4240      	negs	r0, r0
    107e:	e7e6      	b.n	104e <_sercom_i2c_sync_send_address+0x14a>
	return I2C_OK;
    1080:	2000      	movs	r0, #0
	return _sercom_i2c_sync_analyse_flags(hw, flags, msg);
    1082:	e7e4      	b.n	104e <_sercom_i2c_sync_send_address+0x14a>
    1084:	00000581 	.word	0x00000581
    1088:	00004ab4 	.word	0x00004ab4
    108c:	000009e5 	.word	0x000009e5
    1090:	fffbffff 	.word	0xfffbffff
    1094:	0000ffff 	.word	0x0000ffff
    1098:	fffffeff 	.word	0xfffffeff

0000109c <_usart_sync_init>:
{
    109c:	b570      	push	{r4, r5, r6, lr}
    109e:	0005      	movs	r5, r0
    10a0:	000c      	movs	r4, r1
	ASSERT(device);
    10a2:	1e43      	subs	r3, r0, #1
    10a4:	4198      	sbcs	r0, r3
    10a6:	b2c0      	uxtb	r0, r0
    10a8:	22a1      	movs	r2, #161	; 0xa1
    10aa:	4904      	ldr	r1, [pc, #16]	; (10bc <_usart_sync_init+0x20>)
    10ac:	4b04      	ldr	r3, [pc, #16]	; (10c0 <_usart_sync_init+0x24>)
    10ae:	4798      	blx	r3
	device->hw = hw;
    10b0:	602c      	str	r4, [r5, #0]
	return _usart_init(hw);
    10b2:	0020      	movs	r0, r4
    10b4:	4b03      	ldr	r3, [pc, #12]	; (10c4 <_usart_sync_init+0x28>)
    10b6:	4798      	blx	r3
}
    10b8:	bd70      	pop	{r4, r5, r6, pc}
    10ba:	46c0      	nop			; (mov r8, r8)
    10bc:	00004ab4 	.word	0x00004ab4
    10c0:	000009e5 	.word	0x000009e5
    10c4:	00000e49 	.word	0x00000e49

000010c8 <_usart_sync_enable>:
	hri_sercomusart_set_CTRLA_ENABLE_bit(device->hw);
    10c8:	6802      	ldr	r2, [r0, #0]
	((Sercom *)hw)->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
    10ca:	6813      	ldr	r3, [r2, #0]
    10cc:	2102      	movs	r1, #2
    10ce:	430b      	orrs	r3, r1
    10d0:	6013      	str	r3, [r2, #0]
	while (((const Sercom *)hw)->USART.STATUS.bit.SYNCBUSY)
    10d2:	8a13      	ldrh	r3, [r2, #16]
    10d4:	0bdb      	lsrs	r3, r3, #15
    10d6:	d1fc      	bne.n	10d2 <_usart_sync_enable+0xa>
}
    10d8:	4770      	bx	lr

000010da <_usart_sync_write_byte>:
	hri_sercomusart_write_DATA_reg(device->hw, data);
    10da:	6803      	ldr	r3, [r0, #0]
    10dc:	b289      	uxth	r1, r1
	((Sercom *)hw)->USART.DATA.reg = data;
    10de:	8319      	strh	r1, [r3, #24]
}
    10e0:	4770      	bx	lr

000010e2 <_usart_sync_read_byte>:
	return hri_sercomusart_read_DATA_reg(device->hw);
    10e2:	6803      	ldr	r3, [r0, #0]
	return ((Sercom *)hw)->USART.DATA.reg;
    10e4:	8b18      	ldrh	r0, [r3, #24]
    10e6:	b2c0      	uxtb	r0, r0
}
    10e8:	4770      	bx	lr

000010ea <_usart_sync_is_ready_to_send>:
	return hri_sercomusart_get_interrupt_DRE_bit(device->hw);
    10ea:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE) >> SERCOM_USART_INTFLAG_DRE_Pos;
    10ec:	7b98      	ldrb	r0, [r3, #14]
    10ee:	2301      	movs	r3, #1
    10f0:	4018      	ands	r0, r3
}
    10f2:	4770      	bx	lr

000010f4 <_usart_sync_is_transmit_done>:
	return hri_sercomusart_get_interrupt_TXC_bit(device->hw);
    10f4:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_TXC) >> SERCOM_USART_INTFLAG_TXC_Pos;
    10f6:	7b9b      	ldrb	r3, [r3, #14]
    10f8:	085b      	lsrs	r3, r3, #1
    10fa:	2001      	movs	r0, #1
    10fc:	4018      	ands	r0, r3
}
    10fe:	4770      	bx	lr

00001100 <_usart_sync_is_byte_received>:
	return hri_sercomusart_get_interrupt_RXC_bit(device->hw);
    1100:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_RXC) >> SERCOM_USART_INTFLAG_RXC_Pos;
    1102:	7b9b      	ldrb	r3, [r3, #14]
    1104:	089b      	lsrs	r3, r3, #2
    1106:	2001      	movs	r0, #1
    1108:	4018      	ands	r0, r3
}
    110a:	4770      	bx	lr

0000110c <_i2c_m_sync_init>:
{
    110c:	b570      	push	{r4, r5, r6, lr}
    110e:	0006      	movs	r6, r0
    1110:	000c      	movs	r4, r1
	uint8_t i = _get_i2cm_index(hw);
    1112:	0008      	movs	r0, r1
    1114:	4b23      	ldr	r3, [pc, #140]	; (11a4 <_i2c_m_sync_init+0x98>)
    1116:	4798      	blx	r3
    1118:	0005      	movs	r5, r0
	ASSERT(i2c_dev);
    111a:	0030      	movs	r0, r6
    111c:	1e43      	subs	r3, r0, #1
    111e:	4198      	sbcs	r0, r3
    1120:	b2c0      	uxtb	r0, r0
    1122:	4a21      	ldr	r2, [pc, #132]	; (11a8 <_i2c_m_sync_init+0x9c>)
    1124:	4921      	ldr	r1, [pc, #132]	; (11ac <_i2c_m_sync_init+0xa0>)
    1126:	4b22      	ldr	r3, [pc, #136]	; (11b0 <_i2c_m_sync_init+0xa4>)
    1128:	4798      	blx	r3
	i2c_dev->hw = hw;
    112a:	6134      	str	r4, [r6, #16]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
    112c:	8a23      	ldrh	r3, [r4, #16]
    112e:	0bdb      	lsrs	r3, r3, #15
    1130:	d1fc      	bne.n	112c <_i2c_m_sync_init+0x20>
    1132:	8a23      	ldrh	r3, [r4, #16]
    1134:	0bdb      	lsrs	r3, r3, #15
    1136:	d1fc      	bne.n	1132 <_i2c_m_sync_init+0x26>
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
    1138:	6823      	ldr	r3, [r4, #0]
	if (hri_sercomi2cm_get_CTRLA_reg(hw, SERCOM_I2CM_CTRLA_ENABLE)) {
    113a:	079b      	lsls	r3, r3, #30
    113c:	d507      	bpl.n	114e <_i2c_m_sync_init+0x42>
	((Sercom *)hw)->I2CM.CTRLA.reg = data;
    113e:	2300      	movs	r3, #0
    1140:	6023      	str	r3, [r4, #0]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
    1142:	8a23      	ldrh	r3, [r4, #16]
    1144:	0bdb      	lsrs	r3, r3, #15
    1146:	d1fc      	bne.n	1142 <_i2c_m_sync_init+0x36>
    1148:	8a23      	ldrh	r3, [r4, #16]
    114a:	0bdb      	lsrs	r3, r3, #15
    114c:	d1fc      	bne.n	1148 <_i2c_m_sync_init+0x3c>
	((Sercom *)hw)->I2CM.CTRLA.reg = data;
    114e:	2301      	movs	r3, #1
    1150:	6023      	str	r3, [r4, #0]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
    1152:	8a23      	ldrh	r3, [r4, #16]
    1154:	0bdb      	lsrs	r3, r3, #15
    1156:	d1fc      	bne.n	1152 <_i2c_m_sync_init+0x46>
    1158:	8a23      	ldrh	r3, [r4, #16]
    115a:	0bdb      	lsrs	r3, r3, #15
    115c:	d1fc      	bne.n	1158 <_i2c_m_sync_init+0x4c>
	hri_sercomi2cm_write_CTRLA_reg(hw, _i2cms[i].ctrl_a & ~SERCOM_I2CM_CTRLA_ENABLE);
    115e:	006b      	lsls	r3, r5, #1
    1160:	195b      	adds	r3, r3, r5
    1162:	00da      	lsls	r2, r3, #3
    1164:	4b13      	ldr	r3, [pc, #76]	; (11b4 <_i2c_m_sync_init+0xa8>)
    1166:	189b      	adds	r3, r3, r2
    1168:	695b      	ldr	r3, [r3, #20]
    116a:	2202      	movs	r2, #2
    116c:	4393      	bics	r3, r2
	((Sercom *)hw)->I2CM.CTRLA.reg = data;
    116e:	6023      	str	r3, [r4, #0]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
    1170:	8a23      	ldrh	r3, [r4, #16]
    1172:	0bdb      	lsrs	r3, r3, #15
    1174:	d1fc      	bne.n	1170 <_i2c_m_sync_init+0x64>
	hri_sercomi2cm_write_CTRLB_reg(hw, _i2cms[i].ctrl_b);
    1176:	006b      	lsls	r3, r5, #1
    1178:	195b      	adds	r3, r3, r5
    117a:	00da      	lsls	r2, r3, #3
    117c:	4b0d      	ldr	r3, [pc, #52]	; (11b4 <_i2c_m_sync_init+0xa8>)
    117e:	189b      	adds	r3, r3, r2
    1180:	699b      	ldr	r3, [r3, #24]
	((Sercom *)hw)->I2CM.CTRLB.reg = data;
    1182:	6063      	str	r3, [r4, #4]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
    1184:	8a23      	ldrh	r3, [r4, #16]
    1186:	0bdb      	lsrs	r3, r3, #15
    1188:	d1fc      	bne.n	1184 <_i2c_m_sync_init+0x78>
	hri_sercomi2cm_write_BAUD_reg(hw, _i2cms[i].baud);
    118a:	4a0a      	ldr	r2, [pc, #40]	; (11b4 <_i2c_m_sync_init+0xa8>)
    118c:	006b      	lsls	r3, r5, #1
    118e:	1958      	adds	r0, r3, r5
    1190:	00c1      	lsls	r1, r0, #3
    1192:	0008      	movs	r0, r1
    1194:	1851      	adds	r1, r2, r1
    1196:	8b89      	ldrh	r1, [r1, #28]
	((Sercom *)hw)->I2CM.BAUD.reg = data;
    1198:	8161      	strh	r1, [r4, #10]
	i2c_dev->service.trise = _i2cms[i].trise;
    119a:	1812      	adds	r2, r2, r0
    119c:	8c13      	ldrh	r3, [r2, #32]
    119e:	81f3      	strh	r3, [r6, #14]
}
    11a0:	2000      	movs	r0, #0
    11a2:	bd70      	pop	{r4, r5, r6, pc}
    11a4:	00000ebd 	.word	0x00000ebd
    11a8:	000004d7 	.word	0x000004d7
    11ac:	00004ab4 	.word	0x00004ab4
    11b0:	000009e5 	.word	0x000009e5
    11b4:	00004a5c 	.word	0x00004a5c

000011b8 <_i2c_m_sync_enable>:
{
    11b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    11ba:	0006      	movs	r6, r0
	void *hw              = i2c_dev->hw;
    11bc:	6904      	ldr	r4, [r0, #16]
	ASSERT(i2c_dev);
    11be:	4d18      	ldr	r5, [pc, #96]	; (1220 <_i2c_m_sync_enable+0x68>)
    11c0:	1e43      	subs	r3, r0, #1
    11c2:	4198      	sbcs	r0, r3
    11c4:	b2c0      	uxtb	r0, r0
    11c6:	22a1      	movs	r2, #161	; 0xa1
    11c8:	00d2      	lsls	r2, r2, #3
    11ca:	0029      	movs	r1, r5
    11cc:	4f15      	ldr	r7, [pc, #84]	; (1224 <_i2c_m_sync_enable+0x6c>)
    11ce:	47b8      	blx	r7
	ASSERT(i2c_dev->hw);
    11d0:	6930      	ldr	r0, [r6, #16]
    11d2:	1e43      	subs	r3, r0, #1
    11d4:	4198      	sbcs	r0, r3
    11d6:	b2c0      	uxtb	r0, r0
    11d8:	4a13      	ldr	r2, [pc, #76]	; (1228 <_i2c_m_sync_enable+0x70>)
    11da:	0029      	movs	r1, r5
    11dc:	47b8      	blx	r7
	((Sercom *)hw)->I2CM.CTRLA.reg |= SERCOM_I2CM_CTRLA_ENABLE;
    11de:	6823      	ldr	r3, [r4, #0]
    11e0:	2202      	movs	r2, #2
    11e2:	4313      	orrs	r3, r2
    11e4:	6023      	str	r3, [r4, #0]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
    11e6:	8a23      	ldrh	r3, [r4, #16]
    11e8:	0bdb      	lsrs	r3, r3, #15
    11ea:	d1fc      	bne.n	11e6 <_i2c_m_sync_enable+0x2e>
    11ec:	2004      	movs	r0, #4
    11ee:	490f      	ldr	r1, [pc, #60]	; (122c <_i2c_m_sync_enable+0x74>)
    11f0:	8a23      	ldrh	r3, [r4, #16]
    11f2:	0bdb      	lsrs	r3, r3, #15
    11f4:	d1fc      	bne.n	11f0 <_i2c_m_sync_enable+0x38>
	return (((Sercom *)hw)->I2CM.STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE_Msk) >> SERCOM_I2CM_STATUS_BUSSTATE_Pos;
    11f6:	8a22      	ldrh	r2, [r4, #16]
    11f8:	0912      	lsrs	r2, r2, #4
    11fa:	3303      	adds	r3, #3
    11fc:	4013      	ands	r3, r2
	while (hri_sercomi2cm_read_STATUS_BUSSTATE_bf(hw) != I2C_IDLE) {
    11fe:	2b01      	cmp	r3, #1
    1200:	d008      	beq.n	1214 <_i2c_m_sync_enable+0x5c>
		timeout--;
    1202:	3901      	subs	r1, #1
		if (timeout <= 0) {
    1204:	2900      	cmp	r1, #0
    1206:	dcf3      	bgt.n	11f0 <_i2c_m_sync_enable+0x38>
			if (--timeout_attempt)
    1208:	3801      	subs	r0, #1
    120a:	2800      	cmp	r0, #0
    120c:	d004      	beq.n	1218 <_i2c_m_sync_enable+0x60>
			((Sercom *)hw)->I2CM.STATUS.reg = SERCOM_I2CM_STATUS_BUSSTATE(I2C_IDLE);
    120e:	2310      	movs	r3, #16
    1210:	8223      	strh	r3, [r4, #16]
    1212:	e7ec      	b.n	11ee <_i2c_m_sync_enable+0x36>
	return ERR_NONE;
    1214:	2000      	movs	r0, #0
}
    1216:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				return I2C_ERR_BUSY;
    1218:	2006      	movs	r0, #6
    121a:	4240      	negs	r0, r0
    121c:	e7fb      	b.n	1216 <_i2c_m_sync_enable+0x5e>
    121e:	46c0      	nop			; (mov r8, r8)
    1220:	00004ab4 	.word	0x00004ab4
    1224:	000009e5 	.word	0x000009e5
    1228:	00000509 	.word	0x00000509
    122c:	0000ffff 	.word	0x0000ffff

00001230 <_i2c_m_sync_transfer>:
{
    1230:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1232:	0005      	movs	r5, r0
    1234:	000e      	movs	r6, r1
	void *   hw = i2c_dev->hw;
    1236:	6904      	ldr	r4, [r0, #16]
	ASSERT(i2c_dev);
    1238:	1e43      	subs	r3, r0, #1
    123a:	4198      	sbcs	r0, r3
    123c:	b2c0      	uxtb	r0, r0
    123e:	4a7b      	ldr	r2, [pc, #492]	; (142c <_i2c_m_sync_transfer+0x1fc>)
    1240:	497b      	ldr	r1, [pc, #492]	; (1430 <_i2c_m_sync_transfer+0x200>)
    1242:	4f7c      	ldr	r7, [pc, #496]	; (1434 <_i2c_m_sync_transfer+0x204>)
    1244:	47b8      	blx	r7
	ASSERT(i2c_dev->hw);
    1246:	6928      	ldr	r0, [r5, #16]
    1248:	1e43      	subs	r3, r0, #1
    124a:	4198      	sbcs	r0, r3
    124c:	b2c0      	uxtb	r0, r0
    124e:	4a7a      	ldr	r2, [pc, #488]	; (1438 <_i2c_m_sync_transfer+0x208>)
    1250:	4977      	ldr	r1, [pc, #476]	; (1430 <_i2c_m_sync_transfer+0x200>)
    1252:	47b8      	blx	r7
	ASSERT(msg);
    1254:	0030      	movs	r0, r6
    1256:	1e43      	subs	r3, r0, #1
    1258:	4198      	sbcs	r0, r3
    125a:	b2c0      	uxtb	r0, r0
    125c:	4a77      	ldr	r2, [pc, #476]	; (143c <_i2c_m_sync_transfer+0x20c>)
    125e:	4974      	ldr	r1, [pc, #464]	; (1430 <_i2c_m_sync_transfer+0x200>)
    1260:	47b8      	blx	r7
	if (i2c_dev->service.msg.flags & I2C_M_BUSY) {
    1262:	886b      	ldrh	r3, [r5, #2]
    1264:	05db      	lsls	r3, r3, #23
    1266:	d500      	bpl.n	126a <_i2c_m_sync_transfer+0x3a>
    1268:	e0dc      	b.n	1424 <_i2c_m_sync_transfer+0x1f4>
	msg->flags |= I2C_M_BUSY;
    126a:	8872      	ldrh	r2, [r6, #2]
    126c:	2380      	movs	r3, #128	; 0x80
    126e:	005b      	lsls	r3, r3, #1
    1270:	469c      	mov	ip, r3
    1272:	431a      	orrs	r2, r3
    1274:	8072      	strh	r2, [r6, #2]
	i2c_dev->service.msg = *msg;
    1276:	002a      	movs	r2, r5
    1278:	0031      	movs	r1, r6
    127a:	c989      	ldmia	r1!, {r0, r3, r7}
    127c:	c289      	stmia	r2!, {r0, r3, r7}
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_SMEN;
    127e:	6862      	ldr	r2, [r4, #4]
    1280:	4663      	mov	r3, ip
    1282:	4313      	orrs	r3, r2
    1284:	6063      	str	r3, [r4, #4]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
    1286:	8a23      	ldrh	r3, [r4, #16]
    1288:	0bdb      	lsrs	r3, r3, #15
    128a:	d1fc      	bne.n	1286 <_i2c_m_sync_transfer+0x56>
	ret = _sercom_i2c_sync_send_address(i2c_dev);
    128c:	0028      	movs	r0, r5
    128e:	4b6c      	ldr	r3, [pc, #432]	; (1440 <_i2c_m_sync_transfer+0x210>)
    1290:	4798      	blx	r3
	if (ret) {
    1292:	2800      	cmp	r0, #0
    1294:	d100      	bne.n	1298 <_i2c_m_sync_transfer+0x68>
    1296:	e07d      	b.n	1394 <_i2c_m_sync_transfer+0x164>
		i2c_dev->service.msg.flags &= ~I2C_M_BUSY;
    1298:	886b      	ldrh	r3, [r5, #2]
    129a:	4a6a      	ldr	r2, [pc, #424]	; (1444 <_i2c_m_sync_transfer+0x214>)
    129c:	4013      	ands	r3, r2
    129e:	806b      	strh	r3, [r5, #2]
}
    12a0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			return I2C_ERR_BUS;
    12a2:	2005      	movs	r0, #5
    12a4:	4240      	negs	r0, r0
    12a6:	e086      	b.n	13b6 <_i2c_m_sync_transfer+0x186>
			if (msg->flags & I2C_M_STOP) {
    12a8:	8873      	ldrh	r3, [r6, #2]
    12aa:	b21b      	sxth	r3, r3
    12ac:	2b00      	cmp	r3, #0
    12ae:	db04      	blt.n	12ba <_i2c_m_sync_transfer+0x8a>
			i2c_dev->service.msg.flags &= ~I2C_M_BUSY;
    12b0:	886b      	ldrh	r3, [r5, #2]
    12b2:	4a64      	ldr	r2, [pc, #400]	; (1444 <_i2c_m_sync_transfer+0x214>)
    12b4:	4013      	ands	r3, r2
    12b6:	806b      	strh	r3, [r5, #2]
			return ret;
    12b8:	e7f2      	b.n	12a0 <_i2c_m_sync_transfer+0x70>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
    12ba:	6862      	ldr	r2, [r4, #4]
    12bc:	23c0      	movs	r3, #192	; 0xc0
    12be:	029b      	lsls	r3, r3, #10
    12c0:	4313      	orrs	r3, r2
    12c2:	6063      	str	r3, [r4, #4]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
    12c4:	8a23      	ldrh	r3, [r4, #16]
    12c6:	0bdb      	lsrs	r3, r3, #15
    12c8:	d1fc      	bne.n	12c4 <_i2c_m_sync_transfer+0x94>
    12ca:	e7f1      	b.n	12b0 <_i2c_m_sync_transfer+0x80>
			if (status & SERCOM_I2CM_STATUS_RXNACK) {
    12cc:	075b      	lsls	r3, r3, #29
    12ce:	d40b      	bmi.n	12e8 <_i2c_m_sync_transfer+0xb8>
			if (msg->len == 0) {
    12d0:	6868      	ldr	r0, [r5, #4]
    12d2:	2800      	cmp	r0, #0
    12d4:	d12d      	bne.n	1332 <_i2c_m_sync_transfer+0x102>
				if (msg->flags & I2C_M_STOP) {
    12d6:	886b      	ldrh	r3, [r5, #2]
    12d8:	b21b      	sxth	r3, r3
    12da:	2b00      	cmp	r3, #0
    12dc:	db20      	blt.n	1320 <_i2c_m_sync_transfer+0xf0>
				msg->flags &= ~I2C_M_BUSY;
    12de:	886b      	ldrh	r3, [r5, #2]
    12e0:	4a58      	ldr	r2, [pc, #352]	; (1444 <_i2c_m_sync_transfer+0x214>)
    12e2:	4013      	ands	r3, r2
    12e4:	806b      	strh	r3, [r5, #2]
    12e6:	e055      	b.n	1394 <_i2c_m_sync_transfer+0x164>
				if (msg->len > 0) {
    12e8:	686b      	ldr	r3, [r5, #4]
    12ea:	2b00      	cmp	r3, #0
    12ec:	dd04      	ble.n	12f8 <_i2c_m_sync_transfer+0xc8>
					msg->flags |= I2C_M_FAIL;
    12ee:	886b      	ldrh	r3, [r5, #2]
    12f0:	2280      	movs	r2, #128	; 0x80
    12f2:	0152      	lsls	r2, r2, #5
    12f4:	4313      	orrs	r3, r2
    12f6:	806b      	strh	r3, [r5, #2]
				if (msg->flags & I2C_M_STOP) {
    12f8:	886b      	ldrh	r3, [r5, #2]
    12fa:	b21b      	sxth	r3, r3
    12fc:	2b00      	cmp	r3, #0
    12fe:	db06      	blt.n	130e <_i2c_m_sync_transfer+0xde>
				msg->flags &= ~I2C_M_BUSY;
    1300:	886b      	ldrh	r3, [r5, #2]
    1302:	4a50      	ldr	r2, [pc, #320]	; (1444 <_i2c_m_sync_transfer+0x214>)
    1304:	4013      	ands	r3, r2
    1306:	806b      	strh	r3, [r5, #2]
				return I2C_NACK;
    1308:	2002      	movs	r0, #2
    130a:	4240      	negs	r0, r0
    130c:	e042      	b.n	1394 <_i2c_m_sync_transfer+0x164>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
    130e:	6862      	ldr	r2, [r4, #4]
    1310:	23c0      	movs	r3, #192	; 0xc0
    1312:	029b      	lsls	r3, r3, #10
    1314:	4313      	orrs	r3, r2
    1316:	6063      	str	r3, [r4, #4]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
    1318:	8a23      	ldrh	r3, [r4, #16]
    131a:	0bdb      	lsrs	r3, r3, #15
    131c:	d1fc      	bne.n	1318 <_i2c_m_sync_transfer+0xe8>
    131e:	e7ef      	b.n	1300 <_i2c_m_sync_transfer+0xd0>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
    1320:	6862      	ldr	r2, [r4, #4]
    1322:	23c0      	movs	r3, #192	; 0xc0
    1324:	029b      	lsls	r3, r3, #10
    1326:	4313      	orrs	r3, r2
    1328:	6063      	str	r3, [r4, #4]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
    132a:	8a23      	ldrh	r3, [r4, #16]
    132c:	0bdb      	lsrs	r3, r3, #15
    132e:	d1fc      	bne.n	132a <_i2c_m_sync_transfer+0xfa>
    1330:	e7d5      	b.n	12de <_i2c_m_sync_transfer+0xae>
				hri_sercomi2cm_write_DATA_reg(hw, *msg->buffer);
    1332:	68ab      	ldr	r3, [r5, #8]
    1334:	781b      	ldrb	r3, [r3, #0]
	((Sercom *)hw)->I2CM.DATA.reg = data;
    1336:	7623      	strb	r3, [r4, #24]
				msg->buffer++;
    1338:	68ab      	ldr	r3, [r5, #8]
    133a:	3301      	adds	r3, #1
    133c:	60ab      	str	r3, [r5, #8]
				msg->len--;
    133e:	686b      	ldr	r3, [r5, #4]
    1340:	3b01      	subs	r3, #1
    1342:	606b      	str	r3, [r5, #4]
			return I2C_OK;
    1344:	2000      	movs	r0, #0
    1346:	e025      	b.n	1394 <_i2c_m_sync_transfer+0x164>
	} else if (flags & SB_FLAG) {
    1348:	078a      	lsls	r2, r1, #30
    134a:	d569      	bpl.n	1420 <_i2c_m_sync_transfer+0x1f0>
		if ((msg->len) && !(status & SERCOM_I2CM_STATUS_RXNACK)) {
    134c:	686a      	ldr	r2, [r5, #4]
    134e:	2a00      	cmp	r2, #0
    1350:	d05e      	beq.n	1410 <_i2c_m_sync_transfer+0x1e0>
    1352:	075b      	lsls	r3, r3, #29
    1354:	d45c      	bmi.n	1410 <_i2c_m_sync_transfer+0x1e0>
			msg->len--;
    1356:	3a01      	subs	r2, #1
    1358:	606a      	str	r2, [r5, #4]
			if (msg->len == 0) {
    135a:	2a00      	cmp	r2, #0
    135c:	d107      	bne.n	136e <_i2c_m_sync_transfer+0x13e>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
    135e:	6862      	ldr	r2, [r4, #4]
    1360:	2380      	movs	r3, #128	; 0x80
    1362:	02db      	lsls	r3, r3, #11
    1364:	4313      	orrs	r3, r2
    1366:	6063      	str	r3, [r4, #4]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
    1368:	8a23      	ldrh	r3, [r4, #16]
    136a:	0bdb      	lsrs	r3, r3, #15
    136c:	d1fc      	bne.n	1368 <_i2c_m_sync_transfer+0x138>
			if (msg->len == 0) {
    136e:	686b      	ldr	r3, [r5, #4]
    1370:	2b00      	cmp	r3, #0
    1372:	d107      	bne.n	1384 <_i2c_m_sync_transfer+0x154>
				if (msg->flags & I2C_M_STOP) {
    1374:	886b      	ldrh	r3, [r5, #2]
    1376:	b21b      	sxth	r3, r3
    1378:	2b00      	cmp	r3, #0
    137a:	db39      	blt.n	13f0 <_i2c_m_sync_transfer+0x1c0>
				msg->flags &= ~I2C_M_BUSY;
    137c:	886b      	ldrh	r3, [r5, #2]
    137e:	4a31      	ldr	r2, [pc, #196]	; (1444 <_i2c_m_sync_transfer+0x214>)
    1380:	4013      	ands	r3, r2
    1382:	806b      	strh	r3, [r5, #2]
			*msg->buffer++ = hri_sercomi2cm_read_DATA_reg(hw);
    1384:	68ab      	ldr	r3, [r5, #8]
    1386:	1c5a      	adds	r2, r3, #1
    1388:	60aa      	str	r2, [r5, #8]
	return ((Sercom *)hw)->I2CM.DATA.reg;
    138a:	7e22      	ldrb	r2, [r4, #24]
    138c:	701a      	strb	r2, [r3, #0]
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
    138e:	2302      	movs	r3, #2
    1390:	73a3      	strb	r3, [r4, #14]
	return I2C_OK;
    1392:	2000      	movs	r0, #0
	while (i2c_dev->service.msg.flags & I2C_M_BUSY) {
    1394:	886b      	ldrh	r3, [r5, #2]
    1396:	05db      	lsls	r3, r3, #23
    1398:	d400      	bmi.n	139c <_i2c_m_sync_transfer+0x16c>
    139a:	e781      	b.n	12a0 <_i2c_m_sync_transfer+0x70>
	void *   hw      = i2c_dev->hw;
    139c:	692f      	ldr	r7, [r5, #16]
	uint32_t timeout = 65535;
    139e:	4a2a      	ldr	r2, [pc, #168]	; (1448 <_i2c_m_sync_transfer+0x218>)
	return ((Sercom *)hw)->I2CM.INTFLAG.reg;
    13a0:	7bbb      	ldrb	r3, [r7, #14]
    13a2:	b2db      	uxtb	r3, r3
		*flags = hri_sercomi2cm_read_INTFLAG_reg(hw);
    13a4:	0019      	movs	r1, r3
		if (timeout-- == 0) {
    13a6:	1e50      	subs	r0, r2, #1
    13a8:	2a00      	cmp	r2, #0
    13aa:	d100      	bne.n	13ae <_i2c_m_sync_transfer+0x17e>
    13ac:	e779      	b.n	12a2 <_i2c_m_sync_transfer+0x72>
    13ae:	0002      	movs	r2, r0
	} while (!(*flags & MB_FLAG) && !(*flags & SB_FLAG));
    13b0:	079b      	lsls	r3, r3, #30
    13b2:	d0f5      	beq.n	13a0 <_i2c_m_sync_transfer+0x170>
	return I2C_OK;
    13b4:	2000      	movs	r0, #0
		if (ret) {
    13b6:	2800      	cmp	r0, #0
    13b8:	d000      	beq.n	13bc <_i2c_m_sync_transfer+0x18c>
    13ba:	e775      	b.n	12a8 <_i2c_m_sync_transfer+0x78>
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
    13bc:	8a23      	ldrh	r3, [r4, #16]
    13be:	0bdb      	lsrs	r3, r3, #15
    13c0:	d1fc      	bne.n	13bc <_i2c_m_sync_transfer+0x18c>
	return ((Sercom *)hw)->I2CM.STATUS.reg;
    13c2:	8a23      	ldrh	r3, [r4, #16]
    13c4:	b29b      	uxth	r3, r3
	if (flags & MB_FLAG) {
    13c6:	07ca      	lsls	r2, r1, #31
    13c8:	d5be      	bpl.n	1348 <_i2c_m_sync_transfer+0x118>
		if (status & SERCOM_I2CM_STATUS_ARBLOST) {
    13ca:	079a      	lsls	r2, r3, #30
    13cc:	d400      	bmi.n	13d0 <_i2c_m_sync_transfer+0x1a0>
    13ce:	e77d      	b.n	12cc <_i2c_m_sync_transfer+0x9c>
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_MB;
    13d0:	2201      	movs	r2, #1
    13d2:	73a2      	strb	r2, [r4, #14]
			msg->flags |= I2C_M_FAIL;
    13d4:	886a      	ldrh	r2, [r5, #2]
    13d6:	2180      	movs	r1, #128	; 0x80
    13d8:	0149      	lsls	r1, r1, #5
    13da:	430a      	orrs	r2, r1
    13dc:	806a      	strh	r2, [r5, #2]
			msg->flags &= ~I2C_M_BUSY;
    13de:	886a      	ldrh	r2, [r5, #2]
    13e0:	4918      	ldr	r1, [pc, #96]	; (1444 <_i2c_m_sync_transfer+0x214>)
    13e2:	400a      	ands	r2, r1
    13e4:	806a      	strh	r2, [r5, #2]
			if (status & SERCOM_I2CM_STATUS_BUSERR) {
    13e6:	07db      	lsls	r3, r3, #31
    13e8:	d517      	bpl.n	141a <_i2c_m_sync_transfer+0x1ea>
				return I2C_ERR_BUS;
    13ea:	2005      	movs	r0, #5
    13ec:	4240      	negs	r0, r0
    13ee:	e7d1      	b.n	1394 <_i2c_m_sync_transfer+0x164>
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_SMEN;
    13f0:	6863      	ldr	r3, [r4, #4]
    13f2:	4a14      	ldr	r2, [pc, #80]	; (1444 <_i2c_m_sync_transfer+0x214>)
    13f4:	4013      	ands	r3, r2
    13f6:	6063      	str	r3, [r4, #4]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
    13f8:	8a23      	ldrh	r3, [r4, #16]
    13fa:	0bdb      	lsrs	r3, r3, #15
    13fc:	d1fc      	bne.n	13f8 <_i2c_m_sync_transfer+0x1c8>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
    13fe:	6862      	ldr	r2, [r4, #4]
    1400:	23c0      	movs	r3, #192	; 0xc0
    1402:	029b      	lsls	r3, r3, #10
    1404:	4313      	orrs	r3, r2
    1406:	6063      	str	r3, [r4, #4]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
    1408:	8a23      	ldrh	r3, [r4, #16]
    140a:	0bdb      	lsrs	r3, r3, #15
    140c:	d1fc      	bne.n	1408 <_i2c_m_sync_transfer+0x1d8>
    140e:	e7b5      	b.n	137c <_i2c_m_sync_transfer+0x14c>
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
    1410:	2302      	movs	r3, #2
    1412:	73a3      	strb	r3, [r4, #14]
			return I2C_NACK;
    1414:	2002      	movs	r0, #2
    1416:	4240      	negs	r0, r0
    1418:	e7bc      	b.n	1394 <_i2c_m_sync_transfer+0x164>
			return I2C_ERR_BAD_ADDRESS;
    141a:	2004      	movs	r0, #4
    141c:	4240      	negs	r0, r0
    141e:	e7b9      	b.n	1394 <_i2c_m_sync_transfer+0x164>
	return I2C_OK;
    1420:	2000      	movs	r0, #0
    1422:	e7b7      	b.n	1394 <_i2c_m_sync_transfer+0x164>
		return I2C_ERR_BUSY;
    1424:	2006      	movs	r0, #6
    1426:	4240      	negs	r0, r0
    1428:	e73a      	b.n	12a0 <_i2c_m_sync_transfer+0x70>
    142a:	46c0      	nop			; (mov r8, r8)
    142c:	0000059b 	.word	0x0000059b
    1430:	00004ab4 	.word	0x00004ab4
    1434:	000009e5 	.word	0x000009e5
    1438:	0000059c 	.word	0x0000059c
    143c:	0000059d 	.word	0x0000059d
    1440:	00000f05 	.word	0x00000f05
    1444:	fffffeff 	.word	0xfffffeff
    1448:	0000ffff 	.word	0x0000ffff

0000144c <_spi_m_sync_init>:

	return NULL;
}

int32_t _spi_m_sync_init(struct _spi_m_sync_dev *dev, void *const hw)
{
    144c:	b570      	push	{r4, r5, r6, lr}
    144e:	0006      	movs	r6, r0
    1450:	000c      	movs	r4, r1
	uint8_t n = _sercom_get_hardware_index((const void *)hw_addr);
    1452:	0008      	movs	r0, r1
    1454:	4b63      	ldr	r3, [pc, #396]	; (15e4 <_spi_m_sync_init+0x198>)
    1456:	4798      	blx	r3
	for (i = 0; i < sizeof(sercomspi_regs) / sizeof(struct sercomspi_regs_cfg); i++) {
    1458:	2300      	movs	r3, #0
    145a:	2b01      	cmp	r3, #1
    145c:	d80d      	bhi.n	147a <_spi_m_sync_init+0x2e>
		if (sercomspi_regs[i].n == n) {
    145e:	0119      	lsls	r1, r3, #4
    1460:	4a61      	ldr	r2, [pc, #388]	; (15e8 <_spi_m_sync_init+0x19c>)
    1462:	3238      	adds	r2, #56	; 0x38
    1464:	1852      	adds	r2, r2, r1
    1466:	7bd2      	ldrb	r2, [r2, #15]
    1468:	4290      	cmp	r0, r2
    146a:	d002      	beq.n	1472 <_spi_m_sync_init+0x26>
	for (i = 0; i < sizeof(sercomspi_regs) / sizeof(struct sercomspi_regs_cfg); i++) {
    146c:	3301      	adds	r3, #1
    146e:	b2db      	uxtb	r3, r3
    1470:	e7f3      	b.n	145a <_spi_m_sync_init+0xe>
			return &sercomspi_regs[i];
    1472:	4b5d      	ldr	r3, [pc, #372]	; (15e8 <_spi_m_sync_init+0x19c>)
    1474:	3338      	adds	r3, #56	; 0x38
    1476:	185d      	adds	r5, r3, r1
    1478:	e000      	b.n	147c <_spi_m_sync_init+0x30>
	return NULL;
    147a:	2500      	movs	r5, #0
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);

	ASSERT(dev && hw);
    147c:	2e00      	cmp	r6, #0
    147e:	d100      	bne.n	1482 <_spi_m_sync_init+0x36>
    1480:	e06a      	b.n	1558 <_spi_m_sync_init+0x10c>
    1482:	2c00      	cmp	r4, #0
    1484:	d100      	bne.n	1488 <_spi_m_sync_init+0x3c>
    1486:	e065      	b.n	1554 <_spi_m_sync_init+0x108>
    1488:	2001      	movs	r0, #1
    148a:	4a58      	ldr	r2, [pc, #352]	; (15ec <_spi_m_sync_init+0x1a0>)
    148c:	4958      	ldr	r1, [pc, #352]	; (15f0 <_spi_m_sync_init+0x1a4>)
    148e:	4b59      	ldr	r3, [pc, #356]	; (15f4 <_spi_m_sync_init+0x1a8>)
    1490:	4798      	blx	r3

	if (regs == NULL) {
    1492:	2d00      	cmp	r5, #0
    1494:	d100      	bne.n	1498 <_spi_m_sync_init+0x4c>
    1496:	e0a2      	b.n	15de <_spi_m_sync_init+0x192>
	while (((const Sercom *)hw)->SPI.STATUS.bit.SYNCBUSY)
    1498:	8a23      	ldrh	r3, [r4, #16]
    149a:	0bdb      	lsrs	r3, r3, #15
    149c:	d1fc      	bne.n	1498 <_spi_m_sync_init+0x4c>
    149e:	8a23      	ldrh	r3, [r4, #16]
    14a0:	0bdb      	lsrs	r3, r3, #15
    14a2:	d1fc      	bne.n	149e <_spi_m_sync_init+0x52>
	tmp = ((Sercom *)hw)->SPI.CTRLA.reg;
    14a4:	6823      	ldr	r3, [r4, #0]
		return ERR_INVALID_ARG;
	}

	hri_sercomspi_wait_for_sync(hw);
	if (hri_sercomspi_get_CTRLA_reg(hw, SERCOM_SPI_CTRLA_ENABLE)) {
    14a6:	079b      	lsls	r3, r3, #30
    14a8:	d507      	bpl.n	14ba <_spi_m_sync_init+0x6e>
	((Sercom *)hw)->SPI.CTRLA.reg = data;
    14aa:	2300      	movs	r3, #0
    14ac:	6023      	str	r3, [r4, #0]
	while (((const Sercom *)hw)->SPI.STATUS.bit.SYNCBUSY)
    14ae:	8a23      	ldrh	r3, [r4, #16]
    14b0:	0bdb      	lsrs	r3, r3, #15
    14b2:	d1fc      	bne.n	14ae <_spi_m_sync_init+0x62>
    14b4:	8a23      	ldrh	r3, [r4, #16]
    14b6:	0bdb      	lsrs	r3, r3, #15
    14b8:	d1fc      	bne.n	14b4 <_spi_m_sync_init+0x68>
	((Sercom *)hw)->SPI.CTRLA.reg = data;
    14ba:	2301      	movs	r3, #1
    14bc:	6023      	str	r3, [r4, #0]
	while (((const Sercom *)hw)->SPI.STATUS.bit.SYNCBUSY)
    14be:	8a23      	ldrh	r3, [r4, #16]
    14c0:	0bdb      	lsrs	r3, r3, #15
    14c2:	d1fc      	bne.n	14be <_spi_m_sync_init+0x72>
    14c4:	8a23      	ldrh	r3, [r4, #16]
    14c6:	0bdb      	lsrs	r3, r3, #15
    14c8:	d1fc      	bne.n	14c4 <_spi_m_sync_init+0x78>
		hri_sercomspi_wait_for_sync(hw);
	}
	hri_sercomspi_write_CTRLA_reg(hw, SERCOM_SPI_CTRLA_SWRST);
	hri_sercomspi_wait_for_sync(hw);

	dev->prvt = hw;
    14ca:	6034      	str	r4, [r6, #0]

	if ((regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk) == SERCOM_USART_CTRLA_MODE_SPI_SLAVE) {
    14cc:	782b      	ldrb	r3, [r5, #0]
    14ce:	786a      	ldrb	r2, [r5, #1]
    14d0:	0212      	lsls	r2, r2, #8
    14d2:	431a      	orrs	r2, r3
    14d4:	78ab      	ldrb	r3, [r5, #2]
    14d6:	041b      	lsls	r3, r3, #16
    14d8:	431a      	orrs	r2, r3
    14da:	78eb      	ldrb	r3, [r5, #3]
    14dc:	061b      	lsls	r3, r3, #24
    14de:	4313      	orrs	r3, r2
    14e0:	221c      	movs	r2, #28
    14e2:	4013      	ands	r3, r2
    14e4:	2b08      	cmp	r3, #8
    14e6:	d039      	beq.n	155c <_spi_m_sync_init+0x110>
	ASSERT(hw && regs);
    14e8:	2c00      	cmp	r4, #0
    14ea:	d100      	bne.n	14ee <_spi_m_sync_init+0xa2>
    14ec:	e073      	b.n	15d6 <_spi_m_sync_init+0x18a>
    14ee:	2d00      	cmp	r5, #0
    14f0:	d100      	bne.n	14f4 <_spi_m_sync_init+0xa8>
    14f2:	e06e      	b.n	15d2 <_spi_m_sync_init+0x186>
    14f4:	2001      	movs	r0, #1
    14f6:	4a40      	ldr	r2, [pc, #256]	; (15f8 <_spi_m_sync_init+0x1ac>)
    14f8:	493d      	ldr	r1, [pc, #244]	; (15f0 <_spi_m_sync_init+0x1a4>)
    14fa:	4b3e      	ldr	r3, [pc, #248]	; (15f4 <_spi_m_sync_init+0x1a8>)
    14fc:	4798      	blx	r3
	    hw, regs->ctrla & ~(SERCOM_SPI_CTRLA_IBON | SERCOM_SPI_CTRLA_ENABLE | SERCOM_SPI_CTRLA_SWRST));
    14fe:	782b      	ldrb	r3, [r5, #0]
    1500:	786a      	ldrb	r2, [r5, #1]
    1502:	0212      	lsls	r2, r2, #8
    1504:	431a      	orrs	r2, r3
    1506:	78ab      	ldrb	r3, [r5, #2]
    1508:	041b      	lsls	r3, r3, #16
    150a:	431a      	orrs	r2, r3
    150c:	78eb      	ldrb	r3, [r5, #3]
    150e:	061b      	lsls	r3, r3, #24
    1510:	4313      	orrs	r3, r2
	hri_sercomspi_write_CTRLA_reg(
    1512:	4a3a      	ldr	r2, [pc, #232]	; (15fc <_spi_m_sync_init+0x1b0>)
    1514:	4013      	ands	r3, r2
	((Sercom *)hw)->SPI.CTRLA.reg = data;
    1516:	6023      	str	r3, [r4, #0]
	while (((const Sercom *)hw)->SPI.STATUS.bit.SYNCBUSY)
    1518:	8a23      	ldrh	r3, [r4, #16]
    151a:	0bdb      	lsrs	r3, r3, #15
    151c:	d1fc      	bne.n	1518 <_spi_m_sync_init+0xcc>
	    hw, (regs->ctrlb & ~(SERCOM_SPI_CTRLB_AMODE_Msk | SERCOM_SPI_CTRLB_PLOADEN)) | (SERCOM_SPI_CTRLB_RXEN));
    151e:	792b      	ldrb	r3, [r5, #4]
    1520:	796a      	ldrb	r2, [r5, #5]
    1522:	0212      	lsls	r2, r2, #8
    1524:	431a      	orrs	r2, r3
    1526:	79ab      	ldrb	r3, [r5, #6]
    1528:	041b      	lsls	r3, r3, #16
    152a:	431a      	orrs	r2, r3
    152c:	79eb      	ldrb	r3, [r5, #7]
    152e:	061b      	lsls	r3, r3, #24
    1530:	4313      	orrs	r3, r2
    1532:	4a33      	ldr	r2, [pc, #204]	; (1600 <_spi_m_sync_init+0x1b4>)
    1534:	4013      	ands	r3, r2
	hri_sercomspi_write_CTRLB_reg(
    1536:	2280      	movs	r2, #128	; 0x80
    1538:	0292      	lsls	r2, r2, #10
    153a:	4313      	orrs	r3, r2
	((Sercom *)hw)->SPI.CTRLB.reg = data;
    153c:	6063      	str	r3, [r4, #4]
	hri_sercomspi_write_BAUD_reg(hw, regs->baud);
    153e:	7b2b      	ldrb	r3, [r5, #12]
	((Sercom *)hw)->SPI.BAUD.reg = data;
    1540:	72a3      	strb	r3, [r4, #10]
	hri_sercomspi_write_DBGCTRL_reg(hw, regs->dbgctrl);
    1542:	7b6b      	ldrb	r3, [r5, #13]
	((Sercom *)hw)->SPI.DBGCTRL.reg = data;
    1544:	7223      	strb	r3, [r4, #8]
	} else {
		_spi_load_regs_master(hw, regs);
	}

	/* Load character size from default hardware configuration */
	dev->char_size = ((regs->ctrlb & SERCOM_SPI_CTRLB_CHSIZE_Msk) == 0) ? 1 : 2;
    1546:	792b      	ldrb	r3, [r5, #4]
    1548:	075b      	lsls	r3, r3, #29
    154a:	d146      	bne.n	15da <_spi_m_sync_init+0x18e>
    154c:	2301      	movs	r3, #1
    154e:	7133      	strb	r3, [r6, #4]

	return ERR_NONE;
    1550:	2000      	movs	r0, #0
}
    1552:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(dev && hw);
    1554:	2000      	movs	r0, #0
    1556:	e798      	b.n	148a <_spi_m_sync_init+0x3e>
    1558:	2000      	movs	r0, #0
    155a:	e796      	b.n	148a <_spi_m_sync_init+0x3e>
	ASSERT(hw && regs);
    155c:	2c00      	cmp	r4, #0
    155e:	d036      	beq.n	15ce <_spi_m_sync_init+0x182>
    1560:	2d00      	cmp	r5, #0
    1562:	d032      	beq.n	15ca <_spi_m_sync_init+0x17e>
    1564:	2001      	movs	r0, #1
    1566:	4a27      	ldr	r2, [pc, #156]	; (1604 <_spi_m_sync_init+0x1b8>)
    1568:	4921      	ldr	r1, [pc, #132]	; (15f0 <_spi_m_sync_init+0x1a4>)
    156a:	4b22      	ldr	r3, [pc, #136]	; (15f4 <_spi_m_sync_init+0x1a8>)
    156c:	4798      	blx	r3
	    hw, regs->ctrla & ~(SERCOM_SPI_CTRLA_IBON | SERCOM_SPI_CTRLA_ENABLE | SERCOM_SPI_CTRLA_SWRST));
    156e:	782b      	ldrb	r3, [r5, #0]
    1570:	786a      	ldrb	r2, [r5, #1]
    1572:	0212      	lsls	r2, r2, #8
    1574:	431a      	orrs	r2, r3
    1576:	78ab      	ldrb	r3, [r5, #2]
    1578:	041b      	lsls	r3, r3, #16
    157a:	431a      	orrs	r2, r3
    157c:	78eb      	ldrb	r3, [r5, #3]
    157e:	061b      	lsls	r3, r3, #24
    1580:	4313      	orrs	r3, r2
	hri_sercomspi_write_CTRLA_reg(
    1582:	4a1e      	ldr	r2, [pc, #120]	; (15fc <_spi_m_sync_init+0x1b0>)
    1584:	4013      	ands	r3, r2
	((Sercom *)hw)->SPI.CTRLA.reg = data;
    1586:	6023      	str	r3, [r4, #0]
	while (((const Sercom *)hw)->SPI.STATUS.bit.SYNCBUSY)
    1588:	8a23      	ldrh	r3, [r4, #16]
    158a:	0bdb      	lsrs	r3, r3, #15
    158c:	d1fc      	bne.n	1588 <_spi_m_sync_init+0x13c>
	hri_sercomspi_write_CTRLB_reg(hw, regs->ctrlb | (SERCOM_SPI_CTRLB_RXEN | SERCOM_SPI_CTRLB_PLOADEN));
    158e:	792b      	ldrb	r3, [r5, #4]
    1590:	796a      	ldrb	r2, [r5, #5]
    1592:	0212      	lsls	r2, r2, #8
    1594:	431a      	orrs	r2, r3
    1596:	79ab      	ldrb	r3, [r5, #6]
    1598:	041b      	lsls	r3, r3, #16
    159a:	431a      	orrs	r2, r3
    159c:	79eb      	ldrb	r3, [r5, #7]
    159e:	061b      	lsls	r3, r3, #24
    15a0:	4313      	orrs	r3, r2
    15a2:	4a19      	ldr	r2, [pc, #100]	; (1608 <_spi_m_sync_init+0x1bc>)
    15a4:	4313      	orrs	r3, r2
	((Sercom *)hw)->SPI.CTRLB.reg = data;
    15a6:	6063      	str	r3, [r4, #4]
	hri_sercomspi_write_ADDR_reg(hw, regs->addr);
    15a8:	7a2b      	ldrb	r3, [r5, #8]
    15aa:	7a6a      	ldrb	r2, [r5, #9]
    15ac:	0212      	lsls	r2, r2, #8
    15ae:	431a      	orrs	r2, r3
    15b0:	7aab      	ldrb	r3, [r5, #10]
    15b2:	041b      	lsls	r3, r3, #16
    15b4:	431a      	orrs	r2, r3
    15b6:	7aeb      	ldrb	r3, [r5, #11]
    15b8:	061b      	lsls	r3, r3, #24
    15ba:	4313      	orrs	r3, r2
	((Sercom *)hw)->SPI.ADDR.reg = data;
    15bc:	6163      	str	r3, [r4, #20]
	hri_sercomspi_write_DBGCTRL_reg(hw, regs->dbgctrl);
    15be:	7b6b      	ldrb	r3, [r5, #13]
	((Sercom *)hw)->SPI.DBGCTRL.reg = data;
    15c0:	7223      	strb	r3, [r4, #8]
	return ((const Sercom *)hw)->SPI.STATUS.bit.SYNCBUSY;
    15c2:	8a23      	ldrh	r3, [r4, #16]
    15c4:	0bdb      	lsrs	r3, r3, #15
	while (hri_sercomspi_is_syncing(hw))
    15c6:	d1fc      	bne.n	15c2 <_spi_m_sync_init+0x176>
    15c8:	e7bd      	b.n	1546 <_spi_m_sync_init+0xfa>
	ASSERT(hw && regs);
    15ca:	2000      	movs	r0, #0
    15cc:	e7cb      	b.n	1566 <_spi_m_sync_init+0x11a>
    15ce:	2000      	movs	r0, #0
    15d0:	e7c9      	b.n	1566 <_spi_m_sync_init+0x11a>
	ASSERT(hw && regs);
    15d2:	2000      	movs	r0, #0
    15d4:	e78f      	b.n	14f6 <_spi_m_sync_init+0xaa>
    15d6:	2000      	movs	r0, #0
    15d8:	e78d      	b.n	14f6 <_spi_m_sync_init+0xaa>
	dev->char_size = ((regs->ctrlb & SERCOM_SPI_CTRLB_CHSIZE_Msk) == 0) ? 1 : 2;
    15da:	2302      	movs	r3, #2
    15dc:	e7b7      	b.n	154e <_spi_m_sync_init+0x102>
		return ERR_INVALID_ARG;
    15de:	200d      	movs	r0, #13
    15e0:	4240      	negs	r0, r0
    15e2:	e7b6      	b.n	1552 <_spi_m_sync_init+0x106>
    15e4:	00000dd9 	.word	0x00000dd9
    15e8:	00004a5c 	.word	0x00004a5c
    15ec:	000008a3 	.word	0x000008a3
    15f0:	00004ab4 	.word	0x00004ab4
    15f4:	000009e5 	.word	0x000009e5
    15f8:	00000872 	.word	0x00000872
    15fc:	fffffefc 	.word	0xfffffefc
    1600:	fffd3fbf 	.word	0xfffd3fbf
    1604:	00000883 	.word	0x00000883
    1608:	00020040 	.word	0x00020040

0000160c <_spi_m_sync_enable>:

	return _spi_deinit(hw);
}

int32_t _spi_m_sync_enable(struct _spi_m_sync_dev *dev)
{
    160c:	b510      	push	{r4, lr}
    160e:	1e04      	subs	r4, r0, #0
	ASSERT(dev && dev->prvt);
    1610:	d00d      	beq.n	162e <_spi_m_sync_enable+0x22>
    1612:	6803      	ldr	r3, [r0, #0]
    1614:	2b00      	cmp	r3, #0
    1616:	d008      	beq.n	162a <_spi_m_sync_enable+0x1e>
    1618:	2001      	movs	r0, #1
    161a:	4a06      	ldr	r2, [pc, #24]	; (1634 <_spi_m_sync_enable+0x28>)
    161c:	4906      	ldr	r1, [pc, #24]	; (1638 <_spi_m_sync_enable+0x2c>)
    161e:	4b07      	ldr	r3, [pc, #28]	; (163c <_spi_m_sync_enable+0x30>)
    1620:	4798      	blx	r3

	return _spi_sync_enable(dev->prvt);
    1622:	6820      	ldr	r0, [r4, #0]
    1624:	4b06      	ldr	r3, [pc, #24]	; (1640 <_spi_m_sync_enable+0x34>)
    1626:	4798      	blx	r3
}
    1628:	bd10      	pop	{r4, pc}
	ASSERT(dev && dev->prvt);
    162a:	2000      	movs	r0, #0
    162c:	e7f5      	b.n	161a <_spi_m_sync_enable+0xe>
    162e:	2000      	movs	r0, #0
    1630:	e7f3      	b.n	161a <_spi_m_sync_enable+0xe>
    1632:	46c0      	nop			; (mov r8, r8)
    1634:	0000090a 	.word	0x0000090a
    1638:	00004ab4 	.word	0x00004ab4
    163c:	000009e5 	.word	0x000009e5
    1640:	00000de9 	.word	0x00000de9

00001644 <_spi_m_sync_trans>:
	ctrl->txcnt++;
	hri_sercomspi_write_DATA_reg(hw, data);
}

int32_t _spi_m_sync_trans(struct _spi_m_sync_dev *dev, const struct spi_msg *msg)
{
    1644:	b570      	push	{r4, r5, r6, lr}
    1646:	b088      	sub	sp, #32
    1648:	000d      	movs	r5, r1
	void *                 hw   = dev->prvt;
    164a:	6804      	ldr	r4, [r0, #0]
	int32_t                rc   = 0;
	struct _spi_trans_ctrl ctrl = {msg->txbuf, msg->rxbuf, 0, 0, dev->char_size};
    164c:	680b      	ldr	r3, [r1, #0]
    164e:	9303      	str	r3, [sp, #12]
    1650:	684b      	ldr	r3, [r1, #4]
    1652:	9304      	str	r3, [sp, #16]
    1654:	2300      	movs	r3, #0
    1656:	9305      	str	r3, [sp, #20]
    1658:	9306      	str	r3, [sp, #24]
    165a:	7906      	ldrb	r6, [r0, #4]

	ASSERT(dev && hw);
    165c:	2800      	cmp	r0, #0
    165e:	d014      	beq.n	168a <_spi_m_sync_trans+0x46>
    1660:	2c00      	cmp	r4, #0
    1662:	d010      	beq.n	1686 <_spi_m_sync_trans+0x42>
    1664:	2001      	movs	r0, #1
    1666:	4a2d      	ldr	r2, [pc, #180]	; (171c <_spi_m_sync_trans+0xd8>)
    1668:	492d      	ldr	r1, [pc, #180]	; (1720 <_spi_m_sync_trans+0xdc>)
    166a:	4b2e      	ldr	r3, [pc, #184]	; (1724 <_spi_m_sync_trans+0xe0>)
    166c:	4798      	blx	r3
    166e:	8a23      	ldrh	r3, [r4, #16]
    1670:	0bdb      	lsrs	r3, r3, #15

	/* If settings are not applied (pending), we can not go on */
	if (hri_sercomspi_is_syncing(hw)) {
    1672:	d14f      	bne.n	1714 <_spi_m_sync_trans+0xd0>
	while (((const Sercom *)hw)->SPI.STATUS.bit.SYNCBUSY)
    1674:	8a23      	ldrh	r3, [r4, #16]
    1676:	0bdb      	lsrs	r3, r3, #15
    1678:	d1fc      	bne.n	1674 <_spi_m_sync_trans+0x30>
	tmp = ((Sercom *)hw)->SPI.CTRLA.reg;
    167a:	6823      	ldr	r3, [r4, #0]
		return ERR_BUSY;
	}

	/* SPI must be enabled to start synchronous transfer */
	if (!hri_sercomspi_get_CTRLA_ENABLE_bit(hw)) {
    167c:	079b      	lsls	r3, r3, #30
    167e:	d418      	bmi.n	16b2 <_spi_m_sync_trans+0x6e>
		return ERR_NOT_INITIALIZED;
    1680:	2014      	movs	r0, #20
    1682:	4240      	negs	r0, r0
    1684:	e044      	b.n	1710 <_spi_m_sync_trans+0xcc>
	ASSERT(dev && hw);
    1686:	2000      	movs	r0, #0
    1688:	e7ed      	b.n	1666 <_spi_m_sync_trans+0x22>
    168a:	2000      	movs	r0, #0
    168c:	e7eb      	b.n	1666 <_spi_m_sync_trans+0x22>
		return false;
    168e:	2200      	movs	r2, #0
    1690:	e026      	b.n	16e0 <_spi_m_sync_trans+0x9c>
			data |= (*ctrl->txbuf) << 8;
    1692:	7858      	ldrb	r0, [r3, #1]
    1694:	0200      	lsls	r0, r0, #8
    1696:	4301      	orrs	r1, r0
			ctrl->txbuf++;
    1698:	3302      	adds	r3, #2
    169a:	9303      	str	r3, [sp, #12]
	ctrl->txcnt++;
    169c:	3201      	adds	r2, #1
    169e:	9205      	str	r2, [sp, #20]
	hri_sercomspi_write_DATA_reg(hw, data);
    16a0:	b289      	uxth	r1, r1
	((Sercom *)hw)->SPI.DATA.reg = data;
    16a2:	8321      	strh	r1, [r4, #24]
			if (ctrl.rxcnt >= ctrl.txcnt) {
				_spi_tx_check(hw, iflag, &ctrl);
			}
		}

		if (ctrl.txcnt >= msg->size && ctrl.rxcnt >= msg->size) {
    16a4:	9805      	ldr	r0, [sp, #20]
    16a6:	68ab      	ldr	r3, [r5, #8]
    16a8:	4298      	cmp	r0, r3
    16aa:	d302      	bcc.n	16b2 <_spi_m_sync_trans+0x6e>
    16ac:	9a06      	ldr	r2, [sp, #24]
    16ae:	4293      	cmp	r3, r2
    16b0:	d929      	bls.n	1706 <_spi_m_sync_trans+0xc2>
	return ((Sercom *)hw)->SPI.INTFLAG.reg;
    16b2:	7ba3      	ldrb	r3, [r4, #14]
    16b4:	b2db      	uxtb	r3, r3
	if (!(iflag & SERCOM_SPI_INTFLAG_RXC)) {
    16b6:	075a      	lsls	r2, r3, #29
    16b8:	d5e9      	bpl.n	168e <_spi_m_sync_trans+0x4a>
	return ((Sercom *)hw)->SPI.DATA.reg;
    16ba:	8b22      	ldrh	r2, [r4, #24]
    16bc:	b292      	uxth	r2, r2
	if (ctrl->rxbuf) {
    16be:	9904      	ldr	r1, [sp, #16]
    16c0:	2900      	cmp	r1, #0
    16c2:	d008      	beq.n	16d6 <_spi_m_sync_trans+0x92>
		*ctrl->rxbuf++ = (uint8_t)data;
    16c4:	1c48      	adds	r0, r1, #1
    16c6:	9004      	str	r0, [sp, #16]
    16c8:	700a      	strb	r2, [r1, #0]
		if (ctrl->char_size > 1) {
    16ca:	2e01      	cmp	r6, #1
    16cc:	d903      	bls.n	16d6 <_spi_m_sync_trans+0x92>
			*ctrl->rxbuf++ = (uint8_t)(data >> 8);
    16ce:	1c88      	adds	r0, r1, #2
    16d0:	9004      	str	r0, [sp, #16]
    16d2:	0a12      	lsrs	r2, r2, #8
    16d4:	704a      	strb	r2, [r1, #1]
	ctrl->rxcnt++;
    16d6:	9a06      	ldr	r2, [sp, #24]
    16d8:	9201      	str	r2, [sp, #4]
    16da:	3201      	adds	r2, #1
    16dc:	9206      	str	r2, [sp, #24]
	return true;
    16de:	2201      	movs	r2, #1
		if (!_spi_rx_check(hw, iflag, &ctrl)) {
    16e0:	2a00      	cmp	r2, #0
    16e2:	d1df      	bne.n	16a4 <_spi_m_sync_trans+0x60>
			if (ctrl.rxcnt >= ctrl.txcnt) {
    16e4:	9906      	ldr	r1, [sp, #24]
    16e6:	9a05      	ldr	r2, [sp, #20]
    16e8:	4291      	cmp	r1, r2
    16ea:	d3db      	bcc.n	16a4 <_spi_m_sync_trans+0x60>
	if (!(SERCOM_SPI_INTFLAG_DRE & iflag)) {
    16ec:	07db      	lsls	r3, r3, #31
    16ee:	d5d9      	bpl.n	16a4 <_spi_m_sync_trans+0x60>
	if (ctrl->txbuf) {
    16f0:	9b03      	ldr	r3, [sp, #12]
    16f2:	2b00      	cmp	r3, #0
    16f4:	d005      	beq.n	1702 <_spi_m_sync_trans+0xbe>
		data = *ctrl->txbuf++;
    16f6:	1c59      	adds	r1, r3, #1
    16f8:	9103      	str	r1, [sp, #12]
    16fa:	7819      	ldrb	r1, [r3, #0]
		if (ctrl->char_size > 1) {
    16fc:	2e01      	cmp	r6, #1
    16fe:	d8c8      	bhi.n	1692 <_spi_m_sync_trans+0x4e>
    1700:	e7cc      	b.n	169c <_spi_m_sync_trans+0x58>
		data = SPI_DUMMY_CHAR;
    1702:	4909      	ldr	r1, [pc, #36]	; (1728 <_spi_m_sync_trans+0xe4>)
    1704:	e7ca      	b.n	169c <_spi_m_sync_trans+0x58>
	tmp = ((Sercom *)hw)->SPI.INTFLAG.reg;
    1706:	7ba3      	ldrb	r3, [r4, #14]
	while (!(hri_sercomspi_get_INTFLAG_reg(hw, SERCOM_SPI_INTFLAG_TXC | SERCOM_SPI_INTFLAG_DRE))) {
    1708:	079b      	lsls	r3, r3, #30
    170a:	d0fc      	beq.n	1706 <_spi_m_sync_trans+0xc2>
	((Sercom *)hw)->SPI.INTFLAG.reg = mask;
    170c:	2303      	movs	r3, #3
    170e:	73a3      	strb	r3, [r4, #14]
	}
	/* Wait until SPI bus idle */
	_spi_wait_bus_idle(hw);

	return rc;
}
    1710:	b008      	add	sp, #32
    1712:	bd70      	pop	{r4, r5, r6, pc}
		return ERR_BUSY;
    1714:	2004      	movs	r0, #4
    1716:	4240      	negs	r0, r0
    1718:	e7fa      	b.n	1710 <_spi_m_sync_trans+0xcc>
    171a:	46c0      	nop			; (mov r8, r8)
    171c:	00000a01 	.word	0x00000a01
    1720:	00004ab4 	.word	0x00004ab4
    1724:	000009e5 	.word	0x000009e5
    1728:	000001ff 	.word	0x000001ff

0000172c <_sysctrl_init_sources>:
}

static inline hri_sysctrl_osc8m_reg_t hri_sysctrl_read_OSC8M_CALIB_bf(const void *const hw)
{
	uint32_t tmp;
	tmp = ((Sysctrl *)hw)->OSC8M.reg;
    172c:	4b0f      	ldr	r3, [pc, #60]	; (176c <_sysctrl_init_sources+0x40>)
    172e:	6a19      	ldr	r1, [r3, #32]
	tmp = (tmp & SYSCTRL_OSC8M_CALIB_Msk) >> SYSCTRL_OSC8M_CALIB_Pos;
    1730:	0c09      	lsrs	r1, r1, #16
}

static inline hri_sysctrl_osc8m_reg_t hri_sysctrl_read_OSC8M_FRANGE_bf(const void *const hw)
{
	uint32_t tmp;
	tmp = ((Sysctrl *)hw)->OSC8M.reg;
    1732:	6a1a      	ldr	r2, [r3, #32]

#if CONF_OSC8M_CONFIG == 1
	calib = hri_sysctrl_read_OSC8M_CALIB_bf(hw);

	hri_sysctrl_write_OSC8M_reg(hw,
	                            SYSCTRL_OSC8M_FRANGE(hri_sysctrl_read_OSC8M_FRANGE_bf(hw)) |
    1734:	0f92      	lsrs	r2, r2, #30
    1736:	0792      	lsls	r2, r2, #30
#if CONF_OSC8M_OVERWRITE_CALIBRATION == 1
	                                SYSCTRL_OSC8M_CALIB(CONF_OSC8M_CALIB) |
#else
	                                SYSCTRL_OSC8M_CALIB(calib) |
    1738:	0409      	lsls	r1, r1, #16
    173a:	480d      	ldr	r0, [pc, #52]	; (1770 <_sysctrl_init_sources+0x44>)
    173c:	4001      	ands	r1, r0
	                            SYSCTRL_OSC8M_FRANGE(hri_sysctrl_read_OSC8M_FRANGE_bf(hw)) |
    173e:	430a      	orrs	r2, r1
	hri_sysctrl_write_OSC8M_reg(hw,
    1740:	490c      	ldr	r1, [pc, #48]	; (1774 <_sysctrl_init_sources+0x48>)
    1742:	430a      	orrs	r2, r1
}

static inline void hri_sysctrl_write_OSC8M_reg(const void *const hw, hri_sysctrl_osc8m_reg_t data)
{
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->OSC8M.reg = data;
    1744:	621a      	str	r2, [r3, #32]
	((Sysctrl *)hw)->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
    1746:	699a      	ldr	r2, [r3, #24]
    1748:	2102      	movs	r1, #2
    174a:	430a      	orrs	r2, r1
    174c:	619a      	str	r2, [r3, #24]
	tmp = ((Sysctrl *)hw)->OSCULP32K.reg;
    174e:	7f1a      	ldrb	r2, [r3, #28]
	tmp = (tmp & SYSCTRL_OSCULP32K_CALIB_Msk) >> SYSCTRL_OSCULP32K_CALIB_Pos;
    1750:	311d      	adds	r1, #29
    1752:	400a      	ands	r2, r1
	((Sysctrl *)hw)->OSCULP32K.reg = data;
    1754:	771a      	strb	r2, [r3, #28]
	return (((Sysctrl *)hw)->PCLKSR.reg & SYSCTRL_PCLKSR_OSC8MRDY) >> SYSCTRL_PCLKSR_OSC8MRDY_Pos;
    1756:	4b05      	ldr	r3, [pc, #20]	; (176c <_sysctrl_init_sources+0x40>)
    1758:	68db      	ldr	r3, [r3, #12]
#endif
#endif

#if CONF_OSC8M_CONFIG == 1
#if CONF_OSC8M_ENABLE == 1
	while (!hri_sysctrl_get_PCLKSR_OSC8MRDY_bit(hw))
    175a:	071b      	lsls	r3, r3, #28
    175c:	d5fb      	bpl.n	1756 <_sysctrl_init_sources+0x2a>
	((Sysctrl *)hw)->OSC8M.reg |= SYSCTRL_OSC8M_ONDEMAND;
    175e:	4a03      	ldr	r2, [pc, #12]	; (176c <_sysctrl_init_sources+0x40>)
    1760:	6a13      	ldr	r3, [r2, #32]
    1762:	2180      	movs	r1, #128	; 0x80
    1764:	430b      	orrs	r3, r1
    1766:	6213      	str	r3, [r2, #32]
	hri_sysctrl_set_OSC8M_ONDEMAND_bit(hw);
#endif
#endif

	(void)calib, (void)hw;
}
    1768:	4770      	bx	lr
    176a:	46c0      	nop			; (mov r8, r8)
    176c:	40000800 	.word	0x40000800
    1770:	0fff0000 	.word	0x0fff0000
    1774:	00000302 	.word	0x00000302

00001778 <_sysctrl_init_referenced_generators>:
}

static inline void hri_sysctrl_write_DFLLCTRL_reg(const void *const hw, hri_sysctrl_dfllctrl_reg_t data)
{
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->DFLLCTRL.reg = data;
    1778:	2202      	movs	r2, #2
    177a:	4b1b      	ldr	r3, [pc, #108]	; (17e8 <_sysctrl_init_referenced_generators+0x70>)
    177c:	849a      	strh	r2, [r3, #36]	; 0x24
	return (((Sysctrl *)hw)->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY) >> SYSCTRL_PCLKSR_DFLLRDY_Pos;
    177e:	4b1a      	ldr	r3, [pc, #104]	; (17e8 <_sysctrl_init_referenced_generators+0x70>)
    1780:	68db      	ldr	r3, [r3, #12]
	hri_gclk_write_CLKCTRL_reg(GCLK,
	                           GCLK_CLKCTRL_ID(0) | GCLK_CLKCTRL_GEN(CONF_DFLL_GCLK) | (1 << GCLK_CLKCTRL_CLKEN_Pos));
#endif

	hri_sysctrl_write_DFLLCTRL_reg(hw, SYSCTRL_DFLLCTRL_ENABLE);
	while (!hri_sysctrl_get_PCLKSR_DFLLRDY_bit(hw))
    1782:	06db      	lsls	r3, r3, #27
    1784:	d5fb      	bpl.n	177e <_sysctrl_init_referenced_generators+0x6>
}

static inline void hri_sysctrl_write_DFLLMUL_reg(const void *const hw, hri_sysctrl_dfllmul_reg_t data)
{
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->DFLLMUL.reg = data;
    1786:	4a19      	ldr	r2, [pc, #100]	; (17ec <_sysctrl_init_referenced_generators+0x74>)
    1788:	4b17      	ldr	r3, [pc, #92]	; (17e8 <_sysctrl_init_referenced_generators+0x70>)
    178a:	62da      	str	r2, [r3, #44]	; 0x2c
		;

	hri_sysctrl_write_DFLLMUL_reg(hw,
	                              SYSCTRL_DFLLMUL_CSTEP(CONF_DFLL_CSTEP) | SYSCTRL_DFLLMUL_FSTEP(CONF_DFLL_FSTEP)
	                                  | SYSCTRL_DFLLMUL_MUL(CONF_DFLL_MUL));
	hri_sysctrl_write_DFLLVAL_reg(hw, CONF_DFLLVAL);
    178c:	4b18      	ldr	r3, [pc, #96]	; (17f0 <_sysctrl_init_referenced_generators+0x78>)
    178e:	681b      	ldr	r3, [r3, #0]
    1790:	0e9b      	lsrs	r3, r3, #26
    1792:	2b3f      	cmp	r3, #63	; 0x3f
    1794:	d020      	beq.n	17d8 <_sysctrl_init_referenced_generators+0x60>
    1796:	029b      	lsls	r3, r3, #10
    1798:	2280      	movs	r2, #128	; 0x80
    179a:	0092      	lsls	r2, r2, #2
    179c:	4313      	orrs	r3, r2
	((Sysctrl *)hw)->DFLLVAL.reg = data;
    179e:	4a12      	ldr	r2, [pc, #72]	; (17e8 <_sysctrl_init_referenced_generators+0x70>)
    17a0:	6293      	str	r3, [r2, #40]	; 0x28
	((Sysctrl *)hw)->DFLLCTRL.reg = data;
    17a2:	2302      	movs	r3, #2
    17a4:	8493      	strh	r3, [r2, #36]	; 0x24
	tmp = ((Sysctrl *)hw)->DFLLCTRL.reg;
    17a6:	8c93      	ldrh	r3, [r2, #36]	; 0x24
	hri_sysctrl_write_DFLLCTRL_reg(hw, tmp);
#endif

#if CONF_DFLL_CONFIG == 1
#if CONF_DFLL_ENABLE == 1
	if (hri_sysctrl_get_DFLLCTRL_MODE_bit(hw)) {
    17a8:	075b      	lsls	r3, r3, #29
    17aa:	d518      	bpl.n	17de <_sysctrl_init_referenced_generators+0x66>
	tmp = ((Sysctrl *)hw)->PCLKSR.reg;
    17ac:	4b0e      	ldr	r3, [pc, #56]	; (17e8 <_sysctrl_init_referenced_generators+0x70>)
    17ae:	68da      	ldr	r2, [r3, #12]
	tmp &= mask;
    17b0:	23d0      	movs	r3, #208	; 0xd0
    17b2:	4013      	ands	r3, r2
		hri_sysctrl_pclksr_reg_t status_mask
		    = SYSCTRL_PCLKSR_DFLLRDY | SYSCTRL_PCLKSR_DFLLLCKF | SYSCTRL_PCLKSR_DFLLLCKC;

		while (hri_sysctrl_get_PCLKSR_reg(hw, status_mask) != status_mask)
    17b4:	2bd0      	cmp	r3, #208	; 0xd0
    17b6:	d1f9      	bne.n	17ac <_sysctrl_init_referenced_generators+0x34>
	((Sysctrl *)hw)->DFLLCTRL.reg |= SYSCTRL_DFLLCTRL_ONDEMAND;
    17b8:	4a0b      	ldr	r2, [pc, #44]	; (17e8 <_sysctrl_init_referenced_generators+0x70>)
    17ba:	8c93      	ldrh	r3, [r2, #36]	; 0x24
    17bc:	2180      	movs	r1, #128	; 0x80
    17be:	430b      	orrs	r3, r1
    17c0:	b29b      	uxth	r3, r3
    17c2:	8493      	strh	r3, [r2, #36]	; 0x24
	return (((Gclk *)hw)->STATUS.reg & GCLK_STATUS_SYNCBUSY) >> GCLK_STATUS_SYNCBUSY_Pos;
    17c4:	4b0b      	ldr	r3, [pc, #44]	; (17f4 <_sysctrl_init_referenced_generators+0x7c>)
    17c6:	785b      	ldrb	r3, [r3, #1]
	hri_sysctrl_set_DFLLCTRL_ONDEMAND_bit(hw);
#endif
#endif

#if CONF_DFLL_CONFIG == 1
	while (hri_gclk_get_STATUS_SYNCBUSY_bit(GCLK))
    17c8:	09db      	lsrs	r3, r3, #7
    17ca:	d1fb      	bne.n	17c4 <_sysctrl_init_referenced_generators+0x4c>
	((Sysctrl *)hw)->OSC32K.reg &= ~SYSCTRL_OSC32K_ENABLE;
    17cc:	4a06      	ldr	r2, [pc, #24]	; (17e8 <_sysctrl_init_referenced_generators+0x70>)
    17ce:	6993      	ldr	r3, [r2, #24]
    17d0:	2102      	movs	r1, #2
    17d2:	438b      	bics	r3, r1
    17d4:	6193      	str	r3, [r2, #24]
	/* Disable after all possible configurations needs sync written. */
	hri_sysctrl_clear_OSC32K_ENABLE_bit(hw);
#endif

	(void)hw;
}
    17d6:	4770      	bx	lr
	hri_sysctrl_write_DFLLVAL_reg(hw, CONF_DFLLVAL);
    17d8:	23fc      	movs	r3, #252	; 0xfc
    17da:	01db      	lsls	r3, r3, #7
    17dc:	e7df      	b.n	179e <_sysctrl_init_referenced_generators+0x26>
	return (((Sysctrl *)hw)->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY) >> SYSCTRL_PCLKSR_DFLLRDY_Pos;
    17de:	4b02      	ldr	r3, [pc, #8]	; (17e8 <_sysctrl_init_referenced_generators+0x70>)
    17e0:	68db      	ldr	r3, [r3, #12]
		while (!hri_sysctrl_get_PCLKSR_DFLLRDY_bit(hw))
    17e2:	06db      	lsls	r3, r3, #27
    17e4:	d5fb      	bpl.n	17de <_sysctrl_init_referenced_generators+0x66>
    17e6:	e7e7      	b.n	17b8 <_sysctrl_init_referenced_generators+0x40>
    17e8:	40000800 	.word	0x40000800
    17ec:	04010000 	.word	0x04010000
    17f0:	00806024 	.word	0x00806024
    17f4:	40000c00 	.word	0x40000c00

000017f8 <tc_pwm_interrupt_handler>:
 * \internal TC interrupt handler for PWM
 *
 * \param[in] instance TC instance number
 */
static void tc_pwm_interrupt_handler(struct _pwm_device *device)
{
    17f8:	b570      	push	{r4, r5, r6, lr}
    17fa:	0005      	movs	r5, r0
	void *const hw = device->hw;
    17fc:	6904      	ldr	r4, [r0, #16]
	((Tc *)hw)->COUNT16.INTFLAG.reg = TC_INTFLAG_MC1;
}

static inline bool hri_tc_get_interrupt_OVF_bit(const void *const hw)
{
	return (((Tc *)hw)->COUNT16.INTFLAG.reg & TC_INTFLAG_OVF) >> TC_INTFLAG_OVF_Pos;
    17fe:	7ba3      	ldrb	r3, [r4, #14]

	if (hri_tc_get_interrupt_OVF_bit(hw)) {
    1800:	07db      	lsls	r3, r3, #31
    1802:	d505      	bpl.n	1810 <tc_pwm_interrupt_handler+0x18>
}

static inline void hri_tc_clear_interrupt_OVF_bit(const void *const hw)
{
	((Tc *)hw)->COUNT16.INTFLAG.reg = TC_INTFLAG_OVF;
    1804:	2301      	movs	r3, #1
    1806:	73a3      	strb	r3, [r4, #14]
		hri_tc_clear_interrupt_OVF_bit(hw);
		if (NULL != device->callback.pwm_period_cb) {
    1808:	6803      	ldr	r3, [r0, #0]
    180a:	2b00      	cmp	r3, #0
    180c:	d000      	beq.n	1810 <tc_pwm_interrupt_handler+0x18>
			device->callback.pwm_period_cb(device);
    180e:	4798      	blx	r3
	((Tc *)hw)->COUNT16.INTENSET.reg = TC_INTENSET_ERR;
}

static inline bool hri_tc_get_INTEN_ERR_bit(const void *const hw)
{
	return (((Tc *)hw)->COUNT16.INTENSET.reg & TC_INTENSET_ERR) >> TC_INTENSET_ERR_Pos;
    1810:	7b63      	ldrb	r3, [r4, #13]
		}
	}
	if (hri_tc_get_INTEN_ERR_bit(hw)) {
    1812:	079b      	lsls	r3, r3, #30
    1814:	d506      	bpl.n	1824 <tc_pwm_interrupt_handler+0x2c>
	((Tc *)hw)->COUNT16.INTFLAG.reg = TC_INTFLAG_ERR;
    1816:	2302      	movs	r3, #2
    1818:	73a3      	strb	r3, [r4, #14]
		hri_tc_clear_interrupt_ERR_bit(hw);
		if (NULL != device->callback.pwm_error_cb) {
    181a:	686b      	ldr	r3, [r5, #4]
    181c:	2b00      	cmp	r3, #0
    181e:	d001      	beq.n	1824 <tc_pwm_interrupt_handler+0x2c>
			device->callback.pwm_error_cb(device);
    1820:	0028      	movs	r0, r5
    1822:	4798      	blx	r3
		}
	}
}
    1824:	bd70      	pop	{r4, r5, r6, pc}
	...

00001828 <tc_get_hardware_index>:
 * \param[in] hw The pointer to hardware instance
 */
static uint8_t tc_get_hardware_index(const void *const hw)
{
#ifndef _UNIT_TEST_
	return ((uint32_t)hw - TC_HW_BASE_ADDR) >> 10;
    1828:	4b02      	ldr	r3, [pc, #8]	; (1834 <tc_get_hardware_index+0xc>)
    182a:	469c      	mov	ip, r3
    182c:	4460      	add	r0, ip
    182e:	0a80      	lsrs	r0, r0, #10
    1830:	b2c0      	uxtb	r0, r0
#else
	return ((uint32_t)hw - TC_HW_BASE_ADDR) / sizeof(Tc);
#endif
}
    1832:	4770      	bx	lr
    1834:	bdffe000 	.word	0xbdffe000

00001838 <_tc_init_irq_param>:
/**
 * \brief Init irq param with the given tc hardware instance
 */
static void _tc_init_irq_param(const void *const hw, void *dev)
{
	if (hw == TC6) {
    1838:	4b06      	ldr	r3, [pc, #24]	; (1854 <_tc_init_irq_param+0x1c>)
    183a:	4298      	cmp	r0, r3
    183c:	d003      	beq.n	1846 <_tc_init_irq_param+0xe>
		_tc6_dev = (struct _pwm_device *)dev;
	}
	if (hw == TC7) {
    183e:	4b06      	ldr	r3, [pc, #24]	; (1858 <_tc_init_irq_param+0x20>)
    1840:	4298      	cmp	r0, r3
    1842:	d003      	beq.n	184c <_tc_init_irq_param+0x14>
		_tc7_dev = (struct _pwm_device *)dev;
	}
}
    1844:	4770      	bx	lr
		_tc6_dev = (struct _pwm_device *)dev;
    1846:	4b05      	ldr	r3, [pc, #20]	; (185c <_tc_init_irq_param+0x24>)
    1848:	6019      	str	r1, [r3, #0]
    184a:	e7f8      	b.n	183e <_tc_init_irq_param+0x6>
		_tc7_dev = (struct _pwm_device *)dev;
    184c:	4b03      	ldr	r3, [pc, #12]	; (185c <_tc_init_irq_param+0x24>)
    184e:	6059      	str	r1, [r3, #4]
}
    1850:	e7f8      	b.n	1844 <_tc_init_irq_param+0xc>
    1852:	46c0      	nop			; (mov r8, r8)
    1854:	42003800 	.word	0x42003800
    1858:	42003c00 	.word	0x42003c00
    185c:	2000012c 	.word	0x2000012c

00001860 <get_tc_index>:
{
    1860:	b510      	push	{r4, lr}
	uint8_t tc_offset = tc_get_hardware_index(hw) + TC_NUMBER_OFFSET;
    1862:	4b0d      	ldr	r3, [pc, #52]	; (1898 <get_tc_index+0x38>)
    1864:	4798      	blx	r3
	for (i = 0; i < ARRAY_SIZE(_tcs); i++) {
    1866:	2300      	movs	r3, #0
    1868:	2b01      	cmp	r3, #1
    186a:	d80b      	bhi.n	1884 <get_tc_index+0x24>
		if (_tcs[i].number == tc_offset) {
    186c:	009a      	lsls	r2, r3, #2
    186e:	18d2      	adds	r2, r2, r3
    1870:	0091      	lsls	r1, r2, #2
    1872:	4a0a      	ldr	r2, [pc, #40]	; (189c <get_tc_index+0x3c>)
    1874:	5c8a      	ldrb	r2, [r1, r2]
    1876:	4290      	cmp	r0, r2
    1878:	d002      	beq.n	1880 <get_tc_index+0x20>
	for (i = 0; i < ARRAY_SIZE(_tcs); i++) {
    187a:	3301      	adds	r3, #1
    187c:	b2db      	uxtb	r3, r3
    187e:	e7f3      	b.n	1868 <get_tc_index+0x8>
			return i;
    1880:	b258      	sxtb	r0, r3
    1882:	e007      	b.n	1894 <get_tc_index+0x34>
	ASSERT(false);
    1884:	2276      	movs	r2, #118	; 0x76
    1886:	32ff      	adds	r2, #255	; 0xff
    1888:	4905      	ldr	r1, [pc, #20]	; (18a0 <get_tc_index+0x40>)
    188a:	2000      	movs	r0, #0
    188c:	4b05      	ldr	r3, [pc, #20]	; (18a4 <get_tc_index+0x44>)
    188e:	4798      	blx	r3
	return -1;
    1890:	2001      	movs	r0, #1
    1892:	4240      	negs	r0, r0
}
    1894:	bd10      	pop	{r4, pc}
    1896:	46c0      	nop			; (mov r8, r8)
    1898:	00001829 	.word	0x00001829
    189c:	20000000 	.word	0x20000000
    18a0:	00004ad0 	.word	0x00004ad0
    18a4:	000009e5 	.word	0x000009e5

000018a8 <_pwm_init>:
{
    18a8:	b570      	push	{r4, r5, r6, lr}
    18aa:	0005      	movs	r5, r0
    18ac:	000c      	movs	r4, r1
	int8_t i   = get_tc_index(hw);
    18ae:	0008      	movs	r0, r1
    18b0:	4b35      	ldr	r3, [pc, #212]	; (1988 <_pwm_init+0xe0>)
    18b2:	4798      	blx	r3
	device->hw = hw;
    18b4:	612c      	str	r4, [r5, #16]
	while (((const Tc *)hw)->COUNT16.STATUS.bit.SYNCBUSY)
    18b6:	7be3      	ldrb	r3, [r4, #15]
    18b8:	09db      	lsrs	r3, r3, #7
    18ba:	d1fc      	bne.n	18b6 <_pwm_init+0xe>
}

static inline hri_tc_ctrla_reg_t hri_tc_get_CTRLA_reg(const void *const hw, hri_tc_ctrla_reg_t mask)
{
	uint16_t tmp;
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
    18bc:	8823      	ldrh	r3, [r4, #0]
	if (hri_tc_get_CTRLA_reg(hw, TC_CTRLA_ENABLE)) {
    18be:	079b      	lsls	r3, r3, #30
    18c0:	d504      	bpl.n	18cc <_pwm_init+0x24>
}

static inline void hri_tc_write_CTRLA_reg(const void *const hw, hri_tc_ctrla_reg_t data)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT16.CTRLA.reg = data;
    18c2:	2300      	movs	r3, #0
    18c4:	8023      	strh	r3, [r4, #0]
	while (((const Tc *)hw)->COUNT16.STATUS.bit.SYNCBUSY)
    18c6:	7be3      	ldrb	r3, [r4, #15]
    18c8:	09db      	lsrs	r3, r3, #7
    18ca:	d1fc      	bne.n	18c6 <_pwm_init+0x1e>
	((Tc *)hw)->COUNT16.CTRLA.reg = data;
    18cc:	2301      	movs	r3, #1
    18ce:	8023      	strh	r3, [r4, #0]
	while (((const Tc *)hw)->COUNT16.STATUS.bit.SYNCBUSY)
    18d0:	7be3      	ldrb	r3, [r4, #15]
    18d2:	09db      	lsrs	r3, r3, #7
    18d4:	d1fc      	bne.n	18d0 <_pwm_init+0x28>
	hri_tc_write_CTRLA_reg(hw, _tcs[i].ctrl_a);
    18d6:	0082      	lsls	r2, r0, #2
    18d8:	1812      	adds	r2, r2, r0
    18da:	0091      	lsls	r1, r2, #2
    18dc:	4b2b      	ldr	r3, [pc, #172]	; (198c <_pwm_init+0xe4>)
    18de:	185b      	adds	r3, r3, r1
    18e0:	885a      	ldrh	r2, [r3, #2]
	((Tc *)hw)->COUNT16.CTRLA.reg = data;
    18e2:	8022      	strh	r2, [r4, #0]
	hri_tc_write_DBGCTRL_reg(hw, _tcs[i].dbg_ctrl);
    18e4:	7919      	ldrb	r1, [r3, #4]
}

static inline void hri_tc_write_DBGCTRL_reg(const void *const hw, hri_tc_dbgctrl_reg_t data)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT16.DBGCTRL.reg = data;
    18e6:	7221      	strb	r1, [r4, #8]
	hri_tc_write_EVCTRL_reg(hw, _tcs[i].event_ctrl);
    18e8:	88db      	ldrh	r3, [r3, #6]
}

static inline void hri_tc_write_EVCTRL_reg(const void *const hw, hri_tc_evctrl_reg_t data)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT16.EVCTRL.reg = data;
    18ea:	8163      	strh	r3, [r4, #10]
    18ec:	230c      	movs	r3, #12
    18ee:	4013      	ands	r3, r2
	if ((_tcs[i].ctrl_a & TC_CTRLA_MODE_Msk) == TC_CTRLA_MODE_COUNT32) {
    18f0:	2b08      	cmp	r3, #8
    18f2:	d037      	beq.n	1964 <_pwm_init+0xbc>
	} else if ((_tcs[i].ctrl_a & TC_CTRLA_MODE_Msk) == TC_CTRLA_MODE_COUNT16) {
    18f4:	2b00      	cmp	r3, #0
    18f6:	d141      	bne.n	197c <_pwm_init+0xd4>
		hri_tccount16_write_CC_reg(hw, 0, (hri_tccount16_cc_reg_t)_tcs[i].cc0);
    18f8:	4a24      	ldr	r2, [pc, #144]	; (198c <_pwm_init+0xe4>)
    18fa:	0083      	lsls	r3, r0, #2
    18fc:	181e      	adds	r6, r3, r0
    18fe:	00b1      	lsls	r1, r6, #2
    1900:	000e      	movs	r6, r1
    1902:	1851      	adds	r1, r2, r1
    1904:	8989      	ldrh	r1, [r1, #12]
}

static inline void hri_tccount16_write_CC_reg(const void *const hw, uint8_t index, hri_tccount16_cc_reg_t data)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT16.CC[index].reg = data;
    1906:	8321      	strh	r1, [r4, #24]
		hri_tccount16_write_CC_reg(hw, 1, (hri_tccount16_cc_reg_t)_tcs[i].cc1);
    1908:	1992      	adds	r2, r2, r6
    190a:	8a13      	ldrh	r3, [r2, #16]
    190c:	8363      	strh	r3, [r4, #26]
	_tc_init_irq_param(hw, (void *)device);
    190e:	0029      	movs	r1, r5
    1910:	0020      	movs	r0, r4
    1912:	4b1f      	ldr	r3, [pc, #124]	; (1990 <_pwm_init+0xe8>)
    1914:	4798      	blx	r3
	NVIC_DisableIRQ((IRQn_Type)((uint8_t)TC_IRQ_BASE_INDEX + tc_get_hardware_index(hw)));
    1916:	0020      	movs	r0, r4
    1918:	4b1e      	ldr	r3, [pc, #120]	; (1994 <_pwm_init+0xec>)
    191a:	4798      	blx	r3
    191c:	300d      	adds	r0, #13
    191e:	b2c0      	uxtb	r0, r0
    1920:	b243      	sxtb	r3, r0
  if ((int32_t)(IRQn) >= 0)
    1922:	2b00      	cmp	r3, #0
    1924:	db0a      	blt.n	193c <_pwm_init+0x94>
    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    1926:	211f      	movs	r1, #31
    1928:	4001      	ands	r1, r0
    192a:	2201      	movs	r2, #1
    192c:	408a      	lsls	r2, r1
    192e:	2180      	movs	r1, #128	; 0x80
    1930:	4c19      	ldr	r4, [pc, #100]	; (1998 <_pwm_init+0xf0>)
    1932:	5062      	str	r2, [r4, r1]
  __ASM volatile ("dsb 0xF":::"memory");
    1934:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    1938:	f3bf 8f6f 	isb	sy
  if ((int32_t)(IRQn) >= 0)
    193c:	2b00      	cmp	r3, #0
    193e:	db07      	blt.n	1950 <_pwm_init+0xa8>
    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    1940:	211f      	movs	r1, #31
    1942:	4001      	ands	r1, r0
    1944:	2201      	movs	r2, #1
    1946:	408a      	lsls	r2, r1
    1948:	21c0      	movs	r1, #192	; 0xc0
    194a:	0049      	lsls	r1, r1, #1
    194c:	4c12      	ldr	r4, [pc, #72]	; (1998 <_pwm_init+0xf0>)
    194e:	5062      	str	r2, [r4, r1]
  if ((int32_t)(IRQn) >= 0)
    1950:	2b00      	cmp	r3, #0
    1952:	db16      	blt.n	1982 <_pwm_init+0xda>
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    1954:	231f      	movs	r3, #31
    1956:	4018      	ands	r0, r3
    1958:	3b1e      	subs	r3, #30
    195a:	4083      	lsls	r3, r0
    195c:	4a0e      	ldr	r2, [pc, #56]	; (1998 <_pwm_init+0xf0>)
    195e:	6013      	str	r3, [r2, #0]
	return ERR_NONE;
    1960:	2000      	movs	r0, #0
}
    1962:	bd70      	pop	{r4, r5, r6, pc}
		hri_tccount32_write_CC_reg(hw, 0, _tcs[i].cc0);
    1964:	4a09      	ldr	r2, [pc, #36]	; (198c <_pwm_init+0xe4>)
    1966:	0083      	lsls	r3, r0, #2
    1968:	181e      	adds	r6, r3, r0
    196a:	00b1      	lsls	r1, r6, #2
    196c:	000e      	movs	r6, r1
    196e:	1851      	adds	r1, r2, r1
    1970:	68c9      	ldr	r1, [r1, #12]
}

static inline void hri_tccount32_write_CC_reg(const void *const hw, uint8_t index, hri_tccount32_cc_reg_t data)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT32.CC[index].reg = data;
    1972:	61a1      	str	r1, [r4, #24]
		hri_tccount32_write_CC_reg(hw, 1, _tcs[i].cc1);
    1974:	1992      	adds	r2, r2, r6
    1976:	6913      	ldr	r3, [r2, #16]
    1978:	61e3      	str	r3, [r4, #28]
    197a:	e7c8      	b.n	190e <_pwm_init+0x66>
		return ERR_INVALID_DATA;
    197c:	2001      	movs	r0, #1
    197e:	4240      	negs	r0, r0
    1980:	e7ef      	b.n	1962 <_pwm_init+0xba>
	return ERR_NONE;
    1982:	2000      	movs	r0, #0
    1984:	e7ed      	b.n	1962 <_pwm_init+0xba>
    1986:	46c0      	nop			; (mov r8, r8)
    1988:	00001861 	.word	0x00001861
    198c:	20000000 	.word	0x20000000
    1990:	00001839 	.word	0x00001839
    1994:	00001829 	.word	0x00001829
    1998:	e000e100 	.word	0xe000e100

0000199c <_pwm_enable>:
	hri_tc_set_CTRLA_ENABLE_bit(device->hw);
    199c:	6902      	ldr	r2, [r0, #16]
	((Tc *)hw)->COUNT16.CTRLA.reg |= TC_CTRLA_ENABLE;
    199e:	8813      	ldrh	r3, [r2, #0]
    19a0:	2102      	movs	r1, #2
    19a2:	430b      	orrs	r3, r1
    19a4:	b29b      	uxth	r3, r3
    19a6:	8013      	strh	r3, [r2, #0]
}
    19a8:	4770      	bx	lr
	...

000019ac <_pwm_set_param>:
{
    19ac:	b570      	push	{r4, r5, r6, lr}
    19ae:	0004      	movs	r4, r0
    19b0:	000e      	movs	r6, r1
    19b2:	0015      	movs	r5, r2
	int8_t      i  = get_tc_index(device->hw);
    19b4:	6900      	ldr	r0, [r0, #16]
    19b6:	4b11      	ldr	r3, [pc, #68]	; (19fc <_pwm_set_param+0x50>)
    19b8:	4798      	blx	r3
	void *const hw = device->hw;
    19ba:	6924      	ldr	r4, [r4, #16]
	_tcs[i].cc0    = period;
    19bc:	0082      	lsls	r2, r0, #2
    19be:	1812      	adds	r2, r2, r0
    19c0:	0091      	lsls	r1, r2, #2
    19c2:	4b0f      	ldr	r3, [pc, #60]	; (1a00 <_pwm_set_param+0x54>)
    19c4:	185b      	adds	r3, r3, r1
    19c6:	60de      	str	r6, [r3, #12]
	_tcs[i].cc1    = duty_cycle;
    19c8:	611d      	str	r5, [r3, #16]
	if ((_tcs[i].ctrl_a & TC_CTRLA_MODE_Msk) == TC_CTRLA_MODE_COUNT32) {
    19ca:	885a      	ldrh	r2, [r3, #2]
    19cc:	230c      	movs	r3, #12
    19ce:	4013      	ands	r3, r2
    19d0:	2b08      	cmp	r3, #8
    19d2:	d00b      	beq.n	19ec <_pwm_set_param+0x40>
		hri_tccount16_write_CC_reg(hw, 0, _tcs[i].cc0);
    19d4:	4a0a      	ldr	r2, [pc, #40]	; (1a00 <_pwm_set_param+0x54>)
    19d6:	0083      	lsls	r3, r0, #2
    19d8:	181d      	adds	r5, r3, r0
    19da:	00a9      	lsls	r1, r5, #2
    19dc:	000d      	movs	r5, r1
    19de:	1851      	adds	r1, r2, r1
    19e0:	8989      	ldrh	r1, [r1, #12]
	((Tc *)hw)->COUNT16.CC[index].reg = data;
    19e2:	8321      	strh	r1, [r4, #24]
		hri_tccount16_write_CC_reg(hw, 1, _tcs[i].cc1);
    19e4:	1952      	adds	r2, r2, r5
    19e6:	8a13      	ldrh	r3, [r2, #16]
    19e8:	8363      	strh	r3, [r4, #26]
}
    19ea:	bd70      	pop	{r4, r5, r6, pc}
		hri_tccount32_write_CC_reg(hw, 0, _tcs[i].cc0);
    19ec:	4a04      	ldr	r2, [pc, #16]	; (1a00 <_pwm_set_param+0x54>)
    19ee:	000d      	movs	r5, r1
	((Tc *)hw)->COUNT32.CC[index].reg = data;
    19f0:	61a6      	str	r6, [r4, #24]
		hri_tccount32_write_CC_reg(hw, 1, _tcs[i].cc1);
    19f2:	1952      	adds	r2, r2, r5
    19f4:	6913      	ldr	r3, [r2, #16]
    19f6:	61e3      	str	r3, [r4, #28]
    19f8:	e7f7      	b.n	19ea <_pwm_set_param+0x3e>
    19fa:	46c0      	nop			; (mov r8, r8)
    19fc:	00001861 	.word	0x00001861
    1a00:	20000000 	.word	0x20000000

00001a04 <_pwm_is_enabled>:
	return hri_tc_get_CTRLA_ENABLE_bit(device->hw);
    1a04:	6903      	ldr	r3, [r0, #16]
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
    1a06:	881b      	ldrh	r3, [r3, #0]
	tmp = (tmp & TC_CTRLA_ENABLE) >> TC_CTRLA_ENABLE_Pos;
    1a08:	085b      	lsrs	r3, r3, #1
	return (bool)tmp;
    1a0a:	2001      	movs	r0, #1
    1a0c:	4018      	ands	r0, r3
}
    1a0e:	4770      	bx	lr

00001a10 <_tc_get_pwm>:
}
    1a10:	2000      	movs	r0, #0
    1a12:	4770      	bx	lr

00001a14 <TC6_Handler>:
{
    1a14:	b510      	push	{r4, lr}
	tc_pwm_interrupt_handler(_tc6_dev);
    1a16:	4b02      	ldr	r3, [pc, #8]	; (1a20 <TC6_Handler+0xc>)
    1a18:	6818      	ldr	r0, [r3, #0]
    1a1a:	4b02      	ldr	r3, [pc, #8]	; (1a24 <TC6_Handler+0x10>)
    1a1c:	4798      	blx	r3
}
    1a1e:	bd10      	pop	{r4, pc}
    1a20:	2000012c 	.word	0x2000012c
    1a24:	000017f9 	.word	0x000017f9

00001a28 <TC7_Handler>:
{
    1a28:	b510      	push	{r4, lr}
	tc_pwm_interrupt_handler(_tc7_dev);
    1a2a:	4b02      	ldr	r3, [pc, #8]	; (1a34 <TC7_Handler+0xc>)
    1a2c:	6858      	ldr	r0, [r3, #4]
    1a2e:	4b02      	ldr	r3, [pc, #8]	; (1a38 <TC7_Handler+0x10>)
    1a30:	4798      	blx	r3
}
    1a32:	bd10      	pop	{r4, pc}
    1a34:	2000012c 	.word	0x2000012c
    1a38:	000017f9 	.word	0x000017f9

00001a3c <ETH_Handler>:
	EXT_IRG_init();
}

static void ETH_Handler(void){

}
    1a3c:	4770      	bx	lr

00001a3e <TIMER_0_task2_cb>:
	((Port *)hw)->Group[submodule_index].OUTTGL.reg = mask;
    1a3e:	2280      	movs	r2, #128	; 0x80
    1a40:	0412      	lsls	r2, r2, #16
    1a42:	23c0      	movs	r3, #192	; 0xc0
    1a44:	05db      	lsls	r3, r3, #23
    1a46:	61da      	str	r2, [r3, #28]
}

static void TIMER_0_task2_cb(const struct timer_task *const timer_task)
{
	gpio_toggle_pin_level(GLD);
}
    1a48:	4770      	bx	lr
	...

00001a4c <TIMER_IRQ_init>:



static void TIMER_IRQ_init(void)
{
    1a4c:	b510      	push	{r4, lr}
			peripheral = (uint32_t)_pm_get_ahb_index(module);
			PM->AHBMASK.reg |= 1 << peripheral;
		}
		break;
	case PM_BUS_APBA:
		PM->APBAMASK.reg |= 1 << peripheral;
    1a4e:	4a0f      	ldr	r2, [pc, #60]	; (1a8c <TIMER_IRQ_init+0x40>)
    1a50:	6993      	ldr	r3, [r2, #24]
    1a52:	2120      	movs	r1, #32
    1a54:	430b      	orrs	r3, r1
    1a56:	6193      	str	r3, [r2, #24]
	((Gclk *)hw)->CLKCTRL.reg = data;
    1a58:	4a0d      	ldr	r2, [pc, #52]	; (1a90 <TIMER_IRQ_init+0x44>)
    1a5a:	4b0e      	ldr	r3, [pc, #56]	; (1a94 <TIMER_IRQ_init+0x48>)
    1a5c:	805a      	strh	r2, [r3, #2]
	_pm_enable_bus_clock(PM_BUS_APBA, RTC);
	_gclk_enable_channel(RTC_GCLK_ID, CONF_GCLK_RTC_SRC);
	timer_init(&TIMER_IRQ, RTC, _rtc_get_timer());
    1a5e:	4b0e      	ldr	r3, [pc, #56]	; (1a98 <TIMER_IRQ_init+0x4c>)
    1a60:	4798      	blx	r3
    1a62:	0002      	movs	r2, r0
    1a64:	4c0d      	ldr	r4, [pc, #52]	; (1a9c <TIMER_IRQ_init+0x50>)
    1a66:	490e      	ldr	r1, [pc, #56]	; (1aa0 <TIMER_IRQ_init+0x54>)
    1a68:	0020      	movs	r0, r4
    1a6a:	4b0e      	ldr	r3, [pc, #56]	; (1aa4 <TIMER_IRQ_init+0x58>)
    1a6c:	4798      	blx	r3
	
	//TIMER_task1.interval = 100;
	//TIMER_task1.cb       = TIMER_0_task1_cb;
	//TIMER_task1.mode     = TIMER_TASK_REPEAT;
	
	TIMER_task2.interval = 32768/2;
    1a6e:	490e      	ldr	r1, [pc, #56]	; (1aa8 <TIMER_IRQ_init+0x5c>)
    1a70:	2380      	movs	r3, #128	; 0x80
    1a72:	01db      	lsls	r3, r3, #7
    1a74:	608b      	str	r3, [r1, #8]
	TIMER_task2.cb       = TIMER_0_task2_cb;
    1a76:	4b0d      	ldr	r3, [pc, #52]	; (1aac <TIMER_IRQ_init+0x60>)
    1a78:	60cb      	str	r3, [r1, #12]
	TIMER_task2.mode     = TIMER_TASK_REPEAT;
    1a7a:	2301      	movs	r3, #1
    1a7c:	740b      	strb	r3, [r1, #16]

	//timer_add_task(&TIMER_IRQ, &TIMER_task1);
	timer_add_task(&TIMER_IRQ, &TIMER_task2);
    1a7e:	0020      	movs	r0, r4
    1a80:	4b0b      	ldr	r3, [pc, #44]	; (1ab0 <TIMER_IRQ_init+0x64>)
    1a82:	4798      	blx	r3
	timer_start(&TIMER_IRQ);
    1a84:	0020      	movs	r0, r4
    1a86:	4b0b      	ldr	r3, [pc, #44]	; (1ab4 <TIMER_IRQ_init+0x68>)
    1a88:	4798      	blx	r3
    1a8a:	bd10      	pop	{r4, pc}
    1a8c:	40000400 	.word	0x40000400
    1a90:	00004302 	.word	0x00004302
    1a94:	40000c00 	.word	0x40000c00
    1a98:	00000dc1 	.word	0x00000dc1
    1a9c:	200002f8 	.word	0x200002f8
    1aa0:	40001400 	.word	0x40001400
    1aa4:	0000072d 	.word	0x0000072d
    1aa8:	20000134 	.word	0x20000134
    1aac:	00001a3f 	.word	0x00001a3f
    1ab0:	000007ad 	.word	0x000007ad
    1ab4:	00000771 	.word	0x00000771

00001ab8 <gpio_init>:
void gpio_init(void){
    1ab8:	b5f0      	push	{r4, r5, r6, r7, lr}
    1aba:	46de      	mov	lr, fp
    1abc:	4657      	mov	r7, sl
    1abe:	464e      	mov	r6, r9
    1ac0:	4645      	mov	r5, r8
    1ac2:	b5e0      	push	{r5, r6, r7, lr}
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    1ac4:	22c0      	movs	r2, #192	; 0xc0
    1ac6:	05d2      	lsls	r2, r2, #23
    1ac8:	2380      	movs	r3, #128	; 0x80
    1aca:	469c      	mov	ip, r3
    1acc:	6193      	str	r3, [r2, #24]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    1ace:	6093      	str	r3, [r2, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    1ad0:	4b7d      	ldr	r3, [pc, #500]	; (1cc8 <gpio_init+0x210>)
    1ad2:	497e      	ldr	r1, [pc, #504]	; (1ccc <gpio_init+0x214>)
    1ad4:	6299      	str	r1, [r3, #40]	; 0x28
    1ad6:	25c0      	movs	r5, #192	; 0xc0
    1ad8:	062d      	lsls	r5, r5, #24
    1ada:	629d      	str	r5, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    1adc:	2447      	movs	r4, #71	; 0x47
    1ade:	5d18      	ldrb	r0, [r3, r4]
	tmp &= ~PORT_PINCFG_PMUXEN;
    1ae0:	2101      	movs	r1, #1
    1ae2:	4388      	bics	r0, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    1ae4:	5518      	strb	r0, [r3, r4]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    1ae6:	2080      	movs	r0, #128	; 0x80
    1ae8:	0040      	lsls	r0, r0, #1
    1aea:	6150      	str	r0, [r2, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    1aec:	6090      	str	r0, [r2, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    1aee:	4878      	ldr	r0, [pc, #480]	; (1cd0 <gpio_init+0x218>)
    1af0:	6298      	str	r0, [r3, #40]	; 0x28
    1af2:	629d      	str	r5, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    1af4:	3401      	adds	r4, #1
    1af6:	5d18      	ldrb	r0, [r3, r4]
	tmp &= ~PORT_PINCFG_PMUXEN;
    1af8:	4388      	bics	r0, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    1afa:	5518      	strb	r0, [r3, r4]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    1afc:	2780      	movs	r7, #128	; 0x80
    1afe:	00bf      	lsls	r7, r7, #2
    1b00:	6157      	str	r7, [r2, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    1b02:	6097      	str	r7, [r2, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    1b04:	4873      	ldr	r0, [pc, #460]	; (1cd4 <gpio_init+0x21c>)
    1b06:	4682      	mov	sl, r0
    1b08:	6298      	str	r0, [r3, #40]	; 0x28
    1b0a:	629d      	str	r5, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    1b0c:	3401      	adds	r4, #1
    1b0e:	5d18      	ldrb	r0, [r3, r4]
	tmp &= ~PORT_PINCFG_PMUXEN;
    1b10:	4388      	bics	r0, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    1b12:	5518      	strb	r0, [r3, r4]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    1b14:	2080      	movs	r0, #128	; 0x80
    1b16:	00c0      	lsls	r0, r0, #3
    1b18:	4680      	mov	r8, r0
    1b1a:	6150      	str	r0, [r2, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    1b1c:	6090      	str	r0, [r2, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    1b1e:	486e      	ldr	r0, [pc, #440]	; (1cd8 <gpio_init+0x220>)
    1b20:	6298      	str	r0, [r3, #40]	; 0x28
    1b22:	629d      	str	r5, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    1b24:	3401      	adds	r4, #1
    1b26:	5d18      	ldrb	r0, [r3, r4]
	tmp &= ~PORT_PINCFG_PMUXEN;
    1b28:	4388      	bics	r0, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    1b2a:	5518      	strb	r0, [r3, r4]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    1b2c:	2080      	movs	r0, #128	; 0x80
    1b2e:	0100      	lsls	r0, r0, #4
    1b30:	6050      	str	r0, [r2, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    1b32:	486a      	ldr	r0, [pc, #424]	; (1cdc <gpio_init+0x224>)
    1b34:	6298      	str	r0, [r3, #40]	; 0x28
    1b36:	486a      	ldr	r0, [pc, #424]	; (1ce0 <gpio_init+0x228>)
    1b38:	6298      	str	r0, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
    1b3a:	264b      	movs	r6, #75	; 0x4b
    1b3c:	5d98      	ldrb	r0, [r3, r6]
    1b3e:	4681      	mov	r9, r0
    1b40:	2004      	movs	r0, #4
    1b42:	464c      	mov	r4, r9
    1b44:	4384      	bics	r4, r0
    1b46:	559c      	strb	r4, [r3, r6]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    1b48:	5d9c      	ldrb	r4, [r3, r6]
	tmp &= ~PORT_PINCFG_PMUXEN;
    1b4a:	438c      	bics	r4, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    1b4c:	559c      	strb	r4, [r3, r6]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    1b4e:	2680      	movs	r6, #128	; 0x80
    1b50:	0236      	lsls	r6, r6, #8
    1b52:	6196      	str	r6, [r2, #24]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    1b54:	6096      	str	r6, [r2, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    1b56:	4e63      	ldr	r6, [pc, #396]	; (1ce4 <gpio_init+0x22c>)
    1b58:	629e      	str	r6, [r3, #40]	; 0x28
    1b5a:	629d      	str	r5, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    1b5c:	244f      	movs	r4, #79	; 0x4f
    1b5e:	5d1e      	ldrb	r6, [r3, r4]
	tmp &= ~PORT_PINCFG_PMUXEN;
    1b60:	438e      	bics	r6, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    1b62:	551e      	strb	r6, [r3, r4]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    1b64:	2680      	movs	r6, #128	; 0x80
    1b66:	0436      	lsls	r6, r6, #16
    1b68:	6156      	str	r6, [r2, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    1b6a:	6096      	str	r6, [r2, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    1b6c:	2480      	movs	r4, #128	; 0x80
    1b6e:	05e4      	lsls	r4, r4, #23
    1b70:	629c      	str	r4, [r3, #40]	; 0x28
    1b72:	4c5d      	ldr	r4, [pc, #372]	; (1ce8 <gpio_init+0x230>)
    1b74:	629c      	str	r4, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    1b76:	2457      	movs	r4, #87	; 0x57
    1b78:	46a3      	mov	fp, r4
    1b7a:	5d1c      	ldrb	r4, [r3, r4]
	tmp &= ~PORT_PINCFG_PMUXEN;
    1b7c:	438c      	bics	r4, r1
    1b7e:	46a1      	mov	r9, r4
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    1b80:	465c      	mov	r4, fp
    1b82:	464e      	mov	r6, r9
    1b84:	551e      	strb	r6, [r3, r4]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    1b86:	3441      	adds	r4, #65	; 0x41
    1b88:	5117      	str	r7, [r2, r4]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    1b8a:	3c10      	subs	r4, #16
    1b8c:	5117      	str	r7, [r2, r4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    1b8e:	3f59      	subs	r7, #89	; 0x59
    1b90:	3fff      	subs	r7, #255	; 0xff
    1b92:	4654      	mov	r4, sl
    1b94:	51dc      	str	r4, [r3, r7]
    1b96:	51dd      	str	r5, [r3, r7]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    1b98:	24c9      	movs	r4, #201	; 0xc9
    1b9a:	5d1d      	ldrb	r5, [r3, r4]
	tmp &= ~PORT_PINCFG_PMUXEN;
    1b9c:	438d      	bics	r5, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    1b9e:	551d      	strb	r5, [r3, r4]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    1ba0:	2584      	movs	r5, #132	; 0x84
    1ba2:	4644      	mov	r4, r8
    1ba4:	5154      	str	r4, [r2, r5]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    1ba6:	4c51      	ldr	r4, [pc, #324]	; (1cec <gpio_init+0x234>)
    1ba8:	51dc      	str	r4, [r3, r7]
    1baa:	4c4d      	ldr	r4, [pc, #308]	; (1ce0 <gpio_init+0x228>)
    1bac:	51dc      	str	r4, [r3, r7]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
    1bae:	24ca      	movs	r4, #202	; 0xca
    1bb0:	46a0      	mov	r8, r4
    1bb2:	5d1c      	ldrb	r4, [r3, r4]
    1bb4:	4384      	bics	r4, r0
    1bb6:	46a1      	mov	r9, r4
    1bb8:	4644      	mov	r4, r8
    1bba:	464e      	mov	r6, r9
    1bbc:	551e      	strb	r6, [r3, r4]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    1bbe:	5d1c      	ldrb	r4, [r3, r4]
	tmp &= ~PORT_PINCFG_PMUXEN;
    1bc0:	438c      	bics	r4, r1
    1bc2:	46a1      	mov	r9, r4
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    1bc4:	4644      	mov	r4, r8
    1bc6:	464e      	mov	r6, r9
    1bc8:	551e      	strb	r6, [r3, r4]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    1bca:	2480      	movs	r4, #128	; 0x80
    1bcc:	0124      	lsls	r4, r4, #4
    1bce:	5154      	str	r4, [r2, r5]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    1bd0:	4c42      	ldr	r4, [pc, #264]	; (1cdc <gpio_init+0x224>)
    1bd2:	51dc      	str	r4, [r3, r7]
    1bd4:	4c42      	ldr	r4, [pc, #264]	; (1ce0 <gpio_init+0x228>)
    1bd6:	51dc      	str	r4, [r3, r7]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
    1bd8:	24cb      	movs	r4, #203	; 0xcb
    1bda:	46a0      	mov	r8, r4
    1bdc:	5d1c      	ldrb	r4, [r3, r4]
    1bde:	4384      	bics	r4, r0
    1be0:	46a1      	mov	r9, r4
    1be2:	4644      	mov	r4, r8
    1be4:	464e      	mov	r6, r9
    1be6:	551e      	strb	r6, [r3, r4]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    1be8:	5d1c      	ldrb	r4, [r3, r4]
	tmp &= ~PORT_PINCFG_PMUXEN;
    1bea:	438c      	bics	r4, r1
    1bec:	46a1      	mov	r9, r4
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    1bee:	4644      	mov	r4, r8
    1bf0:	464e      	mov	r6, r9
    1bf2:	551e      	strb	r6, [r3, r4]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    1bf4:	2480      	movs	r4, #128	; 0x80
    1bf6:	03e4      	lsls	r4, r4, #15
    1bf8:	6154      	str	r4, [r2, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    1bfa:	6094      	str	r4, [r2, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    1bfc:	2480      	movs	r4, #128	; 0x80
    1bfe:	05e4      	lsls	r4, r4, #23
    1c00:	629c      	str	r4, [r3, #40]	; 0x28
    1c02:	4c3b      	ldr	r4, [pc, #236]	; (1cf0 <gpio_init+0x238>)
    1c04:	629c      	str	r4, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    1c06:	2456      	movs	r4, #86	; 0x56
    1c08:	46a1      	mov	r9, r4
    1c0a:	5d1c      	ldrb	r4, [r3, r4]
	tmp &= ~PORT_PINCFG_PMUXEN;
    1c0c:	438c      	bics	r4, r1
    1c0e:	46a0      	mov	r8, r4
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    1c10:	464c      	mov	r4, r9
    1c12:	4646      	mov	r6, r8
    1c14:	551e      	strb	r6, [r3, r4]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    1c16:	2480      	movs	r4, #128	; 0x80
    1c18:	0464      	lsls	r4, r4, #17
    1c1a:	6154      	str	r4, [r2, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    1c1c:	6094      	str	r4, [r2, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    1c1e:	2480      	movs	r4, #128	; 0x80
    1c20:	05e4      	lsls	r4, r4, #23
    1c22:	629c      	str	r4, [r3, #40]	; 0x28
    1c24:	4c33      	ldr	r4, [pc, #204]	; (1cf4 <gpio_init+0x23c>)
    1c26:	629c      	str	r4, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    1c28:	2458      	movs	r4, #88	; 0x58
    1c2a:	46a1      	mov	r9, r4
    1c2c:	5d1c      	ldrb	r4, [r3, r4]
	tmp &= ~PORT_PINCFG_PMUXEN;
    1c2e:	438c      	bics	r4, r1
    1c30:	46a0      	mov	r8, r4
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    1c32:	464c      	mov	r4, r9
    1c34:	4646      	mov	r6, r8
    1c36:	551e      	strb	r6, [r3, r4]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    1c38:	2480      	movs	r4, #128	; 0x80
    1c3a:	04a4      	lsls	r4, r4, #18
    1c3c:	6154      	str	r4, [r2, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    1c3e:	6094      	str	r4, [r2, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    1c40:	2480      	movs	r4, #128	; 0x80
    1c42:	05e4      	lsls	r4, r4, #23
    1c44:	629c      	str	r4, [r3, #40]	; 0x28
    1c46:	4e2c      	ldr	r6, [pc, #176]	; (1cf8 <gpio_init+0x240>)
    1c48:	629e      	str	r6, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    1c4a:	2459      	movs	r4, #89	; 0x59
    1c4c:	5d1e      	ldrb	r6, [r3, r4]
	tmp &= ~PORT_PINCFG_PMUXEN;
    1c4e:	438e      	bics	r6, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    1c50:	551e      	strb	r6, [r3, r4]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    1c52:	2640      	movs	r6, #64	; 0x40
    1c54:	5156      	str	r6, [r2, r5]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    1c56:	4e29      	ldr	r6, [pc, #164]	; (1cfc <gpio_init+0x244>)
    1c58:	51de      	str	r6, [r3, r7]
    1c5a:	4c21      	ldr	r4, [pc, #132]	; (1ce0 <gpio_init+0x228>)
    1c5c:	51dc      	str	r4, [r3, r7]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
    1c5e:	26c6      	movs	r6, #198	; 0xc6
    1c60:	5d9c      	ldrb	r4, [r3, r6]
    1c62:	4384      	bics	r4, r0
    1c64:	559c      	strb	r4, [r3, r6]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    1c66:	5d9c      	ldrb	r4, [r3, r6]
	tmp &= ~PORT_PINCFG_PMUXEN;
    1c68:	438c      	bics	r4, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    1c6a:	559c      	strb	r4, [r3, r6]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    1c6c:	3ea6      	subs	r6, #166	; 0xa6
    1c6e:	5156      	str	r6, [r2, r5]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    1c70:	4e23      	ldr	r6, [pc, #140]	; (1d00 <gpio_init+0x248>)
    1c72:	51de      	str	r6, [r3, r7]
    1c74:	4c1a      	ldr	r4, [pc, #104]	; (1ce0 <gpio_init+0x228>)
    1c76:	51dc      	str	r4, [r3, r7]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
    1c78:	26c5      	movs	r6, #197	; 0xc5
    1c7a:	5d9c      	ldrb	r4, [r3, r6]
    1c7c:	4384      	bics	r4, r0
    1c7e:	559c      	strb	r4, [r3, r6]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    1c80:	5d9c      	ldrb	r4, [r3, r6]
	tmp &= ~PORT_PINCFG_PMUXEN;
    1c82:	438c      	bics	r4, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    1c84:	559c      	strb	r4, [r3, r6]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    1c86:	3eb5      	subs	r6, #181	; 0xb5
    1c88:	5156      	str	r6, [r2, r5]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    1c8a:	4e1e      	ldr	r6, [pc, #120]	; (1d04 <gpio_init+0x24c>)
    1c8c:	51de      	str	r6, [r3, r7]
    1c8e:	4c14      	ldr	r4, [pc, #80]	; (1ce0 <gpio_init+0x228>)
    1c90:	51dc      	str	r4, [r3, r7]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
    1c92:	26c4      	movs	r6, #196	; 0xc4
    1c94:	5d9c      	ldrb	r4, [r3, r6]
    1c96:	4384      	bics	r4, r0
    1c98:	559c      	strb	r4, [r3, r6]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    1c9a:	5d9c      	ldrb	r4, [r3, r6]
	tmp &= ~PORT_PINCFG_PMUXEN;
    1c9c:	438c      	bics	r4, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    1c9e:	559c      	strb	r4, [r3, r6]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    1ca0:	4664      	mov	r4, ip
    1ca2:	5154      	str	r4, [r2, r5]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    1ca4:	4a18      	ldr	r2, [pc, #96]	; (1d08 <gpio_init+0x250>)
    1ca6:	51da      	str	r2, [r3, r7]
    1ca8:	4a0d      	ldr	r2, [pc, #52]	; (1ce0 <gpio_init+0x228>)
    1caa:	51da      	str	r2, [r3, r7]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
    1cac:	22c7      	movs	r2, #199	; 0xc7
    1cae:	5c9c      	ldrb	r4, [r3, r2]
    1cb0:	4384      	bics	r4, r0
    1cb2:	549c      	strb	r4, [r3, r2]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    1cb4:	5c98      	ldrb	r0, [r3, r2]
	tmp &= ~PORT_PINCFG_PMUXEN;
    1cb6:	4388      	bics	r0, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    1cb8:	5498      	strb	r0, [r3, r2]
}
    1cba:	bc3c      	pop	{r2, r3, r4, r5}
    1cbc:	4690      	mov	r8, r2
    1cbe:	4699      	mov	r9, r3
    1cc0:	46a2      	mov	sl, r4
    1cc2:	46ab      	mov	fp, r5
    1cc4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1cc6:	46c0      	nop			; (mov r8, r8)
    1cc8:	41004400 	.word	0x41004400
    1ccc:	40000080 	.word	0x40000080
    1cd0:	40000100 	.word	0x40000100
    1cd4:	40000200 	.word	0x40000200
    1cd8:	40000400 	.word	0x40000400
    1cdc:	40020800 	.word	0x40020800
    1ce0:	c0020000 	.word	0xc0020000
    1ce4:	40008000 	.word	0x40008000
    1ce8:	c0000080 	.word	0xc0000080
    1cec:	40020400 	.word	0x40020400
    1cf0:	c0000040 	.word	0xc0000040
    1cf4:	c0000100 	.word	0xc0000100
    1cf8:	c0000200 	.word	0xc0000200
    1cfc:	40020040 	.word	0x40020040
    1d00:	40020020 	.word	0x40020020
    1d04:	40020010 	.word	0x40020010
    1d08:	40020080 	.word	0x40020080

00001d0c <EXT_IRG_init>:
void EXT_IRG_init(void){
    1d0c:	b510      	push	{r4, lr}
    1d0e:	4a11      	ldr	r2, [pc, #68]	; (1d54 <EXT_IRG_init+0x48>)
    1d10:	4b11      	ldr	r3, [pc, #68]	; (1d58 <EXT_IRG_init+0x4c>)
    1d12:	805a      	strh	r2, [r3, #2]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    1d14:	2180      	movs	r1, #128	; 0x80
    1d16:	0049      	lsls	r1, r1, #1
    1d18:	2384      	movs	r3, #132	; 0x84
    1d1a:	22c0      	movs	r2, #192	; 0xc0
    1d1c:	05d2      	lsls	r2, r2, #23
    1d1e:	50d1      	str	r1, [r2, r3]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    1d20:	4b0e      	ldr	r3, [pc, #56]	; (1d5c <EXT_IRG_init+0x50>)
    1d22:	22a8      	movs	r2, #168	; 0xa8
    1d24:	490e      	ldr	r1, [pc, #56]	; (1d60 <EXT_IRG_init+0x54>)
    1d26:	5099      	str	r1, [r3, r2]
    1d28:	490e      	ldr	r1, [pc, #56]	; (1d64 <EXT_IRG_init+0x58>)
    1d2a:	5099      	str	r1, [r3, r2]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
    1d2c:	21c8      	movs	r1, #200	; 0xc8
    1d2e:	5c5a      	ldrb	r2, [r3, r1]
    1d30:	2004      	movs	r0, #4
    1d32:	4382      	bics	r2, r0
    1d34:	545a      	strb	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    1d36:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
    1d38:	3803      	subs	r0, #3
    1d3a:	4382      	bics	r2, r0
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    1d3c:	4302      	orrs	r2, r0
    1d3e:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    1d40:	545a      	strb	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    1d42:	3914      	subs	r1, #20
    1d44:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
    1d46:	200f      	movs	r0, #15
    1d48:	4382      	bics	r2, r0
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    1d4a:	545a      	strb	r2, [r3, r1]
	ext_irq_init();
    1d4c:	4b06      	ldr	r3, [pc, #24]	; (1d68 <EXT_IRG_init+0x5c>)
    1d4e:	4798      	blx	r3
}
    1d50:	bd10      	pop	{r4, pc}
    1d52:	46c0      	nop			; (mov r8, r8)
    1d54:	00004103 	.word	0x00004103
    1d58:	40000c00 	.word	0x40000c00
    1d5c:	41004400 	.word	0x41004400
    1d60:	40020100 	.word	0x40020100
    1d64:	c0020000 	.word	0xc0020000
    1d68:	000001fd 	.word	0x000001fd

00001d6c <ETH_SPI_init>:
void ETH_SPI_init(void){
    1d6c:	b5f0      	push	{r4, r5, r6, r7, lr}
    1d6e:	46de      	mov	lr, fp
    1d70:	4657      	mov	r7, sl
    1d72:	4646      	mov	r6, r8
    1d74:	b5c0      	push	{r6, r7, lr}
			peripheral = (uint32_t)_pm_get_apbb_index(module);
			PM->APBBMASK.reg |= 1 << peripheral;
		}
		break;
	case PM_BUS_APBC:
		PM->APBCMASK.reg |= 1 << peripheral;
    1d76:	4a33      	ldr	r2, [pc, #204]	; (1e44 <ETH_SPI_init+0xd8>)
    1d78:	6a13      	ldr	r3, [r2, #32]
    1d7a:	2104      	movs	r1, #4
    1d7c:	4688      	mov	r8, r1
    1d7e:	430b      	orrs	r3, r1
    1d80:	6213      	str	r3, [r2, #32]
    1d82:	4a31      	ldr	r2, [pc, #196]	; (1e48 <ETH_SPI_init+0xdc>)
    1d84:	4b31      	ldr	r3, [pc, #196]	; (1e4c <ETH_SPI_init+0xe0>)
    1d86:	805a      	strh	r2, [r3, #2]
	spi_m_sync_init(&ETH_SPI, SERCOM0);
    1d88:	4931      	ldr	r1, [pc, #196]	; (1e50 <ETH_SPI_init+0xe4>)
    1d8a:	4832      	ldr	r0, [pc, #200]	; (1e54 <ETH_SPI_init+0xe8>)
    1d8c:	4e32      	ldr	r6, [pc, #200]	; (1e58 <ETH_SPI_init+0xec>)
    1d8e:	47b0      	blx	r6
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    1d90:	22c0      	movs	r2, #192	; 0xc0
    1d92:	05d2      	lsls	r2, r2, #23
    1d94:	2310      	movs	r3, #16
    1d96:	6153      	str	r3, [r2, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    1d98:	6093      	str	r3, [r2, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    1d9a:	4b30      	ldr	r3, [pc, #192]	; (1e5c <ETH_SPI_init+0xf0>)
    1d9c:	4930      	ldr	r1, [pc, #192]	; (1e60 <ETH_SPI_init+0xf4>)
    1d9e:	6299      	str	r1, [r3, #40]	; 0x28
    1da0:	21c0      	movs	r1, #192	; 0xc0
    1da2:	0609      	lsls	r1, r1, #24
    1da4:	468b      	mov	fp, r1
    1da6:	6299      	str	r1, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    1da8:	2044      	movs	r0, #68	; 0x44
    1daa:	5c19      	ldrb	r1, [r3, r0]
	tmp &= ~PORT_PINCFG_PMUXEN;
    1dac:	2401      	movs	r4, #1
    1dae:	43a1      	bics	r1, r4
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    1db0:	4321      	orrs	r1, r4
    1db2:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    1db4:	5419      	strb	r1, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    1db6:	2132      	movs	r1, #50	; 0x32
    1db8:	5c58      	ldrb	r0, [r3, r1]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
    1dba:	250f      	movs	r5, #15
    1dbc:	46ac      	mov	ip, r5
    1dbe:	43a8      	bics	r0, r5
	tmp |= PORT_PMUX_PMUXE(data);
    1dc0:	2703      	movs	r7, #3
    1dc2:	4338      	orrs	r0, r7
    1dc4:	b2c0      	uxtb	r0, r0
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    1dc6:	5458      	strb	r0, [r3, r1]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    1dc8:	2020      	movs	r0, #32
    1dca:	6150      	str	r0, [r2, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    1dcc:	6090      	str	r0, [r2, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    1dce:	4825      	ldr	r0, [pc, #148]	; (1e64 <ETH_SPI_init+0xf8>)
    1dd0:	6298      	str	r0, [r3, #40]	; 0x28
    1dd2:	4658      	mov	r0, fp
    1dd4:	6298      	str	r0, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    1dd6:	2045      	movs	r0, #69	; 0x45
    1dd8:	4683      	mov	fp, r0
    1dda:	5c18      	ldrb	r0, [r3, r0]
	tmp &= ~PORT_PINCFG_PMUXEN;
    1ddc:	43a0      	bics	r0, r4
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    1dde:	4320      	orrs	r0, r4
    1de0:	b2c0      	uxtb	r0, r0
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    1de2:	465d      	mov	r5, fp
    1de4:	5558      	strb	r0, [r3, r5]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    1de6:	5c58      	ldrb	r0, [r3, r1]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
    1de8:	3d36      	subs	r5, #54	; 0x36
    1dea:	4028      	ands	r0, r5
	tmp |= PORT_PMUX_PMUXO(data);
    1dec:	2530      	movs	r5, #48	; 0x30
    1dee:	46ab      	mov	fp, r5
    1df0:	465d      	mov	r5, fp
    1df2:	4328      	orrs	r0, r5
    1df4:	b2c0      	uxtb	r0, r0
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    1df6:	5458      	strb	r0, [r3, r1]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    1df8:	310e      	adds	r1, #14
    1dfa:	6051      	str	r1, [r2, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    1dfc:	4a1a      	ldr	r2, [pc, #104]	; (1e68 <ETH_SPI_init+0xfc>)
    1dfe:	629a      	str	r2, [r3, #40]	; 0x28
    1e00:	4a1a      	ldr	r2, [pc, #104]	; (1e6c <ETH_SPI_init+0x100>)
    1e02:	629a      	str	r2, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
    1e04:	2246      	movs	r2, #70	; 0x46
    1e06:	5c99      	ldrb	r1, [r3, r2]
    1e08:	4640      	mov	r0, r8
    1e0a:	4381      	bics	r1, r0
    1e0c:	5499      	strb	r1, [r3, r2]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    1e0e:	5c99      	ldrb	r1, [r3, r2]
	tmp &= ~PORT_PINCFG_PMUXEN;
    1e10:	43a1      	bics	r1, r4
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    1e12:	4321      	orrs	r1, r4
    1e14:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    1e16:	5499      	strb	r1, [r3, r2]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    1e18:	2133      	movs	r1, #51	; 0x33
    1e1a:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
    1e1c:	4660      	mov	r0, ip
    1e1e:	4382      	bics	r2, r0
	tmp |= PORT_PMUX_PMUXE(data);
    1e20:	433a      	orrs	r2, r7
    1e22:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    1e24:	545a      	strb	r2, [r3, r1]
	spi_m_sync_init(&ETH_SPI, SERCOM0);
    1e26:	490a      	ldr	r1, [pc, #40]	; (1e50 <ETH_SPI_init+0xe4>)
    1e28:	480a      	ldr	r0, [pc, #40]	; (1e54 <ETH_SPI_init+0xe8>)
    1e2a:	47b0      	blx	r6
	spi_m_sync_get_io_descriptor(&ETH_SPI, &eth_spi);
    1e2c:	4910      	ldr	r1, [pc, #64]	; (1e70 <ETH_SPI_init+0x104>)
    1e2e:	4809      	ldr	r0, [pc, #36]	; (1e54 <ETH_SPI_init+0xe8>)
    1e30:	4b10      	ldr	r3, [pc, #64]	; (1e74 <ETH_SPI_init+0x108>)
    1e32:	4798      	blx	r3
	spi_m_sync_enable(&ETH_SPI);
    1e34:	4807      	ldr	r0, [pc, #28]	; (1e54 <ETH_SPI_init+0xe8>)
    1e36:	4b10      	ldr	r3, [pc, #64]	; (1e78 <ETH_SPI_init+0x10c>)
    1e38:	4798      	blx	r3
}
    1e3a:	bc1c      	pop	{r2, r3, r4}
    1e3c:	4690      	mov	r8, r2
    1e3e:	469a      	mov	sl, r3
    1e40:	46a3      	mov	fp, r4
    1e42:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1e44:	40000400 	.word	0x40000400
    1e48:	0000400d 	.word	0x0000400d
    1e4c:	40000c00 	.word	0x40000c00
    1e50:	42000800 	.word	0x42000800
    1e54:	200002cc 	.word	0x200002cc
    1e58:	00000501 	.word	0x00000501
    1e5c:	41004400 	.word	0x41004400
    1e60:	40000010 	.word	0x40000010
    1e64:	40000020 	.word	0x40000020
    1e68:	40020040 	.word	0x40020040
    1e6c:	c0020000 	.word	0xc0020000
    1e70:	200002ac 	.word	0x200002ac
    1e74:	00000641 	.word	0x00000641
    1e78:	00000559 	.word	0x00000559

00001e7c <ETH_SPI_Select>:
/**
 * \brief Set output level on port with mask
 */
static inline void _gpio_set_level(const enum gpio_port port, const uint32_t mask, const bool level)
{
	if (level) {
    1e7c:	2800      	cmp	r0, #0
    1e7e:	d104      	bne.n	1e8a <ETH_SPI_Select+0xe>
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    1e80:	2280      	movs	r2, #128	; 0x80
    1e82:	23c0      	movs	r3, #192	; 0xc0
    1e84:	05db      	lsls	r3, r3, #23
    1e86:	615a      	str	r2, [r3, #20]
}
    1e88:	4770      	bx	lr
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    1e8a:	2280      	movs	r2, #128	; 0x80
    1e8c:	23c0      	movs	r3, #192	; 0xc0
    1e8e:	05db      	lsls	r3, r3, #23
    1e90:	619a      	str	r2, [r3, #24]
    1e92:	e7f9      	b.n	1e88 <ETH_SPI_Select+0xc>

00001e94 <W5500_Select>:
void W5500_Select(void){
    1e94:	b510      	push	{r4, lr}
	ETH_SPI_Select(false);
    1e96:	2000      	movs	r0, #0
    1e98:	4b01      	ldr	r3, [pc, #4]	; (1ea0 <W5500_Select+0xc>)
    1e9a:	4798      	blx	r3
}
    1e9c:	bd10      	pop	{r4, pc}
    1e9e:	46c0      	nop			; (mov r8, r8)
    1ea0:	00001e7d 	.word	0x00001e7d

00001ea4 <W5500_Unselect>:
void W5500_Unselect(void){
    1ea4:	b510      	push	{r4, lr}
	ETH_SPI_Select(true);
    1ea6:	2001      	movs	r0, #1
    1ea8:	4b01      	ldr	r3, [pc, #4]	; (1eb0 <W5500_Unselect+0xc>)
    1eaa:	4798      	blx	r3
}
    1eac:	bd10      	pop	{r4, pc}
    1eae:	46c0      	nop			; (mov r8, r8)
    1eb0:	00001e7d 	.word	0x00001e7d

00001eb4 <W5500_ReadBuff>:
void W5500_ReadBuff(uint8_t* buff, uint16_t len){
    1eb4:	b510      	push	{r4, lr}
    1eb6:	0003      	movs	r3, r0
    1eb8:	000a      	movs	r2, r1
	io_read(eth_spi,buff,len);
    1eba:	4903      	ldr	r1, [pc, #12]	; (1ec8 <W5500_ReadBuff+0x14>)
    1ebc:	6808      	ldr	r0, [r1, #0]
    1ebe:	0019      	movs	r1, r3
    1ec0:	4b02      	ldr	r3, [pc, #8]	; (1ecc <W5500_ReadBuff+0x18>)
    1ec2:	4798      	blx	r3
}
    1ec4:	bd10      	pop	{r4, pc}
    1ec6:	46c0      	nop			; (mov r8, r8)
    1ec8:	200002ac 	.word	0x200002ac
    1ecc:	000003fd 	.word	0x000003fd

00001ed0 <W5500_WriteBuff>:
void W5500_WriteBuff(uint8_t* buff, uint16_t len){
    1ed0:	b510      	push	{r4, lr}
    1ed2:	0003      	movs	r3, r0
    1ed4:	000a      	movs	r2, r1
	io_write(eth_spi,buff,len);
    1ed6:	4903      	ldr	r1, [pc, #12]	; (1ee4 <W5500_WriteBuff+0x14>)
    1ed8:	6808      	ldr	r0, [r1, #0]
    1eda:	0019      	movs	r1, r3
    1edc:	4b02      	ldr	r3, [pc, #8]	; (1ee8 <W5500_WriteBuff+0x18>)
    1ede:	4798      	blx	r3
}
    1ee0:	bd10      	pop	{r4, pc}
    1ee2:	46c0      	nop			; (mov r8, r8)
    1ee4:	200002ac 	.word	0x200002ac
    1ee8:	000003c5 	.word	0x000003c5

00001eec <W5500_ReadByte>:
uint8_t W5500_ReadByte(void){
    1eec:	b510      	push	{r4, lr}
    1eee:	b082      	sub	sp, #8
	uint8_t data_byte = 0;
    1ef0:	466b      	mov	r3, sp
    1ef2:	1ddc      	adds	r4, r3, #7
    1ef4:	2300      	movs	r3, #0
    1ef6:	7023      	strb	r3, [r4, #0]
	io_read(eth_spi,&data_byte,1);
    1ef8:	4b04      	ldr	r3, [pc, #16]	; (1f0c <W5500_ReadByte+0x20>)
    1efa:	6818      	ldr	r0, [r3, #0]
    1efc:	2201      	movs	r2, #1
    1efe:	0021      	movs	r1, r4
    1f00:	4b03      	ldr	r3, [pc, #12]	; (1f10 <W5500_ReadByte+0x24>)
    1f02:	4798      	blx	r3
	return data_byte;
    1f04:	7820      	ldrb	r0, [r4, #0]
}
    1f06:	b002      	add	sp, #8
    1f08:	bd10      	pop	{r4, pc}
    1f0a:	46c0      	nop			; (mov r8, r8)
    1f0c:	200002ac 	.word	0x200002ac
    1f10:	000003fd 	.word	0x000003fd

00001f14 <W5500_Write_byte>:
void W5500_Write_byte(uint8_t byte){
    1f14:	b500      	push	{lr}
    1f16:	b083      	sub	sp, #12
    1f18:	466b      	mov	r3, sp
    1f1a:	1dd9      	adds	r1, r3, #7
    1f1c:	7008      	strb	r0, [r1, #0]
	io_write(eth_spi, &byte, 1);
    1f1e:	4b03      	ldr	r3, [pc, #12]	; (1f2c <W5500_Write_byte+0x18>)
    1f20:	6818      	ldr	r0, [r3, #0]
    1f22:	2201      	movs	r2, #1
    1f24:	4b02      	ldr	r3, [pc, #8]	; (1f30 <W5500_Write_byte+0x1c>)
    1f26:	4798      	blx	r3
}
    1f28:	b003      	add	sp, #12
    1f2a:	bd00      	pop	{pc}
    1f2c:	200002ac 	.word	0x200002ac
    1f30:	000003c5 	.word	0x000003c5

00001f34 <EXT_SPI_init>:
void EXT_SPI_init(void){
    1f34:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1f36:	46d6      	mov	lr, sl
    1f38:	464f      	mov	r7, r9
    1f3a:	b580      	push	{r7, lr}
    1f3c:	4a33      	ldr	r2, [pc, #204]	; (200c <STACK_SIZE+0xc>)
    1f3e:	6a13      	ldr	r3, [r2, #32]
    1f40:	2120      	movs	r1, #32
    1f42:	430b      	orrs	r3, r1
    1f44:	6213      	str	r3, [r2, #32]
    1f46:	4a32      	ldr	r2, [pc, #200]	; (2010 <STACK_SIZE+0x10>)
    1f48:	4b32      	ldr	r3, [pc, #200]	; (2014 <STACK_SIZE+0x14>)
    1f4a:	805a      	strh	r2, [r3, #2]
	spi_m_sync_init(&EXT_SPI, SERCOM3);
    1f4c:	4932      	ldr	r1, [pc, #200]	; (2018 <STACK_SIZE+0x18>)
    1f4e:	4833      	ldr	r0, [pc, #204]	; (201c <STACK_SIZE+0x1c>)
    1f50:	4e33      	ldr	r6, [pc, #204]	; (2020 <STACK_SIZE+0x20>)
    1f52:	47b0      	blx	r6
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    1f54:	22c0      	movs	r2, #192	; 0xc0
    1f56:	05d2      	lsls	r2, r2, #23
    1f58:	2380      	movs	r3, #128	; 0x80
    1f5a:	025b      	lsls	r3, r3, #9
    1f5c:	6153      	str	r3, [r2, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    1f5e:	6093      	str	r3, [r2, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    1f60:	4b30      	ldr	r3, [pc, #192]	; (2024 <STACK_SIZE+0x24>)
    1f62:	2180      	movs	r1, #128	; 0x80
    1f64:	05c9      	lsls	r1, r1, #23
    1f66:	468a      	mov	sl, r1
    1f68:	6299      	str	r1, [r3, #40]	; 0x28
    1f6a:	492f      	ldr	r1, [pc, #188]	; (2028 <STACK_SIZE+0x28>)
    1f6c:	6299      	str	r1, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    1f6e:	2050      	movs	r0, #80	; 0x50
    1f70:	5c19      	ldrb	r1, [r3, r0]
	tmp &= ~PORT_PINCFG_PMUXEN;
    1f72:	2401      	movs	r4, #1
    1f74:	43a1      	bics	r1, r4
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    1f76:	4321      	orrs	r1, r4
    1f78:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    1f7a:	5419      	strb	r1, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    1f7c:	2138      	movs	r1, #56	; 0x38
    1f7e:	5c58      	ldrb	r0, [r3, r1]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
    1f80:	250f      	movs	r5, #15
    1f82:	46ac      	mov	ip, r5
    1f84:	43a8      	bics	r0, r5
	tmp |= PORT_PMUX_PMUXE(data);
    1f86:	2703      	movs	r7, #3
    1f88:	4338      	orrs	r0, r7
    1f8a:	b2c0      	uxtb	r0, r0
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    1f8c:	5458      	strb	r0, [r3, r1]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    1f8e:	2080      	movs	r0, #128	; 0x80
    1f90:	0280      	lsls	r0, r0, #10
    1f92:	6150      	str	r0, [r2, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    1f94:	6090      	str	r0, [r2, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    1f96:	4650      	mov	r0, sl
    1f98:	6298      	str	r0, [r3, #40]	; 0x28
    1f9a:	4824      	ldr	r0, [pc, #144]	; (202c <STACK_SIZE+0x2c>)
    1f9c:	6298      	str	r0, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    1f9e:	2051      	movs	r0, #81	; 0x51
    1fa0:	4682      	mov	sl, r0
    1fa2:	5c18      	ldrb	r0, [r3, r0]
	tmp &= ~PORT_PINCFG_PMUXEN;
    1fa4:	43a0      	bics	r0, r4
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    1fa6:	4320      	orrs	r0, r4
    1fa8:	b2c0      	uxtb	r0, r0
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    1faa:	4655      	mov	r5, sl
    1fac:	5558      	strb	r0, [r3, r5]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    1fae:	5c58      	ldrb	r0, [r3, r1]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
    1fb0:	3d42      	subs	r5, #66	; 0x42
    1fb2:	4028      	ands	r0, r5
	tmp |= PORT_PMUX_PMUXO(data);
    1fb4:	2530      	movs	r5, #48	; 0x30
    1fb6:	46aa      	mov	sl, r5
    1fb8:	4655      	mov	r5, sl
    1fba:	4328      	orrs	r0, r5
    1fbc:	b2c0      	uxtb	r0, r0
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    1fbe:	5458      	strb	r0, [r3, r1]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    1fc0:	2180      	movs	r1, #128	; 0x80
    1fc2:	02c9      	lsls	r1, r1, #11
    1fc4:	6051      	str	r1, [r2, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    1fc6:	4a1a      	ldr	r2, [pc, #104]	; (2030 <STACK_SIZE+0x30>)
    1fc8:	629a      	str	r2, [r3, #40]	; 0x28
    1fca:	4a1a      	ldr	r2, [pc, #104]	; (2034 <STACK_SIZE+0x34>)
    1fcc:	629a      	str	r2, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
    1fce:	2252      	movs	r2, #82	; 0x52
    1fd0:	5c99      	ldrb	r1, [r3, r2]
    1fd2:	2004      	movs	r0, #4
    1fd4:	4381      	bics	r1, r0
    1fd6:	5499      	strb	r1, [r3, r2]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    1fd8:	5c99      	ldrb	r1, [r3, r2]
	tmp &= ~PORT_PINCFG_PMUXEN;
    1fda:	43a1      	bics	r1, r4
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    1fdc:	4321      	orrs	r1, r4
    1fde:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    1fe0:	5499      	strb	r1, [r3, r2]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    1fe2:	2139      	movs	r1, #57	; 0x39
    1fe4:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
    1fe6:	4660      	mov	r0, ip
    1fe8:	4382      	bics	r2, r0
	tmp |= PORT_PMUX_PMUXE(data);
    1fea:	433a      	orrs	r2, r7
    1fec:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    1fee:	545a      	strb	r2, [r3, r1]
	spi_m_sync_init(&EXT_SPI, SERCOM3);
    1ff0:	4909      	ldr	r1, [pc, #36]	; (2018 <STACK_SIZE+0x18>)
    1ff2:	480a      	ldr	r0, [pc, #40]	; (201c <STACK_SIZE+0x1c>)
    1ff4:	47b0      	blx	r6
	spi_m_sync_get_io_descriptor(&EXT_SPI, &ext_spi);
    1ff6:	4910      	ldr	r1, [pc, #64]	; (2038 <STACK_SIZE+0x38>)
    1ff8:	4808      	ldr	r0, [pc, #32]	; (201c <STACK_SIZE+0x1c>)
    1ffa:	4b10      	ldr	r3, [pc, #64]	; (203c <STACK_SIZE+0x3c>)
    1ffc:	4798      	blx	r3
	spi_m_sync_enable(&EXT_SPI);
    1ffe:	4807      	ldr	r0, [pc, #28]	; (201c <STACK_SIZE+0x1c>)
    2000:	4b0f      	ldr	r3, [pc, #60]	; (2040 <STACK_SIZE+0x40>)
    2002:	4798      	blx	r3
}
    2004:	bc0c      	pop	{r2, r3}
    2006:	4691      	mov	r9, r2
    2008:	469a      	mov	sl, r3
    200a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    200c:	40000400 	.word	0x40000400
    2010:	00004010 	.word	0x00004010
    2014:	40000c00 	.word	0x40000c00
    2018:	42001400 	.word	0x42001400
    201c:	200002b4 	.word	0x200002b4
    2020:	00000501 	.word	0x00000501
    2024:	41004400 	.word	0x41004400
    2028:	c0000001 	.word	0xc0000001
    202c:	c0000002 	.word	0xc0000002
    2030:	40020000 	.word	0x40020000
    2034:	c0020004 	.word	0xc0020004
    2038:	200002b0 	.word	0x200002b0
    203c:	00000641 	.word	0x00000641
    2040:	00000559 	.word	0x00000559

00002044 <EXT_I2C_init>:
void EXT_I2C_init(void){
    2044:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2046:	4a1e      	ldr	r2, [pc, #120]	; (20c0 <EXT_I2C_init+0x7c>)
    2048:	6a13      	ldr	r3, [r2, #32]
    204a:	2110      	movs	r1, #16
    204c:	430b      	orrs	r3, r1
    204e:	6213      	str	r3, [r2, #32]
    2050:	4b1c      	ldr	r3, [pc, #112]	; (20c4 <EXT_I2C_init+0x80>)
    2052:	4a1d      	ldr	r2, [pc, #116]	; (20c8 <EXT_I2C_init+0x84>)
    2054:	805a      	strh	r2, [r3, #2]
    2056:	4a1d      	ldr	r2, [pc, #116]	; (20cc <EXT_I2C_init+0x88>)
    2058:	805a      	strh	r2, [r3, #2]
	i2c_m_sync_init(&EXT_I2C, SERCOM2);
    205a:	4c1d      	ldr	r4, [pc, #116]	; (20d0 <EXT_I2C_init+0x8c>)
    205c:	491d      	ldr	r1, [pc, #116]	; (20d4 <EXT_I2C_init+0x90>)
    205e:	0020      	movs	r0, r4
    2060:	4b1d      	ldr	r3, [pc, #116]	; (20d8 <EXT_I2C_init+0x94>)
    2062:	4798      	blx	r3
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
    2064:	4b1d      	ldr	r3, [pc, #116]	; (20dc <EXT_I2C_init+0x98>)
    2066:	204c      	movs	r0, #76	; 0x4c
    2068:	5c19      	ldrb	r1, [r3, r0]
    206a:	2204      	movs	r2, #4
    206c:	4391      	bics	r1, r2
    206e:	5419      	strb	r1, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    2070:	5c19      	ldrb	r1, [r3, r0]
	tmp &= ~PORT_PINCFG_PMUXEN;
    2072:	2601      	movs	r6, #1
    2074:	43b1      	bics	r1, r6
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    2076:	2501      	movs	r5, #1
    2078:	4329      	orrs	r1, r5
    207a:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    207c:	5419      	strb	r1, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    207e:	3816      	subs	r0, #22
    2080:	5c19      	ldrb	r1, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
    2082:	270f      	movs	r7, #15
    2084:	43b9      	bics	r1, r7
	tmp |= PORT_PMUX_PMUXE(data);
    2086:	2702      	movs	r7, #2
    2088:	4339      	orrs	r1, r7
    208a:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    208c:	5419      	strb	r1, [r3, r0]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
    208e:	214d      	movs	r1, #77	; 0x4d
    2090:	5c5f      	ldrb	r7, [r3, r1]
    2092:	4397      	bics	r7, r2
    2094:	545f      	strb	r7, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    2096:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
    2098:	43b2      	bics	r2, r6
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    209a:	432a      	orrs	r2, r5
    209c:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    209e:	545a      	strb	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    20a0:	5c1a      	ldrb	r2, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
    20a2:	393e      	subs	r1, #62	; 0x3e
    20a4:	400a      	ands	r2, r1
	tmp |= PORT_PMUX_PMUXO(data);
    20a6:	2120      	movs	r1, #32
    20a8:	430a      	orrs	r2, r1
    20aa:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    20ac:	541a      	strb	r2, [r3, r0]
	i2c_m_sync_get_io_descriptor(&EXT_I2C, &ext_i2c);
    20ae:	490c      	ldr	r1, [pc, #48]	; (20e0 <EXT_I2C_init+0x9c>)
    20b0:	0020      	movs	r0, r4
    20b2:	4b0c      	ldr	r3, [pc, #48]	; (20e4 <EXT_I2C_init+0xa0>)
    20b4:	4798      	blx	r3
	i2c_m_sync_enable(&EXT_I2C);
    20b6:	0020      	movs	r0, r4
    20b8:	4b0b      	ldr	r3, [pc, #44]	; (20e8 <EXT_I2C_init+0xa4>)
    20ba:	4798      	blx	r3
}
    20bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    20be:	46c0      	nop			; (mov r8, r8)
    20c0:	40000400 	.word	0x40000400
    20c4:	40000c00 	.word	0x40000c00
    20c8:	0000400f 	.word	0x0000400f
    20cc:	0000430c 	.word	0x0000430c
    20d0:	20000314 	.word	0x20000314
    20d4:	42001000 	.word	0x42001000
    20d8:	00000371 	.word	0x00000371
    20dc:	41004400 	.word	0x41004400
    20e0:	200002e8 	.word	0x200002e8
    20e4:	000003bd 	.word	0x000003bd
    20e8:	000003b1 	.word	0x000003b1

000020ec <PWM_init>:
void PWM_init(void){
    20ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    20ee:	46de      	mov	lr, fp
    20f0:	4657      	mov	r7, sl
    20f2:	464e      	mov	r6, r9
    20f4:	4645      	mov	r5, r8
    20f6:	b5e0      	push	{r5, r6, r7, lr}
    20f8:	4d2c      	ldr	r5, [pc, #176]	; (21ac <PWM_init+0xc0>)
    20fa:	6a2a      	ldr	r2, [r5, #32]
    20fc:	2380      	movs	r3, #128	; 0x80
    20fe:	01db      	lsls	r3, r3, #7
    2100:	4313      	orrs	r3, r2
    2102:	622b      	str	r3, [r5, #32]
    2104:	4b2a      	ldr	r3, [pc, #168]	; (21b0 <PWM_init+0xc4>)
    2106:	469a      	mov	sl, r3
    2108:	4b2a      	ldr	r3, [pc, #168]	; (21b4 <PWM_init+0xc8>)
    210a:	469b      	mov	fp, r3
    210c:	4653      	mov	r3, sl
    210e:	465a      	mov	r2, fp
    2110:	805a      	strh	r2, [r3, #2]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    2112:	4c29      	ldr	r4, [pc, #164]	; (21b8 <PWM_init+0xcc>)
    2114:	22d1      	movs	r2, #209	; 0xd1
    2116:	5ca3      	ldrb	r3, [r4, r2]
	tmp &= ~PORT_PINCFG_PMUXEN;
    2118:	2101      	movs	r1, #1
    211a:	4689      	mov	r9, r1
    211c:	438b      	bics	r3, r1
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    211e:	4688      	mov	r8, r1
    2120:	4641      	mov	r1, r8
    2122:	430b      	orrs	r3, r1
    2124:	b2db      	uxtb	r3, r3
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    2126:	54a3      	strb	r3, [r4, r2]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    2128:	3a19      	subs	r2, #25
    212a:	5ca3      	ldrb	r3, [r4, r2]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
    212c:	210f      	movs	r1, #15
    212e:	400b      	ands	r3, r1
	tmp |= PORT_PMUX_PMUXO(data);
    2130:	3131      	adds	r1, #49	; 0x31
    2132:	430b      	orrs	r3, r1
    2134:	b2db      	uxtb	r3, r3
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    2136:	54a3      	strb	r3, [r4, r2]
	pwm_init(&PWM_0, TC6, _tc_get_pwm());
    2138:	4f20      	ldr	r7, [pc, #128]	; (21bc <PWM_init+0xd0>)
    213a:	47b8      	blx	r7
    213c:	0002      	movs	r2, r0
    213e:	4920      	ldr	r1, [pc, #128]	; (21c0 <PWM_init+0xd4>)
    2140:	4820      	ldr	r0, [pc, #128]	; (21c4 <PWM_init+0xd8>)
    2142:	4e21      	ldr	r6, [pc, #132]	; (21c8 <PWM_init+0xdc>)
    2144:	47b0      	blx	r6
    2146:	6a2a      	ldr	r2, [r5, #32]
    2148:	2380      	movs	r3, #128	; 0x80
    214a:	021b      	lsls	r3, r3, #8
    214c:	4313      	orrs	r3, r2
    214e:	622b      	str	r3, [r5, #32]
    2150:	4653      	mov	r3, sl
    2152:	465a      	mov	r2, fp
    2154:	805a      	strh	r2, [r3, #2]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    2156:	2255      	movs	r2, #85	; 0x55
    2158:	5ca3      	ldrb	r3, [r4, r2]
	tmp &= ~PORT_PINCFG_PMUXEN;
    215a:	4649      	mov	r1, r9
    215c:	438b      	bics	r3, r1
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    215e:	4641      	mov	r1, r8
    2160:	430b      	orrs	r3, r1
    2162:	b2db      	uxtb	r3, r3
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    2164:	54a3      	strb	r3, [r4, r2]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    2166:	3a1b      	subs	r2, #27
    2168:	5ca3      	ldrb	r3, [r4, r2]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
    216a:	210f      	movs	r1, #15
    216c:	400b      	ands	r3, r1
	tmp |= PORT_PMUX_PMUXO(data);
    216e:	3131      	adds	r1, #49	; 0x31
    2170:	430b      	orrs	r3, r1
    2172:	b2db      	uxtb	r3, r3
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    2174:	54a3      	strb	r3, [r4, r2]
	pwm_init(&PWM_1, TC7, _tc_get_pwm());
    2176:	47b8      	blx	r7
    2178:	0002      	movs	r2, r0
    217a:	4c14      	ldr	r4, [pc, #80]	; (21cc <PWM_init+0xe0>)
    217c:	4914      	ldr	r1, [pc, #80]	; (21d0 <PWM_init+0xe4>)
    217e:	0020      	movs	r0, r4
    2180:	47b0      	blx	r6
	pwm_set_parameters(&PWM_0, 5000, 0);
    2182:	4e14      	ldr	r6, [pc, #80]	; (21d4 <PWM_init+0xe8>)
    2184:	2200      	movs	r2, #0
    2186:	0031      	movs	r1, r6
    2188:	480e      	ldr	r0, [pc, #56]	; (21c4 <PWM_init+0xd8>)
    218a:	4d13      	ldr	r5, [pc, #76]	; (21d8 <PWM_init+0xec>)
    218c:	47a8      	blx	r5
	pwm_set_parameters(&PWM_1, 5000, 0);
    218e:	2200      	movs	r2, #0
    2190:	0031      	movs	r1, r6
    2192:	0020      	movs	r0, r4
    2194:	47a8      	blx	r5
	pwm_enable(&PWM_0);
    2196:	480b      	ldr	r0, [pc, #44]	; (21c4 <PWM_init+0xd8>)
    2198:	4d10      	ldr	r5, [pc, #64]	; (21dc <PWM_init+0xf0>)
    219a:	47a8      	blx	r5
	pwm_enable(&PWM_1);
    219c:	0020      	movs	r0, r4
    219e:	47a8      	blx	r5
}
    21a0:	bc3c      	pop	{r2, r3, r4, r5}
    21a2:	4690      	mov	r8, r2
    21a4:	4699      	mov	r9, r3
    21a6:	46a2      	mov	sl, r4
    21a8:	46ab      	mov	fp, r5
    21aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    21ac:	40000400 	.word	0x40000400
    21b0:	40000c00 	.word	0x40000c00
    21b4:	00004016 	.word	0x00004016
    21b8:	41004400 	.word	0x41004400
    21bc:	00001a11 	.word	0x00001a11
    21c0:	42003800 	.word	0x42003800
    21c4:	200001f8 	.word	0x200001f8
    21c8:	0000044d 	.word	0x0000044d
    21cc:	20000254 	.word	0x20000254
    21d0:	42003c00 	.word	0x42003c00
    21d4:	00001388 	.word	0x00001388
    21d8:	000004d1 	.word	0x000004d1
    21dc:	00000495 	.word	0x00000495

000021e0 <DEBUG_Serial_init>:
void DEBUG_Serial_init(void){
    21e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    21e2:	4a19      	ldr	r2, [pc, #100]	; (2248 <DEBUG_Serial_init+0x68>)
    21e4:	6a13      	ldr	r3, [r2, #32]
    21e6:	2140      	movs	r1, #64	; 0x40
    21e8:	430b      	orrs	r3, r1
    21ea:	6213      	str	r3, [r2, #32]
    21ec:	4a17      	ldr	r2, [pc, #92]	; (224c <DEBUG_Serial_init+0x6c>)
    21ee:	4b18      	ldr	r3, [pc, #96]	; (2250 <DEBUG_Serial_init+0x70>)
    21f0:	805a      	strh	r2, [r3, #2]
	usart_sync_init(&DEBUG_SERIAL, SERCOM4, (void *)NULL);
    21f2:	2200      	movs	r2, #0
    21f4:	4917      	ldr	r1, [pc, #92]	; (2254 <DEBUG_Serial_init+0x74>)
    21f6:	4818      	ldr	r0, [pc, #96]	; (2258 <DEBUG_Serial_init+0x78>)
    21f8:	4b18      	ldr	r3, [pc, #96]	; (225c <DEBUG_Serial_init+0x7c>)
    21fa:	4798      	blx	r3
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    21fc:	4b18      	ldr	r3, [pc, #96]	; (2260 <DEBUG_Serial_init+0x80>)
    21fe:	21cc      	movs	r1, #204	; 0xcc
    2200:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
    2202:	2401      	movs	r4, #1
    2204:	43a2      	bics	r2, r4
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    2206:	2701      	movs	r7, #1
    2208:	433a      	orrs	r2, r7
    220a:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    220c:	545a      	strb	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    220e:	22b6      	movs	r2, #182	; 0xb6
    2210:	5c98      	ldrb	r0, [r3, r2]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
    2212:	260f      	movs	r6, #15
    2214:	43b0      	bics	r0, r6
	tmp |= PORT_PMUX_PMUXE(data);
    2216:	2502      	movs	r5, #2
    2218:	4328      	orrs	r0, r5
    221a:	b2c0      	uxtb	r0, r0
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    221c:	5498      	strb	r0, [r3, r2]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    221e:	3218      	adds	r2, #24
    2220:	5c99      	ldrb	r1, [r3, r2]
	tmp &= ~PORT_PINCFG_PMUXEN;
    2222:	43a1      	bics	r1, r4
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    2224:	4339      	orrs	r1, r7
    2226:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    2228:	5499      	strb	r1, [r3, r2]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    222a:	21b7      	movs	r1, #183	; 0xb7
    222c:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
    222e:	43b2      	bics	r2, r6
	tmp |= PORT_PMUX_PMUXE(data);
    2230:	432a      	orrs	r2, r5
    2232:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    2234:	545a      	strb	r2, [r3, r1]
	usart_sync_get_io_descriptor(&DEBUG_SERIAL, &debug_serial);
    2236:	490b      	ldr	r1, [pc, #44]	; (2264 <DEBUG_Serial_init+0x84>)
    2238:	4807      	ldr	r0, [pc, #28]	; (2258 <DEBUG_Serial_init+0x78>)
    223a:	4b0b      	ldr	r3, [pc, #44]	; (2268 <DEBUG_Serial_init+0x88>)
    223c:	4798      	blx	r3
	usart_sync_enable(&DEBUG_SERIAL);
    223e:	4806      	ldr	r0, [pc, #24]	; (2258 <DEBUG_Serial_init+0x78>)
    2240:	4b0a      	ldr	r3, [pc, #40]	; (226c <DEBUG_Serial_init+0x8c>)
    2242:	4798      	blx	r3
}
    2244:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2246:	46c0      	nop			; (mov r8, r8)
    2248:	40000400 	.word	0x40000400
    224c:	00004011 	.word	0x00004011
    2250:	40000c00 	.word	0x40000c00
    2254:	42001800 	.word	0x42001800
    2258:	200002ec 	.word	0x200002ec
    225c:	0000093d 	.word	0x0000093d
    2260:	41004400 	.word	0x41004400
    2264:	200002e4 	.word	0x200002e4
    2268:	000009b5 	.word	0x000009b5
    226c:	00000989 	.word	0x00000989

00002270 <mcu_init>:
{
    2270:	b510      	push	{r4, lr}
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
	_init_chip();
    2272:	4b0b      	ldr	r3, [pc, #44]	; (22a0 <mcu_init+0x30>)
    2274:	4798      	blx	r3
	gpio_init();
    2276:	4b0b      	ldr	r3, [pc, #44]	; (22a4 <mcu_init+0x34>)
    2278:	4798      	blx	r3
	ETH_SPI_init();
    227a:	4b0b      	ldr	r3, [pc, #44]	; (22a8 <mcu_init+0x38>)
    227c:	4798      	blx	r3
	EXT_SPI_init();
    227e:	4b0b      	ldr	r3, [pc, #44]	; (22ac <mcu_init+0x3c>)
    2280:	4798      	blx	r3
	EXT_I2C_init();
    2282:	4b0b      	ldr	r3, [pc, #44]	; (22b0 <mcu_init+0x40>)
    2284:	4798      	blx	r3
	PWM_init();
    2286:	4b0b      	ldr	r3, [pc, #44]	; (22b4 <mcu_init+0x44>)
    2288:	4798      	blx	r3
	DEBUG_Serial_init();
    228a:	4b0b      	ldr	r3, [pc, #44]	; (22b8 <mcu_init+0x48>)
    228c:	4798      	blx	r3
	ext_irq_register(ETH_INT, ETH_Handler);
    228e:	490b      	ldr	r1, [pc, #44]	; (22bc <mcu_init+0x4c>)
    2290:	2028      	movs	r0, #40	; 0x28
    2292:	4b0b      	ldr	r3, [pc, #44]	; (22c0 <mcu_init+0x50>)
    2294:	4798      	blx	r3
	TIMER_IRQ_init();
    2296:	4b0b      	ldr	r3, [pc, #44]	; (22c4 <mcu_init+0x54>)
    2298:	4798      	blx	r3
	EXT_IRG_init();
    229a:	4b0b      	ldr	r3, [pc, #44]	; (22c8 <mcu_init+0x58>)
    229c:	4798      	blx	r3
}
    229e:	bd10      	pop	{r4, pc}
    22a0:	00000a95 	.word	0x00000a95
    22a4:	00001ab9 	.word	0x00001ab9
    22a8:	00001d6d 	.word	0x00001d6d
    22ac:	00001f35 	.word	0x00001f35
    22b0:	00002045 	.word	0x00002045
    22b4:	000020ed 	.word	0x000020ed
    22b8:	000021e1 	.word	0x000021e1
    22bc:	00001a3d 	.word	0x00001a3d
    22c0:	00000231 	.word	0x00000231
    22c4:	00001a4d 	.word	0x00001a4d
    22c8:	00001d0d 	.word	0x00001d0d

000022cc <close>:
   while(getSn_SR(sn) == SOCK_CLOSED);
   return (int8_t)sn;
}	   

int8_t close(uint8_t sn)
{
    22cc:	b570      	push	{r4, r5, r6, lr}
    22ce:	0006      	movs	r6, r0
	CHECK_SOCKNUM();
    22d0:	2808      	cmp	r0, #8
    22d2:	d82e      	bhi.n	2332 <close+0x66>
      while(getSn_CR(sn) != 0);
      while(getSn_SR(sn) != SOCK_UDP);
      sendto(sn,destip,1,destip,0x3000); // send the dummy data to an unknown destination(0.0.0.1).
   };   
#endif 
	setSn_CR(sn,Sn_CR_CLOSE);
    22d4:	0084      	lsls	r4, r0, #2
    22d6:	3401      	adds	r4, #1
    22d8:	00e4      	lsls	r4, r4, #3
    22da:	1c65      	adds	r5, r4, #1
    22dc:	35ff      	adds	r5, #255	; 0xff
    22de:	2110      	movs	r1, #16
    22e0:	0028      	movs	r0, r5
    22e2:	4b15      	ldr	r3, [pc, #84]	; (2338 <close+0x6c>)
    22e4:	4798      	blx	r3
   /* wait to process the command... */
	while( getSn_CR(sn) );
    22e6:	0028      	movs	r0, r5
    22e8:	4b14      	ldr	r3, [pc, #80]	; (233c <close+0x70>)
    22ea:	4798      	blx	r3
    22ec:	2800      	cmp	r0, #0
    22ee:	d1fa      	bne.n	22e6 <close+0x1a>
	/* clear all interrupt of the socket. */
	setSn_IR(sn, 0xFF);
    22f0:	2380      	movs	r3, #128	; 0x80
    22f2:	009b      	lsls	r3, r3, #2
    22f4:	18e0      	adds	r0, r4, r3
    22f6:	211f      	movs	r1, #31
    22f8:	4b0f      	ldr	r3, [pc, #60]	; (2338 <close+0x6c>)
    22fa:	4798      	blx	r3
	//A20150401 : Release the sock_io_mode of socket n.
	sock_io_mode &= ~(1<<sn);
    22fc:	2301      	movs	r3, #1
    22fe:	40b3      	lsls	r3, r6
    2300:	43db      	mvns	r3, r3
    2302:	b21b      	sxth	r3, r3
    2304:	480e      	ldr	r0, [pc, #56]	; (2340 <close+0x74>)
    2306:	8802      	ldrh	r2, [r0, #0]
    2308:	401a      	ands	r2, r3
    230a:	8002      	strh	r2, [r0, #0]
	//
	sock_is_sending &= ~(1<<sn);
    230c:	8842      	ldrh	r2, [r0, #2]
    230e:	4013      	ands	r3, r2
    2310:	8043      	strh	r3, [r0, #2]
	sock_remained_size[sn] = 0;
    2312:	0073      	lsls	r3, r6, #1
    2314:	18c3      	adds	r3, r0, r3
    2316:	2200      	movs	r2, #0
    2318:	809a      	strh	r2, [r3, #4]
	sock_pack_info[sn] = 0;
    231a:	1980      	adds	r0, r0, r6
    231c:	2300      	movs	r3, #0
    231e:	7503      	strb	r3, [r0, #20]
	while(getSn_SR(sn) != SOCK_CLOSED);
    2320:	23c0      	movs	r3, #192	; 0xc0
    2322:	009b      	lsls	r3, r3, #2
    2324:	18e0      	adds	r0, r4, r3
    2326:	4b05      	ldr	r3, [pc, #20]	; (233c <close+0x70>)
    2328:	4798      	blx	r3
    232a:	2800      	cmp	r0, #0
    232c:	d1f8      	bne.n	2320 <close+0x54>
	return SOCK_OK;
    232e:	3001      	adds	r0, #1
}
    2330:	bd70      	pop	{r4, r5, r6, pc}
	CHECK_SOCKNUM();
    2332:	2001      	movs	r0, #1
    2334:	4240      	negs	r0, r0
    2336:	e7fb      	b.n	2330 <close+0x64>
    2338:	000030c9 	.word	0x000030c9
    233c:	00003065 	.word	0x00003065
    2340:	20000148 	.word	0x20000148

00002344 <socket>:
{
    2344:	b5f0      	push	{r4, r5, r6, r7, lr}
    2346:	46ce      	mov	lr, r9
    2348:	4647      	mov	r7, r8
    234a:	b580      	push	{r7, lr}
    234c:	b085      	sub	sp, #20
    234e:	0006      	movs	r6, r0
    2350:	000d      	movs	r5, r1
    2352:	4691      	mov	r9, r2
    2354:	001f      	movs	r7, r3
	CHECK_SOCKNUM();
    2356:	2808      	cmp	r0, #8
    2358:	d900      	bls.n	235c <socket+0x18>
    235a:	e090      	b.n	247e <socket+0x13a>
	switch(protocol)
    235c:	2901      	cmp	r1, #1
    235e:	d068      	beq.n	2432 <socket+0xee>
    2360:	2900      	cmp	r1, #0
    2362:	d100      	bne.n	2366 <socket+0x22>
    2364:	e08e      	b.n	2484 <socket+0x140>
    2366:	2904      	cmp	r1, #4
    2368:	d900      	bls.n	236c <socket+0x28>
    236a:	e08b      	b.n	2484 <socket+0x140>
	if((flag & 0x04) != 0) return SOCKERR_SOCKFLAG;
    236c:	077b      	lsls	r3, r7, #29
    236e:	d500      	bpl.n	2372 <socket+0x2e>
    2370:	e08b      	b.n	248a <socket+0x146>
	if(flag != 0)
    2372:	2f00      	cmp	r7, #0
    2374:	d004      	beq.n	2380 <socket+0x3c>
   	switch(protocol)
    2376:	2d01      	cmp	r5, #1
    2378:	d068      	beq.n	244c <socket+0x108>
    237a:	2d02      	cmp	r5, #2
    237c:	d100      	bne.n	2380 <socket+0x3c>
    237e:	e06b      	b.n	2458 <socket+0x114>
	close(sn);
    2380:	0030      	movs	r0, r6
    2382:	4b45      	ldr	r3, [pc, #276]	; (2498 <socket+0x154>)
    2384:	4798      	blx	r3
	   setSn_MR(sn, (protocol | (flag & 0xF0)));
    2386:	00b4      	lsls	r4, r6, #2
    2388:	3401      	adds	r4, #1
    238a:	00e4      	lsls	r4, r4, #3
    238c:	230f      	movs	r3, #15
    238e:	0039      	movs	r1, r7
    2390:	4399      	bics	r1, r3
    2392:	b249      	sxtb	r1, r1
    2394:	4329      	orrs	r1, r5
    2396:	b2c9      	uxtb	r1, r1
    2398:	0020      	movs	r0, r4
    239a:	4b40      	ldr	r3, [pc, #256]	; (249c <socket+0x158>)
    239c:	4798      	blx	r3
	if(!port)
    239e:	464b      	mov	r3, r9
    23a0:	2b00      	cmp	r3, #0
    23a2:	d108      	bne.n	23b6 <socket+0x72>
	   port = sock_any_port++;
    23a4:	4a3e      	ldr	r2, [pc, #248]	; (24a0 <socket+0x15c>)
    23a6:	8813      	ldrh	r3, [r2, #0]
    23a8:	4699      	mov	r9, r3
    23aa:	3301      	adds	r3, #1
    23ac:	b29b      	uxth	r3, r3
    23ae:	8013      	strh	r3, [r2, #0]
	   if(sock_any_port == 0xFFF0) sock_any_port = SOCK_ANY_PORT_NUM;
    23b0:	4a3c      	ldr	r2, [pc, #240]	; (24a4 <socket+0x160>)
    23b2:	4293      	cmp	r3, r2
    23b4:	d05f      	beq.n	2476 <socket+0x132>
   setSn_PORT(sn,port);	
    23b6:	2380      	movs	r3, #128	; 0x80
    23b8:	00db      	lsls	r3, r3, #3
    23ba:	18e0      	adds	r0, r4, r3
    23bc:	464b      	mov	r3, r9
    23be:	0a19      	lsrs	r1, r3, #8
    23c0:	4b36      	ldr	r3, [pc, #216]	; (249c <socket+0x158>)
    23c2:	4698      	mov	r8, r3
    23c4:	4798      	blx	r3
    23c6:	464b      	mov	r3, r9
    23c8:	466a      	mov	r2, sp
    23ca:	71d3      	strb	r3, [r2, #7]
    23cc:	79d1      	ldrb	r1, [r2, #7]
    23ce:	23a0      	movs	r3, #160	; 0xa0
    23d0:	00db      	lsls	r3, r3, #3
    23d2:	18e0      	adds	r0, r4, r3
    23d4:	47c0      	blx	r8
   setSn_CR(sn,Sn_CR_OPEN);
    23d6:	1c65      	adds	r5, r4, #1
    23d8:	35ff      	adds	r5, #255	; 0xff
    23da:	2101      	movs	r1, #1
    23dc:	0028      	movs	r0, r5
    23de:	47c0      	blx	r8
   while(getSn_CR(sn));
    23e0:	0028      	movs	r0, r5
    23e2:	4b31      	ldr	r3, [pc, #196]	; (24a8 <socket+0x164>)
    23e4:	4798      	blx	r3
    23e6:	2800      	cmp	r0, #0
    23e8:	d1fa      	bne.n	23e0 <socket+0x9c>
   sock_io_mode &= ~(1 <<sn);
    23ea:	2101      	movs	r1, #1
    23ec:	40b1      	lsls	r1, r6
    23ee:	43c9      	mvns	r1, r1
    23f0:	b209      	sxth	r1, r1
    23f2:	4a2e      	ldr	r2, [pc, #184]	; (24ac <socket+0x168>)
    23f4:	8813      	ldrh	r3, [r2, #0]
    23f6:	400b      	ands	r3, r1
    23f8:	b21b      	sxth	r3, r3
	sock_io_mode |= ((flag & SF_IO_NONBLOCK) << sn);   
    23fa:	3001      	adds	r0, #1
    23fc:	4007      	ands	r7, r0
    23fe:	40b7      	lsls	r7, r6
    2400:	431f      	orrs	r7, r3
    2402:	8017      	strh	r7, [r2, #0]
   sock_is_sending &= ~(1<<sn);
    2404:	8853      	ldrh	r3, [r2, #2]
    2406:	4019      	ands	r1, r3
    2408:	8051      	strh	r1, [r2, #2]
   sock_remained_size[sn] = 0;
    240a:	0073      	lsls	r3, r6, #1
    240c:	18d3      	adds	r3, r2, r3
    240e:	2100      	movs	r1, #0
    2410:	8099      	strh	r1, [r3, #4]
   sock_pack_info[sn] = PACK_COMPLETED;
    2412:	1992      	adds	r2, r2, r6
    2414:	2300      	movs	r3, #0
    2416:	7513      	strb	r3, [r2, #20]
   while(getSn_SR(sn) == SOCK_CLOSED);
    2418:	23c0      	movs	r3, #192	; 0xc0
    241a:	009b      	lsls	r3, r3, #2
    241c:	18e0      	adds	r0, r4, r3
    241e:	4b22      	ldr	r3, [pc, #136]	; (24a8 <socket+0x164>)
    2420:	4798      	blx	r3
    2422:	2800      	cmp	r0, #0
    2424:	d0f8      	beq.n	2418 <socket+0xd4>
   return (int8_t)sn;
    2426:	b270      	sxtb	r0, r6
}	   
    2428:	b005      	add	sp, #20
    242a:	bc0c      	pop	{r2, r3}
    242c:	4690      	mov	r8, r2
    242e:	4699      	mov	r9, r3
    2430:	bdf0      	pop	{r4, r5, r6, r7, pc}
            getSIPR((uint8_t*)&taddr);
    2432:	2204      	movs	r2, #4
    2434:	a903      	add	r1, sp, #12
    2436:	20f0      	movs	r0, #240	; 0xf0
    2438:	0100      	lsls	r0, r0, #4
    243a:	4b1d      	ldr	r3, [pc, #116]	; (24b0 <socket+0x16c>)
    243c:	4798      	blx	r3
            if(taddr == 0) return SOCKERR_SOCKINIT;
    243e:	9b03      	ldr	r3, [sp, #12]
    2440:	2b00      	cmp	r3, #0
    2442:	d000      	beq.n	2446 <socket+0x102>
    2444:	e792      	b.n	236c <socket+0x28>
    2446:	2003      	movs	r0, #3
    2448:	4240      	negs	r0, r0
    244a:	e7ed      	b.n	2428 <socket+0xe4>
   		     if((flag & (SF_TCP_NODELAY|SF_IO_NONBLOCK))==0) return SOCKERR_SOCKFLAG;
    244c:	2321      	movs	r3, #33	; 0x21
    244e:	423b      	tst	r3, r7
    2450:	d196      	bne.n	2380 <socket+0x3c>
    2452:	2006      	movs	r0, #6
    2454:	4240      	negs	r0, r0
    2456:	e7e7      	b.n	2428 <socket+0xe4>
   	      if(flag & SF_IGMP_VER2)
    2458:	06bb      	lsls	r3, r7, #26
    245a:	d502      	bpl.n	2462 <socket+0x11e>
   	         if((flag & SF_MULTI_ENABLE)==0) return SOCKERR_SOCKFLAG;
    245c:	b27b      	sxtb	r3, r7
    245e:	2b00      	cmp	r3, #0
    2460:	da16      	bge.n	2490 <socket+0x14c>
      	      if(flag & SF_UNI_BLOCK)
    2462:	06fb      	lsls	r3, r7, #27
    2464:	d400      	bmi.n	2468 <socket+0x124>
    2466:	e78b      	b.n	2380 <socket+0x3c>
      	         if((flag & SF_MULTI_ENABLE) == 0) return SOCKERR_SOCKFLAG;
    2468:	b27b      	sxtb	r3, r7
    246a:	2b00      	cmp	r3, #0
    246c:	da00      	bge.n	2470 <socket+0x12c>
    246e:	e787      	b.n	2380 <socket+0x3c>
    2470:	2006      	movs	r0, #6
    2472:	4240      	negs	r0, r0
    2474:	e7d8      	b.n	2428 <socket+0xe4>
	   if(sock_any_port == 0xFFF0) sock_any_port = SOCK_ANY_PORT_NUM;
    2476:	4a0f      	ldr	r2, [pc, #60]	; (24b4 <socket+0x170>)
    2478:	4b09      	ldr	r3, [pc, #36]	; (24a0 <socket+0x15c>)
    247a:	801a      	strh	r2, [r3, #0]
    247c:	e79b      	b.n	23b6 <socket+0x72>
	CHECK_SOCKNUM();
    247e:	2001      	movs	r0, #1
    2480:	4240      	negs	r0, r0
    2482:	e7d1      	b.n	2428 <socket+0xe4>
         return SOCKERR_SOCKMODE;
    2484:	2005      	movs	r0, #5
    2486:	4240      	negs	r0, r0
    2488:	e7ce      	b.n	2428 <socket+0xe4>
	if((flag & 0x04) != 0) return SOCKERR_SOCKFLAG;
    248a:	2006      	movs	r0, #6
    248c:	4240      	negs	r0, r0
    248e:	e7cb      	b.n	2428 <socket+0xe4>
   	         if((flag & SF_MULTI_ENABLE)==0) return SOCKERR_SOCKFLAG;
    2490:	2006      	movs	r0, #6
    2492:	4240      	negs	r0, r0
    2494:	e7c8      	b.n	2428 <socket+0xe4>
    2496:	46c0      	nop			; (mov r8, r8)
    2498:	000022cd 	.word	0x000022cd
    249c:	000030c9 	.word	0x000030c9
    24a0:	20000028 	.word	0x20000028
    24a4:	0000fff0 	.word	0x0000fff0
    24a8:	00003065 	.word	0x00003065
    24ac:	20000148 	.word	0x20000148
    24b0:	00003129 	.word	0x00003129
    24b4:	ffffc000 	.word	0xffffc000

000024b8 <listen>:

int8_t listen(uint8_t sn)
{
    24b8:	b570      	push	{r4, r5, r6, lr}
    24ba:	0006      	movs	r6, r0
	CHECK_SOCKNUM();
    24bc:	2808      	cmp	r0, #8
    24be:	d829      	bhi.n	2514 <listen+0x5c>
   CHECK_SOCKMODE(Sn_MR_TCP);
    24c0:	0084      	lsls	r4, r0, #2
    24c2:	3401      	adds	r4, #1
    24c4:	00e4      	lsls	r4, r4, #3
    24c6:	0020      	movs	r0, r4
    24c8:	4b17      	ldr	r3, [pc, #92]	; (2528 <listen+0x70>)
    24ca:	4798      	blx	r3
    24cc:	230f      	movs	r3, #15
    24ce:	4018      	ands	r0, r3
    24d0:	2801      	cmp	r0, #1
    24d2:	d122      	bne.n	251a <listen+0x62>
	CHECK_SOCKINIT();
    24d4:	23c0      	movs	r3, #192	; 0xc0
    24d6:	009b      	lsls	r3, r3, #2
    24d8:	18e5      	adds	r5, r4, r3
    24da:	0028      	movs	r0, r5
    24dc:	4b12      	ldr	r3, [pc, #72]	; (2528 <listen+0x70>)
    24de:	4798      	blx	r3
    24e0:	2813      	cmp	r0, #19
    24e2:	d11d      	bne.n	2520 <listen+0x68>
	setSn_CR(sn,Sn_CR_LISTEN);
    24e4:	3401      	adds	r4, #1
    24e6:	34ff      	adds	r4, #255	; 0xff
    24e8:	2102      	movs	r1, #2
    24ea:	0020      	movs	r0, r4
    24ec:	4b0f      	ldr	r3, [pc, #60]	; (252c <listen+0x74>)
    24ee:	4798      	blx	r3
	while(getSn_CR(sn));
    24f0:	0020      	movs	r0, r4
    24f2:	4b0d      	ldr	r3, [pc, #52]	; (2528 <listen+0x70>)
    24f4:	4798      	blx	r3
    24f6:	2800      	cmp	r0, #0
    24f8:	d1fa      	bne.n	24f0 <listen+0x38>
   while(getSn_SR(sn) != SOCK_LISTEN)
    24fa:	0028      	movs	r0, r5
    24fc:	4b0a      	ldr	r3, [pc, #40]	; (2528 <listen+0x70>)
    24fe:	4798      	blx	r3
    2500:	2814      	cmp	r0, #20
    2502:	d101      	bne.n	2508 <listen+0x50>
   {
         close(sn);
         return SOCKERR_SOCKCLOSED;
   }
   return SOCK_OK;
    2504:	3813      	subs	r0, #19
}
    2506:	bd70      	pop	{r4, r5, r6, pc}
         close(sn);
    2508:	0030      	movs	r0, r6
    250a:	4b09      	ldr	r3, [pc, #36]	; (2530 <listen+0x78>)
    250c:	4798      	blx	r3
         return SOCKERR_SOCKCLOSED;
    250e:	2004      	movs	r0, #4
    2510:	4240      	negs	r0, r0
    2512:	e7f8      	b.n	2506 <listen+0x4e>
	CHECK_SOCKNUM();
    2514:	2001      	movs	r0, #1
    2516:	4240      	negs	r0, r0
    2518:	e7f5      	b.n	2506 <listen+0x4e>
   CHECK_SOCKMODE(Sn_MR_TCP);
    251a:	2005      	movs	r0, #5
    251c:	4240      	negs	r0, r0
    251e:	e7f2      	b.n	2506 <listen+0x4e>
	CHECK_SOCKINIT();
    2520:	2003      	movs	r0, #3
    2522:	4240      	negs	r0, r0
    2524:	e7ef      	b.n	2506 <listen+0x4e>
    2526:	46c0      	nop			; (mov r8, r8)
    2528:	00003065 	.word	0x00003065
    252c:	000030c9 	.word	0x000030c9
    2530:	000022cd 	.word	0x000022cd

00002534 <disconnect>:
   
   return SOCK_OK;
}

int8_t disconnect(uint8_t sn)
{
    2534:	b570      	push	{r4, r5, r6, lr}
    2536:	0006      	movs	r6, r0
   CHECK_SOCKNUM();
    2538:	2808      	cmp	r0, #8
    253a:	d835      	bhi.n	25a8 <disconnect+0x74>
   CHECK_SOCKMODE(Sn_MR_TCP);
    253c:	0084      	lsls	r4, r0, #2
    253e:	3401      	adds	r4, #1
    2540:	00e4      	lsls	r4, r4, #3
    2542:	0020      	movs	r0, r4
    2544:	4b1c      	ldr	r3, [pc, #112]	; (25b8 <disconnect+0x84>)
    2546:	4798      	blx	r3
    2548:	230f      	movs	r3, #15
    254a:	4018      	ands	r0, r3
    254c:	2801      	cmp	r0, #1
    254e:	d12e      	bne.n	25ae <disconnect+0x7a>
	setSn_CR(sn,Sn_CR_DISCON);
    2550:	1c65      	adds	r5, r4, #1
    2552:	35ff      	adds	r5, #255	; 0xff
    2554:	2108      	movs	r1, #8
    2556:	0028      	movs	r0, r5
    2558:	4b18      	ldr	r3, [pc, #96]	; (25bc <disconnect+0x88>)
    255a:	4798      	blx	r3
	/* wait to process the command... */
	while(getSn_CR(sn));
    255c:	0028      	movs	r0, r5
    255e:	4b16      	ldr	r3, [pc, #88]	; (25b8 <disconnect+0x84>)
    2560:	4798      	blx	r3
    2562:	2800      	cmp	r0, #0
    2564:	d1fa      	bne.n	255c <disconnect+0x28>
	sock_is_sending &= ~(1<<sn);
    2566:	2101      	movs	r1, #1
    2568:	0008      	movs	r0, r1
    256a:	40b0      	lsls	r0, r6
    256c:	4b14      	ldr	r3, [pc, #80]	; (25c0 <disconnect+0x8c>)
    256e:	885a      	ldrh	r2, [r3, #2]
    2570:	4382      	bics	r2, r0
    2572:	805a      	strh	r2, [r3, #2]
   if(sock_io_mode & (1<<sn)) return SOCK_BUSY;
    2574:	881b      	ldrh	r3, [r3, #0]
    2576:	4133      	asrs	r3, r6
    2578:	4219      	tst	r1, r3
    257a:	d11b      	bne.n	25b4 <disconnect+0x80>
	while(getSn_SR(sn) != SOCK_CLOSED)
    257c:	23c0      	movs	r3, #192	; 0xc0
    257e:	009b      	lsls	r3, r3, #2
    2580:	18e0      	adds	r0, r4, r3
    2582:	4b0d      	ldr	r3, [pc, #52]	; (25b8 <disconnect+0x84>)
    2584:	4798      	blx	r3
    2586:	2800      	cmp	r0, #0
    2588:	d00c      	beq.n	25a4 <disconnect+0x70>
	{
	   if(getSn_IR(sn) & Sn_IR_TIMEOUT)
    258a:	2380      	movs	r3, #128	; 0x80
    258c:	009b      	lsls	r3, r3, #2
    258e:	18e0      	adds	r0, r4, r3
    2590:	4b09      	ldr	r3, [pc, #36]	; (25b8 <disconnect+0x84>)
    2592:	4798      	blx	r3
    2594:	0703      	lsls	r3, r0, #28
    2596:	d5f1      	bpl.n	257c <disconnect+0x48>
	   {
	      close(sn);
    2598:	0030      	movs	r0, r6
    259a:	4b0a      	ldr	r3, [pc, #40]	; (25c4 <disconnect+0x90>)
    259c:	4798      	blx	r3
	      return SOCKERR_TIMEOUT;
    259e:	200d      	movs	r0, #13
    25a0:	4240      	negs	r0, r0
    25a2:	e008      	b.n	25b6 <disconnect+0x82>
	   }
	}
	return SOCK_OK;
    25a4:	3001      	adds	r0, #1
    25a6:	e006      	b.n	25b6 <disconnect+0x82>
   CHECK_SOCKNUM();
    25a8:	2001      	movs	r0, #1
    25aa:	4240      	negs	r0, r0
    25ac:	e003      	b.n	25b6 <disconnect+0x82>
   CHECK_SOCKMODE(Sn_MR_TCP);
    25ae:	2005      	movs	r0, #5
    25b0:	4240      	negs	r0, r0
    25b2:	e000      	b.n	25b6 <disconnect+0x82>
   if(sock_io_mode & (1<<sn)) return SOCK_BUSY;
    25b4:	2000      	movs	r0, #0
}
    25b6:	bd70      	pop	{r4, r5, r6, pc}
    25b8:	00003065 	.word	0x00003065
    25bc:	000030c9 	.word	0x000030c9
    25c0:	20000148 	.word	0x20000148
    25c4:	000022cd 	.word	0x000022cd

000025c8 <send>:

int32_t send(uint8_t sn, uint8_t * buf, uint16_t len)
{
    25c8:	b5f0      	push	{r4, r5, r6, r7, lr}
    25ca:	46c6      	mov	lr, r8
    25cc:	b500      	push	{lr}
    25ce:	b082      	sub	sp, #8
    25d0:	0004      	movs	r4, r0
    25d2:	9101      	str	r1, [sp, #4]
    25d4:	0017      	movs	r7, r2
   uint8_t tmp=0;
   uint16_t freesize=0;
   
   CHECK_SOCKNUM();
    25d6:	2808      	cmp	r0, #8
    25d8:	d900      	bls.n	25dc <send+0x14>
    25da:	e080      	b.n	26de <send+0x116>
   CHECK_SOCKMODE(Sn_MR_TCP);
    25dc:	0005      	movs	r5, r0
    25de:	0083      	lsls	r3, r0, #2
    25e0:	3301      	adds	r3, #1
    25e2:	00db      	lsls	r3, r3, #3
    25e4:	4698      	mov	r8, r3
    25e6:	0018      	movs	r0, r3
    25e8:	4b43      	ldr	r3, [pc, #268]	; (26f8 <send+0x130>)
    25ea:	4798      	blx	r3
    25ec:	230f      	movs	r3, #15
    25ee:	4018      	ands	r0, r3
    25f0:	2801      	cmp	r0, #1
    25f2:	d000      	beq.n	25f6 <send+0x2e>
    25f4:	e076      	b.n	26e4 <send+0x11c>
   CHECK_SOCKDATA();
    25f6:	2f00      	cmp	r7, #0
    25f8:	d100      	bne.n	25fc <send+0x34>
    25fa:	e076      	b.n	26ea <send+0x122>
   tmp = getSn_SR(sn);
    25fc:	23c0      	movs	r3, #192	; 0xc0
    25fe:	009b      	lsls	r3, r3, #2
    2600:	4443      	add	r3, r8
    2602:	9300      	str	r3, [sp, #0]
    2604:	0018      	movs	r0, r3
    2606:	4b3c      	ldr	r3, [pc, #240]	; (26f8 <send+0x130>)
    2608:	4798      	blx	r3
   if(tmp != SOCK_ESTABLISHED && tmp != SOCK_CLOSE_WAIT) return SOCKERR_SOCKSTATUS;
    260a:	2817      	cmp	r0, #23
    260c:	d002      	beq.n	2614 <send+0x4c>
    260e:	281c      	cmp	r0, #28
    2610:	d000      	beq.n	2614 <send+0x4c>
    2612:	e06d      	b.n	26f0 <send+0x128>
   if( sock_is_sending & (1<<sn) )
    2614:	4b39      	ldr	r3, [pc, #228]	; (26fc <send+0x134>)
    2616:	885b      	ldrh	r3, [r3, #2]
    2618:	4123      	asrs	r3, r4
    261a:	07db      	lsls	r3, r3, #31
    261c:	d518      	bpl.n	2650 <send+0x88>
   {
      tmp = getSn_IR(sn);
    261e:	2680      	movs	r6, #128	; 0x80
    2620:	00b6      	lsls	r6, r6, #2
    2622:	4446      	add	r6, r8
    2624:	0030      	movs	r0, r6
    2626:	4b34      	ldr	r3, [pc, #208]	; (26f8 <send+0x130>)
    2628:	4798      	blx	r3
      if(tmp & Sn_IR_SENDOK)
    262a:	06c3      	lsls	r3, r0, #27
    262c:	d406      	bmi.n	263c <send+0x74>
               return SOCK_BUSY;
            }
         #endif
         sock_is_sending &= ~(1<<sn);         
      }
      else if(tmp & Sn_IR_TIMEOUT)
    262e:	0703      	lsls	r3, r0, #28
    2630:	d41a      	bmi.n	2668 <send+0xa0>
      {
         close(sn);
         return SOCKERR_TIMEOUT;
      }
      else return SOCK_BUSY;
    2632:	2000      	movs	r0, #0
   while(getSn_CR(sn));
   sock_is_sending |= (1 << sn);
   //M20150409 : Explicit Type Casting
   //return len;
   return (int32_t)len;
}
    2634:	b002      	add	sp, #8
    2636:	bc04      	pop	{r2}
    2638:	4690      	mov	r8, r2
    263a:	bdf0      	pop	{r4, r5, r6, r7, pc}
         setSn_IR(sn, Sn_IR_SENDOK);
    263c:	2110      	movs	r1, #16
    263e:	0030      	movs	r0, r6
    2640:	4b2f      	ldr	r3, [pc, #188]	; (2700 <send+0x138>)
    2642:	4798      	blx	r3
         sock_is_sending &= ~(1<<sn);         
    2644:	2201      	movs	r2, #1
    2646:	40a2      	lsls	r2, r4
    2648:	492c      	ldr	r1, [pc, #176]	; (26fc <send+0x134>)
    264a:	884b      	ldrh	r3, [r1, #2]
    264c:	4393      	bics	r3, r2
    264e:	804b      	strh	r3, [r1, #2]
   freesize = getSn_TxMAX(sn);
    2650:	20f8      	movs	r0, #248	; 0xf8
    2652:	0140      	lsls	r0, r0, #5
    2654:	4440      	add	r0, r8
    2656:	4b28      	ldr	r3, [pc, #160]	; (26f8 <send+0x130>)
    2658:	4798      	blx	r3
    265a:	b280      	uxth	r0, r0
    265c:	0280      	lsls	r0, r0, #10
    265e:	b286      	uxth	r6, r0
   if (len > freesize) len = freesize; // check size not to exceed MAX size.
    2660:	42b7      	cmp	r7, r6
    2662:	d80f      	bhi.n	2684 <send+0xbc>
    2664:	003e      	movs	r6, r7
    2666:	e00d      	b.n	2684 <send+0xbc>
         close(sn);
    2668:	0020      	movs	r0, r4
    266a:	4b26      	ldr	r3, [pc, #152]	; (2704 <send+0x13c>)
    266c:	4798      	blx	r3
         return SOCKERR_TIMEOUT;
    266e:	200d      	movs	r0, #13
    2670:	4240      	negs	r0, r0
    2672:	e7df      	b.n	2634 <send+0x6c>
         close(sn);
    2674:	0020      	movs	r0, r4
    2676:	4b23      	ldr	r3, [pc, #140]	; (2704 <send+0x13c>)
    2678:	4798      	blx	r3
         return SOCKERR_SOCKSTATUS;
    267a:	2007      	movs	r0, #7
    267c:	4240      	negs	r0, r0
    267e:	e7d9      	b.n	2634 <send+0x6c>
      if(len <= freesize) break;
    2680:	42be      	cmp	r6, r7
    2682:	d913      	bls.n	26ac <send+0xe4>
      freesize = getSn_TX_FSR(sn);
    2684:	0020      	movs	r0, r4
    2686:	4b20      	ldr	r3, [pc, #128]	; (2708 <send+0x140>)
    2688:	4798      	blx	r3
    268a:	0007      	movs	r7, r0
      tmp = getSn_SR(sn);
    268c:	9800      	ldr	r0, [sp, #0]
    268e:	4b1a      	ldr	r3, [pc, #104]	; (26f8 <send+0x130>)
    2690:	4798      	blx	r3
      if ((tmp != SOCK_ESTABLISHED) && (tmp != SOCK_CLOSE_WAIT))
    2692:	2817      	cmp	r0, #23
    2694:	d001      	beq.n	269a <send+0xd2>
    2696:	281c      	cmp	r0, #28
    2698:	d1ec      	bne.n	2674 <send+0xac>
      if( (sock_io_mode & (1<<sn)) && (len > freesize) ) return SOCK_BUSY;
    269a:	4b18      	ldr	r3, [pc, #96]	; (26fc <send+0x134>)
    269c:	881b      	ldrh	r3, [r3, #0]
    269e:	412b      	asrs	r3, r5
    26a0:	07db      	lsls	r3, r3, #31
    26a2:	d5ed      	bpl.n	2680 <send+0xb8>
    26a4:	42be      	cmp	r6, r7
    26a6:	d9eb      	bls.n	2680 <send+0xb8>
    26a8:	2000      	movs	r0, #0
    26aa:	e7c3      	b.n	2634 <send+0x6c>
   wiz_send_data(sn, buf, len);
    26ac:	0032      	movs	r2, r6
    26ae:	9901      	ldr	r1, [sp, #4]
    26b0:	0020      	movs	r0, r4
    26b2:	4b16      	ldr	r3, [pc, #88]	; (270c <send+0x144>)
    26b4:	4798      	blx	r3
   setSn_CR(sn,Sn_CR_SEND);
    26b6:	4645      	mov	r5, r8
    26b8:	3501      	adds	r5, #1
    26ba:	35ff      	adds	r5, #255	; 0xff
    26bc:	2120      	movs	r1, #32
    26be:	0028      	movs	r0, r5
    26c0:	4b0f      	ldr	r3, [pc, #60]	; (2700 <send+0x138>)
    26c2:	4798      	blx	r3
   while(getSn_CR(sn));
    26c4:	0028      	movs	r0, r5
    26c6:	4b0c      	ldr	r3, [pc, #48]	; (26f8 <send+0x130>)
    26c8:	4798      	blx	r3
    26ca:	2800      	cmp	r0, #0
    26cc:	d1fa      	bne.n	26c4 <send+0xfc>
   sock_is_sending |= (1 << sn);
    26ce:	2201      	movs	r2, #1
    26d0:	40a2      	lsls	r2, r4
    26d2:	490a      	ldr	r1, [pc, #40]	; (26fc <send+0x134>)
    26d4:	884b      	ldrh	r3, [r1, #2]
    26d6:	4313      	orrs	r3, r2
    26d8:	804b      	strh	r3, [r1, #2]
   return (int32_t)len;
    26da:	0030      	movs	r0, r6
    26dc:	e7aa      	b.n	2634 <send+0x6c>
   CHECK_SOCKNUM();
    26de:	2001      	movs	r0, #1
    26e0:	4240      	negs	r0, r0
    26e2:	e7a7      	b.n	2634 <send+0x6c>
   CHECK_SOCKMODE(Sn_MR_TCP);
    26e4:	2005      	movs	r0, #5
    26e6:	4240      	negs	r0, r0
    26e8:	e7a4      	b.n	2634 <send+0x6c>
   CHECK_SOCKDATA();
    26ea:	200e      	movs	r0, #14
    26ec:	4240      	negs	r0, r0
    26ee:	e7a1      	b.n	2634 <send+0x6c>
   if(tmp != SOCK_ESTABLISHED && tmp != SOCK_CLOSE_WAIT) return SOCKERR_SOCKSTATUS;
    26f0:	2007      	movs	r0, #7
    26f2:	4240      	negs	r0, r0
    26f4:	e79e      	b.n	2634 <send+0x6c>
    26f6:	46c0      	nop			; (mov r8, r8)
    26f8:	00003065 	.word	0x00003065
    26fc:	20000148 	.word	0x20000148
    2700:	000030c9 	.word	0x000030c9
    2704:	000022cd 	.word	0x000022cd
    2708:	00003221 	.word	0x00003221
    270c:	000032f9 	.word	0x000032f9

00002710 <recv>:


int32_t recv(uint8_t sn, uint8_t * buf, uint16_t len)
{
    2710:	b5f0      	push	{r4, r5, r6, r7, lr}
    2712:	46c6      	mov	lr, r8
    2714:	b500      	push	{lr}
    2716:	b082      	sub	sp, #8
    2718:	9000      	str	r0, [sp, #0]
    271a:	9101      	str	r1, [sp, #4]
    271c:	0014      	movs	r4, r2
#if   _WIZCHIP_ == 5300
   uint8_t head[2];
   uint16_t mr;
#endif
//
   CHECK_SOCKNUM();
    271e:	2808      	cmp	r0, #8
    2720:	d864      	bhi.n	27ec <recv+0xdc>
   CHECK_SOCKMODE(Sn_MR_TCP);
    2722:	0006      	movs	r6, r0
    2724:	0087      	lsls	r7, r0, #2
    2726:	3701      	adds	r7, #1
    2728:	00ff      	lsls	r7, r7, #3
    272a:	0038      	movs	r0, r7
    272c:	4b34      	ldr	r3, [pc, #208]	; (2800 <recv+0xf0>)
    272e:	4798      	blx	r3
    2730:	230f      	movs	r3, #15
    2732:	4018      	ands	r0, r3
    2734:	2801      	cmp	r0, #1
    2736:	d15c      	bne.n	27f2 <recv+0xe2>
   CHECK_SOCKDATA();
    2738:	2c00      	cmp	r4, #0
    273a:	d05d      	beq.n	27f8 <recv+0xe8>
   
   recvsize = getSn_RxMAX(sn);
    273c:	23f0      	movs	r3, #240	; 0xf0
    273e:	015b      	lsls	r3, r3, #5
    2740:	18f8      	adds	r0, r7, r3
    2742:	4b2f      	ldr	r3, [pc, #188]	; (2800 <recv+0xf0>)
    2744:	4798      	blx	r3
    2746:	b280      	uxth	r0, r0
    2748:	0280      	lsls	r0, r0, #10
    274a:	b283      	uxth	r3, r0
    274c:	4698      	mov	r8, r3
   if(recvsize < len) len = recvsize;
    274e:	429c      	cmp	r4, r3
    2750:	d80f      	bhi.n	2772 <recv+0x62>
    2752:	46a0      	mov	r8, r4
    2754:	e00d      	b.n	2772 <recv+0x62>
            if(tmp == SOCK_CLOSE_WAIT)
            {
               if(recvsize != 0) break;
               else if(getSn_TX_FSR(sn) == getSn_TxMAX(sn))
               {
                  close(sn);
    2756:	9800      	ldr	r0, [sp, #0]
    2758:	4b2a      	ldr	r3, [pc, #168]	; (2804 <recv+0xf4>)
    275a:	4798      	blx	r3
                  return SOCKERR_SOCKSTATUS;
    275c:	2007      	movs	r0, #7
    275e:	4240      	negs	r0, r0
    2760:	e040      	b.n	27e4 <recv+0xd4>
               }
            }
            else
            {
               close(sn);
    2762:	9800      	ldr	r0, [sp, #0]
    2764:	4b27      	ldr	r3, [pc, #156]	; (2804 <recv+0xf4>)
    2766:	4798      	blx	r3
               return SOCKERR_SOCKSTATUS;
    2768:	2007      	movs	r0, #7
    276a:	4240      	negs	r0, r0
    276c:	e03a      	b.n	27e4 <recv+0xd4>
            }
         }
         if((sock_io_mode & (1<<sn)) && (recvsize == 0)) return SOCK_BUSY;
         if(recvsize != 0) break;
    276e:	2c00      	cmp	r4, #0
    2770:	d124      	bne.n	27bc <recv+0xac>
         recvsize = getSn_RX_RSR(sn);
    2772:	9d00      	ldr	r5, [sp, #0]
    2774:	0028      	movs	r0, r5
    2776:	4b24      	ldr	r3, [pc, #144]	; (2808 <recv+0xf8>)
    2778:	4798      	blx	r3
    277a:	0004      	movs	r4, r0
         tmp = getSn_SR(sn);
    277c:	23c0      	movs	r3, #192	; 0xc0
    277e:	009b      	lsls	r3, r3, #2
    2780:	18f8      	adds	r0, r7, r3
    2782:	4b1f      	ldr	r3, [pc, #124]	; (2800 <recv+0xf0>)
    2784:	4798      	blx	r3
         if (tmp != SOCK_ESTABLISHED)
    2786:	2817      	cmp	r0, #23
    2788:	d00f      	beq.n	27aa <recv+0x9a>
            if(tmp == SOCK_CLOSE_WAIT)
    278a:	281c      	cmp	r0, #28
    278c:	d1e9      	bne.n	2762 <recv+0x52>
               if(recvsize != 0) break;
    278e:	2c00      	cmp	r4, #0
    2790:	d114      	bne.n	27bc <recv+0xac>
               else if(getSn_TX_FSR(sn) == getSn_TxMAX(sn))
    2792:	0028      	movs	r0, r5
    2794:	4b1d      	ldr	r3, [pc, #116]	; (280c <recv+0xfc>)
    2796:	4798      	blx	r3
    2798:	0005      	movs	r5, r0
    279a:	23f8      	movs	r3, #248	; 0xf8
    279c:	015b      	lsls	r3, r3, #5
    279e:	18f8      	adds	r0, r7, r3
    27a0:	4b17      	ldr	r3, [pc, #92]	; (2800 <recv+0xf0>)
    27a2:	4798      	blx	r3
    27a4:	0280      	lsls	r0, r0, #10
    27a6:	4285      	cmp	r5, r0
    27a8:	d0d5      	beq.n	2756 <recv+0x46>
         if((sock_io_mode & (1<<sn)) && (recvsize == 0)) return SOCK_BUSY;
    27aa:	4b19      	ldr	r3, [pc, #100]	; (2810 <recv+0x100>)
    27ac:	881b      	ldrh	r3, [r3, #0]
    27ae:	4133      	asrs	r3, r6
    27b0:	07db      	lsls	r3, r3, #31
    27b2:	d5dc      	bpl.n	276e <recv+0x5e>
    27b4:	2c00      	cmp	r4, #0
    27b6:	d1da      	bne.n	276e <recv+0x5e>
    27b8:	2000      	movs	r0, #0
    27ba:	e013      	b.n	27e4 <recv+0xd4>
   }
   else sock_pack_info[sn] = PACK_COMPLETED;
   if(getSn_MR(sn) & Sn_MR_ALIGN) sock_remained_size[sn] = 0;
   //len = recvsize;
#else   
   if(recvsize < len) len = recvsize;   
    27bc:	45a0      	cmp	r8, r4
    27be:	d800      	bhi.n	27c2 <recv+0xb2>
    27c0:	4644      	mov	r4, r8
   wiz_recv_data(sn, buf, len);
    27c2:	0022      	movs	r2, r4
    27c4:	9901      	ldr	r1, [sp, #4]
    27c6:	9800      	ldr	r0, [sp, #0]
    27c8:	4b12      	ldr	r3, [pc, #72]	; (2814 <recv+0x104>)
    27ca:	4798      	blx	r3
   setSn_CR(sn,Sn_CR_RECV);
    27cc:	3701      	adds	r7, #1
    27ce:	37ff      	adds	r7, #255	; 0xff
    27d0:	2140      	movs	r1, #64	; 0x40
    27d2:	0038      	movs	r0, r7
    27d4:	4b10      	ldr	r3, [pc, #64]	; (2818 <recv+0x108>)
    27d6:	4798      	blx	r3
   while(getSn_CR(sn));
    27d8:	0038      	movs	r0, r7
    27da:	4b09      	ldr	r3, [pc, #36]	; (2800 <recv+0xf0>)
    27dc:	4798      	blx	r3
    27de:	2800      	cmp	r0, #0
    27e0:	d1fa      	bne.n	27d8 <recv+0xc8>
#endif
     
   //M20150409 : Explicit Type Casting
   //return len;
   return (int32_t)len;
    27e2:	0020      	movs	r0, r4
}
    27e4:	b002      	add	sp, #8
    27e6:	bc04      	pop	{r2}
    27e8:	4690      	mov	r8, r2
    27ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
   CHECK_SOCKNUM();
    27ec:	2001      	movs	r0, #1
    27ee:	4240      	negs	r0, r0
    27f0:	e7f8      	b.n	27e4 <recv+0xd4>
   CHECK_SOCKMODE(Sn_MR_TCP);
    27f2:	2005      	movs	r0, #5
    27f4:	4240      	negs	r0, r0
    27f6:	e7f5      	b.n	27e4 <recv+0xd4>
   CHECK_SOCKDATA();
    27f8:	200e      	movs	r0, #14
    27fa:	4240      	negs	r0, r0
    27fc:	e7f2      	b.n	27e4 <recv+0xd4>
    27fe:	46c0      	nop			; (mov r8, r8)
    2800:	00003065 	.word	0x00003065
    2804:	000022cd 	.word	0x000022cd
    2808:	0000328d 	.word	0x0000328d
    280c:	00003221 	.word	0x00003221
    2810:	20000148 	.word	0x20000148
    2814:	00003371 	.word	0x00003371
    2818:	000030c9 	.word	0x000030c9

0000281c <sendto>:

int32_t sendto(uint8_t sn, uint8_t * buf, uint16_t len, uint8_t * addr, uint16_t port)
{
    281c:	b5f0      	push	{r4, r5, r6, r7, lr}
    281e:	46de      	mov	lr, fp
    2820:	b500      	push	{lr}
    2822:	b084      	sub	sp, #16
    2824:	9001      	str	r0, [sp, #4]
    2826:	9103      	str	r1, [sp, #12]
    2828:	4693      	mov	fp, r2
    282a:	001c      	movs	r4, r3
    282c:	ab0a      	add	r3, sp, #40	; 0x28
    282e:	881f      	ldrh	r7, [r3, #0]
   uint8_t tmp = 0;
   uint16_t freesize = 0;
   uint32_t taddr;

   CHECK_SOCKNUM();
    2830:	2808      	cmp	r0, #8
    2832:	d900      	bls.n	2836 <sendto+0x1a>
    2834:	e094      	b.n	2960 <sendto+0x144>
   switch(getSn_MR(sn) & 0x0F)
    2836:	0005      	movs	r5, r0
    2838:	0083      	lsls	r3, r0, #2
    283a:	3301      	adds	r3, #1
    283c:	00de      	lsls	r6, r3, #3
    283e:	0030      	movs	r0, r6
    2840:	4b52      	ldr	r3, [pc, #328]	; (298c <sendto+0x170>)
    2842:	4798      	blx	r3
    2844:	230f      	movs	r3, #15
    2846:	4003      	ands	r3, r0
    2848:	3b02      	subs	r3, #2
    284a:	b2db      	uxtb	r3, r3
    284c:	2b02      	cmp	r3, #2
    284e:	d900      	bls.n	2852 <sendto+0x36>
    2850:	e089      	b.n	2966 <sendto+0x14a>
         break;
//   #endif
      default:
         return SOCKERR_SOCKMODE;
   }
   CHECK_SOCKDATA();
    2852:	465b      	mov	r3, fp
    2854:	2b00      	cmp	r3, #0
    2856:	d100      	bne.n	285a <sendto+0x3e>
    2858:	e088      	b.n	296c <sendto+0x150>
   //M20140501 : For avoiding fatal error on memory align mismatched
   //if(*((uint32_t*)addr) == 0) return SOCKERR_IPINVALID;
   //{
      //uint32_t taddr;
      taddr = ((uint32_t)addr[0]) & 0x000000FF;
    285a:	7823      	ldrb	r3, [r4, #0]
      taddr = (taddr << 8) + ((uint32_t)addr[1] & 0x000000FF);
    285c:	021b      	lsls	r3, r3, #8
    285e:	7862      	ldrb	r2, [r4, #1]
    2860:	189b      	adds	r3, r3, r2
      taddr = (taddr << 8) + ((uint32_t)addr[2] & 0x000000FF);
    2862:	021b      	lsls	r3, r3, #8
    2864:	78a2      	ldrb	r2, [r4, #2]
    2866:	189b      	adds	r3, r3, r2
      taddr = (taddr << 8) + ((uint32_t)addr[3] & 0x000000FF);
    2868:	021b      	lsls	r3, r3, #8
    286a:	78e2      	ldrb	r2, [r4, #3]
    286c:	189b      	adds	r3, r3, r2
   //}
   //
   //if(*((uint32_t*)addr) == 0) return SOCKERR_IPINVALID;
   if((taddr == 0) && ((getSn_MR(sn)&Sn_MR_MACRAW) != Sn_MR_MACRAW)) return SOCKERR_IPINVALID;
    286e:	2b00      	cmp	r3, #0
    2870:	d033      	beq.n	28da <sendto+0xbe>
   if((port  == 0) && ((getSn_MR(sn)&Sn_MR_MACRAW) != Sn_MR_MACRAW)) return SOCKERR_PORTZERO;
    2872:	2f00      	cmp	r7, #0
    2874:	d104      	bne.n	2880 <sendto+0x64>
    2876:	0030      	movs	r0, r6
    2878:	4b44      	ldr	r3, [pc, #272]	; (298c <sendto+0x170>)
    287a:	4798      	blx	r3
    287c:	0743      	lsls	r3, r0, #29
    287e:	d578      	bpl.n	2972 <sendto+0x156>
   tmp = getSn_SR(sn);
    2880:	23c0      	movs	r3, #192	; 0xc0
    2882:	009b      	lsls	r3, r3, #2
    2884:	469c      	mov	ip, r3
    2886:	44b4      	add	ip, r6
    2888:	4663      	mov	r3, ip
    288a:	9302      	str	r3, [sp, #8]
    288c:	4660      	mov	r0, ip
    288e:	4b3f      	ldr	r3, [pc, #252]	; (298c <sendto+0x170>)
    2890:	4798      	blx	r3
//#if ( _WIZCHIP_ < 5200 )
   if((tmp != SOCK_MACRAW) && (tmp != SOCK_UDP) && (tmp != SOCK_IPRAW)) return SOCKERR_SOCKSTATUS;
    2892:	2842      	cmp	r0, #66	; 0x42
    2894:	d003      	beq.n	289e <sendto+0x82>
    2896:	2822      	cmp	r0, #34	; 0x22
    2898:	d001      	beq.n	289e <sendto+0x82>
    289a:	2832      	cmp	r0, #50	; 0x32
    289c:	d16c      	bne.n	2978 <sendto+0x15c>
//#else
//   if(tmp != SOCK_MACRAW && tmp != SOCK_UDP) return SOCKERR_SOCKSTATUS;
//#endif
      
   setSn_DIPR(sn,addr);
    289e:	2204      	movs	r2, #4
    28a0:	0021      	movs	r1, r4
    28a2:	23c0      	movs	r3, #192	; 0xc0
    28a4:	011b      	lsls	r3, r3, #4
    28a6:	18f0      	adds	r0, r6, r3
    28a8:	4b39      	ldr	r3, [pc, #228]	; (2990 <sendto+0x174>)
    28aa:	4798      	blx	r3
   setSn_DPORT(sn,port);      
    28ac:	0a39      	lsrs	r1, r7, #8
    28ae:	2380      	movs	r3, #128	; 0x80
    28b0:	015b      	lsls	r3, r3, #5
    28b2:	18f0      	adds	r0, r6, r3
    28b4:	4c37      	ldr	r4, [pc, #220]	; (2994 <sendto+0x178>)
    28b6:	47a0      	blx	r4
    28b8:	b2f9      	uxtb	r1, r7
    28ba:	2388      	movs	r3, #136	; 0x88
    28bc:	015b      	lsls	r3, r3, #5
    28be:	18f0      	adds	r0, r6, r3
    28c0:	47a0      	blx	r4
   freesize = getSn_TxMAX(sn);
    28c2:	23f8      	movs	r3, #248	; 0xf8
    28c4:	015b      	lsls	r3, r3, #5
    28c6:	18f0      	adds	r0, r6, r3
    28c8:	4b30      	ldr	r3, [pc, #192]	; (298c <sendto+0x170>)
    28ca:	4798      	blx	r3
    28cc:	b280      	uxth	r0, r0
    28ce:	0280      	lsls	r0, r0, #10
    28d0:	b287      	uxth	r7, r0
   if (len > freesize) len = freesize; // check size not to exceed MAX size.
    28d2:	45bb      	cmp	fp, r7
    28d4:	d80b      	bhi.n	28ee <sendto+0xd2>
    28d6:	465f      	mov	r7, fp
    28d8:	e009      	b.n	28ee <sendto+0xd2>
   if((taddr == 0) && ((getSn_MR(sn)&Sn_MR_MACRAW) != Sn_MR_MACRAW)) return SOCKERR_IPINVALID;
    28da:	0030      	movs	r0, r6
    28dc:	4b2b      	ldr	r3, [pc, #172]	; (298c <sendto+0x170>)
    28de:	4798      	blx	r3
    28e0:	0743      	lsls	r3, r0, #29
    28e2:	d4c6      	bmi.n	2872 <sendto+0x56>
    28e4:	200c      	movs	r0, #12
    28e6:	4240      	negs	r0, r0
    28e8:	e04b      	b.n	2982 <sendto+0x166>
   while(1)
   {
      freesize = getSn_TX_FSR(sn);
      if(getSn_SR(sn) == SOCK_CLOSED) return SOCKERR_SOCKCLOSED;
      if( (sock_io_mode & (1<<sn)) && (len > freesize) ) return SOCK_BUSY;
      if(len <= freesize) break;
    28ea:	42a7      	cmp	r7, r4
    28ec:	d911      	bls.n	2912 <sendto+0xf6>
      freesize = getSn_TX_FSR(sn);
    28ee:	9801      	ldr	r0, [sp, #4]
    28f0:	4b29      	ldr	r3, [pc, #164]	; (2998 <sendto+0x17c>)
    28f2:	4798      	blx	r3
    28f4:	0004      	movs	r4, r0
      if(getSn_SR(sn) == SOCK_CLOSED) return SOCKERR_SOCKCLOSED;
    28f6:	9802      	ldr	r0, [sp, #8]
    28f8:	4b24      	ldr	r3, [pc, #144]	; (298c <sendto+0x170>)
    28fa:	4798      	blx	r3
    28fc:	2800      	cmp	r0, #0
    28fe:	d03e      	beq.n	297e <sendto+0x162>
      if( (sock_io_mode & (1<<sn)) && (len > freesize) ) return SOCK_BUSY;
    2900:	4b26      	ldr	r3, [pc, #152]	; (299c <sendto+0x180>)
    2902:	881b      	ldrh	r3, [r3, #0]
    2904:	412b      	asrs	r3, r5
    2906:	07db      	lsls	r3, r3, #31
    2908:	d5ef      	bpl.n	28ea <sendto+0xce>
    290a:	42a7      	cmp	r7, r4
    290c:	d9ed      	bls.n	28ea <sendto+0xce>
    290e:	2000      	movs	r0, #0
    2910:	e037      	b.n	2982 <sendto+0x166>
   };
	wiz_send_data(sn, buf, len);
    2912:	003a      	movs	r2, r7
    2914:	9903      	ldr	r1, [sp, #12]
    2916:	9801      	ldr	r0, [sp, #4]
    2918:	4b21      	ldr	r3, [pc, #132]	; (29a0 <sendto+0x184>)
    291a:	4798      	blx	r3
//A20150601 : For W5300
#if _WIZCHIP_ == 5300
   setSn_TX_WRSR(sn, len);
#endif
//   
	setSn_CR(sn,Sn_CR_SEND);
    291c:	1c74      	adds	r4, r6, #1
    291e:	34ff      	adds	r4, #255	; 0xff
    2920:	2120      	movs	r1, #32
    2922:	0020      	movs	r0, r4
    2924:	4b1b      	ldr	r3, [pc, #108]	; (2994 <sendto+0x178>)
    2926:	4798      	blx	r3
	/* wait to process the command... */
	while(getSn_CR(sn));
    2928:	0020      	movs	r0, r4
    292a:	4b18      	ldr	r3, [pc, #96]	; (298c <sendto+0x170>)
    292c:	4798      	blx	r3
    292e:	2800      	cmp	r0, #0
    2930:	d1fa      	bne.n	2928 <sendto+0x10c>
   while(1)
   {
      tmp = getSn_IR(sn);
    2932:	2380      	movs	r3, #128	; 0x80
    2934:	009b      	lsls	r3, r3, #2
    2936:	18f4      	adds	r4, r6, r3
    2938:	0020      	movs	r0, r4
    293a:	4b14      	ldr	r3, [pc, #80]	; (298c <sendto+0x170>)
    293c:	4798      	blx	r3
      if(tmp & Sn_IR_SENDOK)
    293e:	06c3      	lsls	r3, r0, #27
    2940:	d408      	bmi.n	2954 <sendto+0x138>
         setSn_IR(sn, Sn_IR_SENDOK);
         break;
      }
      //M:20131104
      //else if(tmp & Sn_IR_TIMEOUT) return SOCKERR_TIMEOUT;
      else if(tmp & Sn_IR_TIMEOUT)
    2942:	0703      	lsls	r3, r0, #28
    2944:	d5f5      	bpl.n	2932 <sendto+0x116>
      {
         setSn_IR(sn, Sn_IR_TIMEOUT);
    2946:	2108      	movs	r1, #8
    2948:	0020      	movs	r0, r4
    294a:	4b12      	ldr	r3, [pc, #72]	; (2994 <sendto+0x178>)
    294c:	4798      	blx	r3
         //len = (uint16_t)SOCKERR_TIMEOUT;
         //break;
         #if _WIZCHIP_ < 5500   //M20150401 : for WIZCHIP Errata #4, #5 (ARP errata)
            if(taddr) setSUBR((uint8_t*)&taddr);
         #endif
         return SOCKERR_TIMEOUT;
    294e:	200d      	movs	r0, #13
    2950:	4240      	negs	r0, r0
    2952:	e016      	b.n	2982 <sendto+0x166>
         setSn_IR(sn, Sn_IR_SENDOK);
    2954:	2110      	movs	r1, #16
    2956:	0020      	movs	r0, r4
    2958:	4b0e      	ldr	r3, [pc, #56]	; (2994 <sendto+0x178>)
    295a:	4798      	blx	r3
   #if _WIZCHIP_ < 5500   //M20150401 : for WIZCHIP Errata #4, #5 (ARP errata)
      if(taddr) setSUBR((uint8_t*)&taddr);
   #endif
   //M20150409 : Explicit Type Casting
   //return len;
   return (int32_t)len;
    295c:	0038      	movs	r0, r7
    295e:	e010      	b.n	2982 <sendto+0x166>
   CHECK_SOCKNUM();
    2960:	2001      	movs	r0, #1
    2962:	4240      	negs	r0, r0
    2964:	e00d      	b.n	2982 <sendto+0x166>
         return SOCKERR_SOCKMODE;
    2966:	2005      	movs	r0, #5
    2968:	4240      	negs	r0, r0
    296a:	e00a      	b.n	2982 <sendto+0x166>
   CHECK_SOCKDATA();
    296c:	200e      	movs	r0, #14
    296e:	4240      	negs	r0, r0
    2970:	e007      	b.n	2982 <sendto+0x166>
   if((port  == 0) && ((getSn_MR(sn)&Sn_MR_MACRAW) != Sn_MR_MACRAW)) return SOCKERR_PORTZERO;
    2972:	200b      	movs	r0, #11
    2974:	4240      	negs	r0, r0
    2976:	e004      	b.n	2982 <sendto+0x166>
   if((tmp != SOCK_MACRAW) && (tmp != SOCK_UDP) && (tmp != SOCK_IPRAW)) return SOCKERR_SOCKSTATUS;
    2978:	2007      	movs	r0, #7
    297a:	4240      	negs	r0, r0
    297c:	e001      	b.n	2982 <sendto+0x166>
      if(getSn_SR(sn) == SOCK_CLOSED) return SOCKERR_SOCKCLOSED;
    297e:	2004      	movs	r0, #4
    2980:	4240      	negs	r0, r0
}
    2982:	b004      	add	sp, #16
    2984:	bc04      	pop	{r2}
    2986:	4693      	mov	fp, r2
    2988:	bdf0      	pop	{r4, r5, r6, r7, pc}
    298a:	46c0      	nop			; (mov r8, r8)
    298c:	00003065 	.word	0x00003065
    2990:	000031a9 	.word	0x000031a9
    2994:	000030c9 	.word	0x000030c9
    2998:	00003221 	.word	0x00003221
    299c:	20000148 	.word	0x20000148
    29a0:	000032f9 	.word	0x000032f9

000029a4 <recvfrom>:



int32_t recvfrom(uint8_t sn, uint8_t * buf, uint16_t len, uint8_t * addr, uint16_t *port)
{
    29a4:	b5f0      	push	{r4, r5, r6, r7, lr}
    29a6:	46de      	mov	lr, fp
    29a8:	4647      	mov	r7, r8
    29aa:	b580      	push	{r7, lr}
    29ac:	b085      	sub	sp, #20
    29ae:	0005      	movs	r5, r0
    29b0:	9100      	str	r1, [sp, #0]
    29b2:	4690      	mov	r8, r2
    29b4:	9301      	str	r3, [sp, #4]
#endif
//   
   uint8_t  head[8];
	uint16_t pack_len=0;

   CHECK_SOCKNUM();
    29b6:	2808      	cmp	r0, #8
    29b8:	d900      	bls.n	29bc <recvfrom+0x18>
    29ba:	e12a      	b.n	2c12 <recvfrom+0x26e>
//A20150601
#if _WIZCHIP_ == 5300
   mr1 = getMR();
#endif   

   switch((mr=getSn_MR(sn)) & 0x0F)
    29bc:	0007      	movs	r7, r0
    29be:	0083      	lsls	r3, r0, #2
    29c0:	3301      	adds	r3, #1
    29c2:	00de      	lsls	r6, r3, #3
    29c4:	0030      	movs	r0, r6
    29c6:	4b99      	ldr	r3, [pc, #612]	; (2c2c <recvfrom+0x288>)
    29c8:	4798      	blx	r3
    29ca:	4683      	mov	fp, r0
    29cc:	230f      	movs	r3, #15
    29ce:	4003      	ands	r3, r0
    29d0:	3b02      	subs	r3, #2
    29d2:	b2db      	uxtb	r3, r3
    29d4:	2b02      	cmp	r3, #2
    29d6:	d900      	bls.n	29da <recvfrom+0x36>
    29d8:	e11e      	b.n	2c18 <recvfrom+0x274>
         break;
   #endif
      default:
         return SOCKERR_SOCKMODE;
   }
   CHECK_SOCKDATA();
    29da:	4643      	mov	r3, r8
    29dc:	2b00      	cmp	r3, #0
    29de:	d100      	bne.n	29e2 <recvfrom+0x3e>
    29e0:	e11d      	b.n	2c1e <recvfrom+0x27a>
   if(sock_remained_size[sn] == 0)
    29e2:	006a      	lsls	r2, r5, #1
    29e4:	4b92      	ldr	r3, [pc, #584]	; (2c30 <recvfrom+0x28c>)
    29e6:	189b      	adds	r3, r3, r2
    29e8:	889b      	ldrh	r3, [r3, #4]
    29ea:	2b00      	cmp	r3, #0
    29ec:	d016      	beq.n	2a1c <recvfrom+0x78>
	uint16_t pack_len=0;
    29ee:	2400      	movs	r4, #0
         if(pack_len != 0) break;
      };
   }
//D20150601 : Move it to bottom
// sock_pack_info[sn] = PACK_COMPLETED;
	switch (mr & 0x07)
    29f0:	2307      	movs	r3, #7
    29f2:	465a      	mov	r2, fp
    29f4:	4013      	ands	r3, r2
    29f6:	2b03      	cmp	r3, #3
    29f8:	d100      	bne.n	29fc <recvfrom+0x58>
    29fa:	e0c7      	b.n	2b8c <recvfrom+0x1e8>
    29fc:	2b04      	cmp	r3, #4
    29fe:	d100      	bne.n	2a02 <recvfrom+0x5e>
    2a00:	e087      	b.n	2b12 <recvfrom+0x16e>
    2a02:	2b02      	cmp	r3, #2
    2a04:	d01f      	beq.n	2a46 <recvfrom+0xa2>
			else pack_len = sock_remained_size[sn];
   		wiz_recv_data(sn, buf, pack_len); // data copy.
			break;
   //#endif
      default:
         wiz_recv_ignore(sn, pack_len); // data copy.
    2a06:	0021      	movs	r1, r4
    2a08:	0028      	movs	r0, r5
    2a0a:	4b8a      	ldr	r3, [pc, #552]	; (2c34 <recvfrom+0x290>)
    2a0c:	4798      	blx	r3
         sock_remained_size[sn] = pack_len;
    2a0e:	006a      	lsls	r2, r5, #1
    2a10:	4b87      	ldr	r3, [pc, #540]	; (2c30 <recvfrom+0x28c>)
    2a12:	189b      	adds	r3, r3, r2
    2a14:	809c      	strh	r4, [r3, #4]
         break;
    2a16:	e028      	b.n	2a6a <recvfrom+0xc6>
         if(pack_len != 0) break;
    2a18:	2c00      	cmp	r4, #0
    2a1a:	d1e9      	bne.n	29f0 <recvfrom+0x4c>
         pack_len = getSn_RX_RSR(sn);
    2a1c:	0028      	movs	r0, r5
    2a1e:	4b86      	ldr	r3, [pc, #536]	; (2c38 <recvfrom+0x294>)
    2a20:	4798      	blx	r3
    2a22:	0004      	movs	r4, r0
         if(getSn_SR(sn) == SOCK_CLOSED) return SOCKERR_SOCKCLOSED;
    2a24:	23c0      	movs	r3, #192	; 0xc0
    2a26:	009b      	lsls	r3, r3, #2
    2a28:	18f0      	adds	r0, r6, r3
    2a2a:	4b80      	ldr	r3, [pc, #512]	; (2c2c <recvfrom+0x288>)
    2a2c:	4798      	blx	r3
    2a2e:	2800      	cmp	r0, #0
    2a30:	d100      	bne.n	2a34 <recvfrom+0x90>
    2a32:	e0f7      	b.n	2c24 <recvfrom+0x280>
         if( (sock_io_mode & (1<<sn)) && (pack_len == 0) ) return SOCK_BUSY;
    2a34:	4b7e      	ldr	r3, [pc, #504]	; (2c30 <recvfrom+0x28c>)
    2a36:	881b      	ldrh	r3, [r3, #0]
    2a38:	413b      	asrs	r3, r7
    2a3a:	07db      	lsls	r3, r3, #31
    2a3c:	d5ec      	bpl.n	2a18 <recvfrom+0x74>
    2a3e:	2c00      	cmp	r4, #0
    2a40:	d1ea      	bne.n	2a18 <recvfrom+0x74>
    2a42:	2000      	movs	r0, #0
    2a44:	e02d      	b.n	2aa2 <recvfrom+0xfe>
	      if(sock_remained_size[sn] == 0)
    2a46:	006a      	lsls	r2, r5, #1
    2a48:	4b79      	ldr	r3, [pc, #484]	; (2c30 <recvfrom+0x28c>)
    2a4a:	189b      	adds	r3, r3, r2
    2a4c:	889b      	ldrh	r3, [r3, #4]
    2a4e:	2b00      	cmp	r3, #0
    2a50:	d02c      	beq.n	2aac <recvfrom+0x108>
			if(len < sock_remained_size[sn]) pack_len = len;
    2a52:	006a      	lsls	r2, r5, #1
    2a54:	4b76      	ldr	r3, [pc, #472]	; (2c30 <recvfrom+0x28c>)
    2a56:	189b      	adds	r3, r3, r2
    2a58:	889c      	ldrh	r4, [r3, #4]
    2a5a:	45a0      	cmp	r8, r4
    2a5c:	d200      	bcs.n	2a60 <recvfrom+0xbc>
    2a5e:	4644      	mov	r4, r8
   		wiz_recv_data(sn, buf, pack_len); // data copy.
    2a60:	0022      	movs	r2, r4
    2a62:	9900      	ldr	r1, [sp, #0]
    2a64:	0028      	movs	r0, r5
    2a66:	4b75      	ldr	r3, [pc, #468]	; (2c3c <recvfrom+0x298>)
    2a68:	4798      	blx	r3
   }
	setSn_CR(sn,Sn_CR_RECV);
    2a6a:	3601      	adds	r6, #1
    2a6c:	36ff      	adds	r6, #255	; 0xff
    2a6e:	2140      	movs	r1, #64	; 0x40
    2a70:	0030      	movs	r0, r6
    2a72:	4b73      	ldr	r3, [pc, #460]	; (2c40 <recvfrom+0x29c>)
    2a74:	4798      	blx	r3
	/* wait to process the command... */
	while(getSn_CR(sn)) ;
    2a76:	0030      	movs	r0, r6
    2a78:	4b6c      	ldr	r3, [pc, #432]	; (2c2c <recvfrom+0x288>)
    2a7a:	4798      	blx	r3
    2a7c:	2800      	cmp	r0, #0
    2a7e:	d1fa      	bne.n	2a76 <recvfrom+0xd2>
	sock_remained_size[sn] -= pack_len;
    2a80:	006b      	lsls	r3, r5, #1
    2a82:	4a6b      	ldr	r2, [pc, #428]	; (2c30 <recvfrom+0x28c>)
    2a84:	18d2      	adds	r2, r2, r3
    2a86:	8893      	ldrh	r3, [r2, #4]
    2a88:	1b1b      	subs	r3, r3, r4
    2a8a:	b29b      	uxth	r3, r3
    2a8c:	8093      	strh	r3, [r2, #4]
	//M20150601 : 
	//if(sock_remained_size[sn] != 0) sock_pack_info[sn] |= 0x01;
	if(sock_remained_size[sn] != 0)
    2a8e:	2b00      	cmp	r3, #0
    2a90:	d100      	bne.n	2a94 <recvfrom+0xf0>
    2a92:	e0b9      	b.n	2c08 <recvfrom+0x264>
	{
	   sock_pack_info[sn] |= PACK_REMAINED;
    2a94:	4b66      	ldr	r3, [pc, #408]	; (2c30 <recvfrom+0x28c>)
    2a96:	195d      	adds	r5, r3, r5
    2a98:	7d2b      	ldrb	r3, [r5, #20]
    2a9a:	2201      	movs	r2, #1
    2a9c:	4313      	orrs	r3, r2
    2a9e:	752b      	strb	r3, [r5, #20]
   pack_len = len;
#endif
   //
   //M20150409 : Explicit Type Casting
   //return pack_len;
   return (int32_t)pack_len;
    2aa0:	0020      	movs	r0, r4
}
    2aa2:	b005      	add	sp, #20
    2aa4:	bc0c      	pop	{r2, r3}
    2aa6:	4690      	mov	r8, r2
    2aa8:	469b      	mov	fp, r3
    2aaa:	bdf0      	pop	{r4, r5, r6, r7, pc}
   			wiz_recv_data(sn, head, 8);
    2aac:	2208      	movs	r2, #8
    2aae:	a902      	add	r1, sp, #8
    2ab0:	0028      	movs	r0, r5
    2ab2:	4b62      	ldr	r3, [pc, #392]	; (2c3c <recvfrom+0x298>)
    2ab4:	4798      	blx	r3
   			setSn_CR(sn,Sn_CR_RECV);
    2ab6:	1c74      	adds	r4, r6, #1
    2ab8:	34ff      	adds	r4, #255	; 0xff
    2aba:	2140      	movs	r1, #64	; 0x40
    2abc:	0020      	movs	r0, r4
    2abe:	4b60      	ldr	r3, [pc, #384]	; (2c40 <recvfrom+0x29c>)
    2ac0:	4798      	blx	r3
   			while(getSn_CR(sn));
    2ac2:	0020      	movs	r0, r4
    2ac4:	4b59      	ldr	r3, [pc, #356]	; (2c2c <recvfrom+0x288>)
    2ac6:	4798      	blx	r3
    2ac8:	2800      	cmp	r0, #0
    2aca:	d1fa      	bne.n	2ac2 <recvfrom+0x11e>
               addr[0] = head[0];
    2acc:	ab02      	add	r3, sp, #8
    2ace:	781b      	ldrb	r3, [r3, #0]
    2ad0:	9a01      	ldr	r2, [sp, #4]
    2ad2:	7013      	strb	r3, [r2, #0]
      			addr[1] = head[1];
    2ad4:	ab02      	add	r3, sp, #8
    2ad6:	785b      	ldrb	r3, [r3, #1]
    2ad8:	7053      	strb	r3, [r2, #1]
      			addr[2] = head[2];
    2ada:	ab02      	add	r3, sp, #8
    2adc:	789b      	ldrb	r3, [r3, #2]
    2ade:	7093      	strb	r3, [r2, #2]
      			addr[3] = head[3];
    2ae0:	ab02      	add	r3, sp, #8
    2ae2:	78db      	ldrb	r3, [r3, #3]
    2ae4:	70d3      	strb	r3, [r2, #3]
      			*port = head[4];
    2ae6:	ab02      	add	r3, sp, #8
    2ae8:	791b      	ldrb	r3, [r3, #4]
      			*port = (*port << 8) + head[5];
    2aea:	021b      	lsls	r3, r3, #8
    2aec:	aa02      	add	r2, sp, #8
    2aee:	7952      	ldrb	r2, [r2, #5]
    2af0:	189b      	adds	r3, r3, r2
    2af2:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    2af4:	8013      	strh	r3, [r2, #0]
      			sock_remained_size[sn] = head[6];
    2af6:	ab02      	add	r3, sp, #8
    2af8:	799b      	ldrb	r3, [r3, #6]
      			sock_remained_size[sn] = (sock_remained_size[sn] << 8) + head[7];
    2afa:	021b      	lsls	r3, r3, #8
    2afc:	aa02      	add	r2, sp, #8
    2afe:	79d2      	ldrb	r2, [r2, #7]
    2b00:	189b      	adds	r3, r3, r2
    2b02:	4a4b      	ldr	r2, [pc, #300]	; (2c30 <recvfrom+0x28c>)
    2b04:	0069      	lsls	r1, r5, #1
    2b06:	1851      	adds	r1, r2, r1
    2b08:	808b      	strh	r3, [r1, #4]
   			sock_pack_info[sn] = PACK_FIRST;
    2b0a:	1952      	adds	r2, r2, r5
    2b0c:	2380      	movs	r3, #128	; 0x80
    2b0e:	7513      	strb	r3, [r2, #20]
    2b10:	e79f      	b.n	2a52 <recvfrom+0xae>
	      if(sock_remained_size[sn] == 0)
    2b12:	006a      	lsls	r2, r5, #1
    2b14:	4b46      	ldr	r3, [pc, #280]	; (2c30 <recvfrom+0x28c>)
    2b16:	189b      	adds	r3, r3, r2
    2b18:	889b      	ldrh	r3, [r3, #4]
    2b1a:	2b00      	cmp	r3, #0
    2b1c:	d00c      	beq.n	2b38 <recvfrom+0x194>
			if(len < sock_remained_size[sn]) pack_len = len;
    2b1e:	006a      	lsls	r2, r5, #1
    2b20:	4b43      	ldr	r3, [pc, #268]	; (2c30 <recvfrom+0x28c>)
    2b22:	189b      	adds	r3, r3, r2
    2b24:	889c      	ldrh	r4, [r3, #4]
    2b26:	45a0      	cmp	r8, r4
    2b28:	d200      	bcs.n	2b2c <recvfrom+0x188>
    2b2a:	4644      	mov	r4, r8
			wiz_recv_data(sn,buf,pack_len);
    2b2c:	0022      	movs	r2, r4
    2b2e:	9900      	ldr	r1, [sp, #0]
    2b30:	0028      	movs	r0, r5
    2b32:	4b42      	ldr	r3, [pc, #264]	; (2c3c <recvfrom+0x298>)
    2b34:	4798      	blx	r3
		   break;
    2b36:	e798      	b.n	2a6a <recvfrom+0xc6>
   			wiz_recv_data(sn, head, 2);
    2b38:	2202      	movs	r2, #2
    2b3a:	a902      	add	r1, sp, #8
    2b3c:	0028      	movs	r0, r5
    2b3e:	4b3f      	ldr	r3, [pc, #252]	; (2c3c <recvfrom+0x298>)
    2b40:	4798      	blx	r3
   			setSn_CR(sn,Sn_CR_RECV);
    2b42:	1c74      	adds	r4, r6, #1
    2b44:	34ff      	adds	r4, #255	; 0xff
    2b46:	2140      	movs	r1, #64	; 0x40
    2b48:	0020      	movs	r0, r4
    2b4a:	4b3d      	ldr	r3, [pc, #244]	; (2c40 <recvfrom+0x29c>)
    2b4c:	4798      	blx	r3
   			while(getSn_CR(sn));
    2b4e:	0020      	movs	r0, r4
    2b50:	4b36      	ldr	r3, [pc, #216]	; (2c2c <recvfrom+0x288>)
    2b52:	4798      	blx	r3
    2b54:	2800      	cmp	r0, #0
    2b56:	d1fa      	bne.n	2b4e <recvfrom+0x1aa>
    			sock_remained_size[sn] = head[0];
    2b58:	ab02      	add	r3, sp, #8
    2b5a:	781b      	ldrb	r3, [r3, #0]
   			sock_remained_size[sn] = (sock_remained_size[sn] <<8) + head[1] -2;
    2b5c:	021b      	lsls	r3, r3, #8
    2b5e:	aa02      	add	r2, sp, #8
    2b60:	7852      	ldrb	r2, [r2, #1]
    2b62:	189b      	adds	r3, r3, r2
    2b64:	b29b      	uxth	r3, r3
    2b66:	3b02      	subs	r3, #2
    2b68:	b29b      	uxth	r3, r3
    2b6a:	0069      	lsls	r1, r5, #1
    2b6c:	4a30      	ldr	r2, [pc, #192]	; (2c30 <recvfrom+0x28c>)
    2b6e:	1852      	adds	r2, r2, r1
    2b70:	8093      	strh	r3, [r2, #4]
   			if(sock_remained_size[sn] > 1514) 
    2b72:	4a34      	ldr	r2, [pc, #208]	; (2c44 <recvfrom+0x2a0>)
    2b74:	4293      	cmp	r3, r2
    2b76:	d804      	bhi.n	2b82 <recvfrom+0x1de>
   			sock_pack_info[sn] = PACK_FIRST;
    2b78:	4b2d      	ldr	r3, [pc, #180]	; (2c30 <recvfrom+0x28c>)
    2b7a:	195b      	adds	r3, r3, r5
    2b7c:	2280      	movs	r2, #128	; 0x80
    2b7e:	751a      	strb	r2, [r3, #20]
    2b80:	e7cd      	b.n	2b1e <recvfrom+0x17a>
   			   close(sn);
    2b82:	0028      	movs	r0, r5
    2b84:	4b30      	ldr	r3, [pc, #192]	; (2c48 <recvfrom+0x2a4>)
    2b86:	4798      	blx	r3
   			   return SOCKFATAL_PACKLEN;
    2b88:	4830      	ldr	r0, [pc, #192]	; (2c4c <recvfrom+0x2a8>)
    2b8a:	e78a      	b.n	2aa2 <recvfrom+0xfe>
		   if(sock_remained_size[sn] == 0)
    2b8c:	006a      	lsls	r2, r5, #1
    2b8e:	4b28      	ldr	r3, [pc, #160]	; (2c30 <recvfrom+0x28c>)
    2b90:	189b      	adds	r3, r3, r2
    2b92:	889b      	ldrh	r3, [r3, #4]
    2b94:	2b00      	cmp	r3, #0
    2b96:	d00c      	beq.n	2bb2 <recvfrom+0x20e>
			if(len < sock_remained_size[sn]) pack_len = len;
    2b98:	006a      	lsls	r2, r5, #1
    2b9a:	4b25      	ldr	r3, [pc, #148]	; (2c30 <recvfrom+0x28c>)
    2b9c:	189b      	adds	r3, r3, r2
    2b9e:	889c      	ldrh	r4, [r3, #4]
    2ba0:	45a0      	cmp	r8, r4
    2ba2:	d200      	bcs.n	2ba6 <recvfrom+0x202>
    2ba4:	4644      	mov	r4, r8
   		wiz_recv_data(sn, buf, pack_len); // data copy.
    2ba6:	0022      	movs	r2, r4
    2ba8:	9900      	ldr	r1, [sp, #0]
    2baa:	0028      	movs	r0, r5
    2bac:	4b23      	ldr	r3, [pc, #140]	; (2c3c <recvfrom+0x298>)
    2bae:	4798      	blx	r3
			break;
    2bb0:	e75b      	b.n	2a6a <recvfrom+0xc6>
   			wiz_recv_data(sn, head, 6);
    2bb2:	2206      	movs	r2, #6
    2bb4:	a902      	add	r1, sp, #8
    2bb6:	0028      	movs	r0, r5
    2bb8:	4b20      	ldr	r3, [pc, #128]	; (2c3c <recvfrom+0x298>)
    2bba:	4798      	blx	r3
   			setSn_CR(sn,Sn_CR_RECV);
    2bbc:	1c74      	adds	r4, r6, #1
    2bbe:	34ff      	adds	r4, #255	; 0xff
    2bc0:	2140      	movs	r1, #64	; 0x40
    2bc2:	0020      	movs	r0, r4
    2bc4:	4b1e      	ldr	r3, [pc, #120]	; (2c40 <recvfrom+0x29c>)
    2bc6:	4798      	blx	r3
   			while(getSn_CR(sn));
    2bc8:	0020      	movs	r0, r4
    2bca:	4b18      	ldr	r3, [pc, #96]	; (2c2c <recvfrom+0x288>)
    2bcc:	4798      	blx	r3
    2bce:	2800      	cmp	r0, #0
    2bd0:	d1fa      	bne.n	2bc8 <recvfrom+0x224>
   			addr[0] = head[0];
    2bd2:	ab02      	add	r3, sp, #8
    2bd4:	781b      	ldrb	r3, [r3, #0]
    2bd6:	9a01      	ldr	r2, [sp, #4]
    2bd8:	7013      	strb	r3, [r2, #0]
   			addr[1] = head[1];
    2bda:	ab02      	add	r3, sp, #8
    2bdc:	785b      	ldrb	r3, [r3, #1]
    2bde:	7053      	strb	r3, [r2, #1]
   			addr[2] = head[2];
    2be0:	ab02      	add	r3, sp, #8
    2be2:	789b      	ldrb	r3, [r3, #2]
    2be4:	7093      	strb	r3, [r2, #2]
   			addr[3] = head[3];
    2be6:	ab02      	add	r3, sp, #8
    2be8:	78db      	ldrb	r3, [r3, #3]
    2bea:	70d3      	strb	r3, [r2, #3]
   			sock_remained_size[sn] = head[4];
    2bec:	ab02      	add	r3, sp, #8
    2bee:	791b      	ldrb	r3, [r3, #4]
   			sock_remained_size[sn] = (sock_remained_size[sn] << 8) + head[5];
    2bf0:	021b      	lsls	r3, r3, #8
    2bf2:	aa02      	add	r2, sp, #8
    2bf4:	7952      	ldrb	r2, [r2, #5]
    2bf6:	189b      	adds	r3, r3, r2
    2bf8:	4a0d      	ldr	r2, [pc, #52]	; (2c30 <recvfrom+0x28c>)
    2bfa:	0069      	lsls	r1, r5, #1
    2bfc:	1851      	adds	r1, r2, r1
    2bfe:	808b      	strh	r3, [r1, #4]
   			sock_pack_info[sn] = PACK_FIRST;
    2c00:	1952      	adds	r2, r2, r5
    2c02:	2380      	movs	r3, #128	; 0x80
    2c04:	7513      	strb	r3, [r2, #20]
    2c06:	e7c7      	b.n	2b98 <recvfrom+0x1f4>
	else sock_pack_info[sn] = PACK_COMPLETED;
    2c08:	4b09      	ldr	r3, [pc, #36]	; (2c30 <recvfrom+0x28c>)
    2c0a:	195d      	adds	r5, r3, r5
    2c0c:	2300      	movs	r3, #0
    2c0e:	752b      	strb	r3, [r5, #20]
    2c10:	e746      	b.n	2aa0 <recvfrom+0xfc>
   CHECK_SOCKNUM();
    2c12:	2001      	movs	r0, #1
    2c14:	4240      	negs	r0, r0
    2c16:	e744      	b.n	2aa2 <recvfrom+0xfe>
         return SOCKERR_SOCKMODE;
    2c18:	2005      	movs	r0, #5
    2c1a:	4240      	negs	r0, r0
    2c1c:	e741      	b.n	2aa2 <recvfrom+0xfe>
   CHECK_SOCKDATA();
    2c1e:	200e      	movs	r0, #14
    2c20:	4240      	negs	r0, r0
    2c22:	e73e      	b.n	2aa2 <recvfrom+0xfe>
         if(getSn_SR(sn) == SOCK_CLOSED) return SOCKERR_SOCKCLOSED;
    2c24:	2004      	movs	r0, #4
    2c26:	4240      	negs	r0, r0
    2c28:	e73b      	b.n	2aa2 <recvfrom+0xfe>
    2c2a:	46c0      	nop			; (mov r8, r8)
    2c2c:	00003065 	.word	0x00003065
    2c30:	20000148 	.word	0x20000148
    2c34:	000033e9 	.word	0x000033e9
    2c38:	0000328d 	.word	0x0000328d
    2c3c:	00003371 	.word	0x00003371
    2c40:	000030c9 	.word	0x000030c9
    2c44:	000005ea 	.word	0x000005ea
    2c48:	000022cd 	.word	0x000022cd
    2c4c:	fffffc17 	.word	0xfffffc17

00002c50 <ctlsocket>:


int8_t  ctlsocket(uint8_t sn, ctlsock_type cstype, void* arg)
{
    2c50:	b510      	push	{r4, lr}
    2c52:	0014      	movs	r4, r2
   uint8_t tmp = 0;
   CHECK_SOCKNUM();
    2c54:	2808      	cmp	r0, #8
    2c56:	d900      	bls.n	2c5a <ctlsocket+0xa>
    2c58:	e07c      	b.n	2d54 <ctlsocket+0x104>
   switch(cstype)
    2c5a:	2907      	cmp	r1, #7
    2c5c:	d900      	bls.n	2c60 <ctlsocket+0x10>
    2c5e:	e07c      	b.n	2d5a <ctlsocket+0x10a>
    2c60:	0089      	lsls	r1, r1, #2
    2c62:	4b44      	ldr	r3, [pc, #272]	; (2d74 <ctlsocket+0x124>)
    2c64:	585b      	ldr	r3, [r3, r1]
    2c66:	469f      	mov	pc, r3
   {
      case CS_SET_IOMODE:
         tmp = *((uint8_t*)arg);
    2c68:	7813      	ldrb	r3, [r2, #0]
         if(tmp == SOCK_IO_NONBLOCK)  sock_io_mode |= (1<<sn);
    2c6a:	2b01      	cmp	r3, #1
    2c6c:	d00a      	beq.n	2c84 <ctlsocket+0x34>
         else if(tmp == SOCK_IO_BLOCK) sock_io_mode &= ~(1<<sn);
    2c6e:	2b00      	cmp	r3, #0
    2c70:	d000      	beq.n	2c74 <ctlsocket+0x24>
    2c72:	e075      	b.n	2d60 <ctlsocket+0x110>
    2c74:	2201      	movs	r2, #1
    2c76:	4082      	lsls	r2, r0
    2c78:	493f      	ldr	r1, [pc, #252]	; (2d78 <ctlsocket+0x128>)
    2c7a:	880b      	ldrh	r3, [r1, #0]
    2c7c:	4393      	bics	r3, r2
    2c7e:	800b      	strh	r3, [r1, #0]
         break;
   #endif
      default:
         return SOCKERR_ARG;
   }
   return SOCK_OK;
    2c80:	2001      	movs	r0, #1
    2c82:	e00e      	b.n	2ca2 <ctlsocket+0x52>
         if(tmp == SOCK_IO_NONBLOCK)  sock_io_mode |= (1<<sn);
    2c84:	2201      	movs	r2, #1
    2c86:	4082      	lsls	r2, r0
    2c88:	493b      	ldr	r1, [pc, #236]	; (2d78 <ctlsocket+0x128>)
    2c8a:	880b      	ldrh	r3, [r1, #0]
    2c8c:	4313      	orrs	r3, r2
    2c8e:	800b      	strh	r3, [r1, #0]
   return SOCK_OK;
    2c90:	2001      	movs	r0, #1
    2c92:	e006      	b.n	2ca2 <ctlsocket+0x52>
         *((uint8_t*)arg) = (uint8_t)((sock_io_mode >> sn) & 0x0001);
    2c94:	4b38      	ldr	r3, [pc, #224]	; (2d78 <ctlsocket+0x128>)
    2c96:	881b      	ldrh	r3, [r3, #0]
    2c98:	4103      	asrs	r3, r0
    2c9a:	2201      	movs	r2, #1
    2c9c:	4013      	ands	r3, r2
    2c9e:	7023      	strb	r3, [r4, #0]
   return SOCK_OK;
    2ca0:	2001      	movs	r0, #1
}
    2ca2:	bd10      	pop	{r4, pc}
         *((uint16_t*)arg) = getSn_TxMAX(sn);
    2ca4:	0080      	lsls	r0, r0, #2
    2ca6:	3001      	adds	r0, #1
    2ca8:	00c0      	lsls	r0, r0, #3
    2caa:	23f8      	movs	r3, #248	; 0xf8
    2cac:	015b      	lsls	r3, r3, #5
    2cae:	469c      	mov	ip, r3
    2cb0:	4460      	add	r0, ip
    2cb2:	4b32      	ldr	r3, [pc, #200]	; (2d7c <ctlsocket+0x12c>)
    2cb4:	4798      	blx	r3
    2cb6:	b280      	uxth	r0, r0
    2cb8:	0280      	lsls	r0, r0, #10
    2cba:	8020      	strh	r0, [r4, #0]
   return SOCK_OK;
    2cbc:	2001      	movs	r0, #1
         break;
    2cbe:	e7f0      	b.n	2ca2 <ctlsocket+0x52>
         *((uint16_t*)arg) = getSn_RxMAX(sn);
    2cc0:	0080      	lsls	r0, r0, #2
    2cc2:	3001      	adds	r0, #1
    2cc4:	00c0      	lsls	r0, r0, #3
    2cc6:	23f0      	movs	r3, #240	; 0xf0
    2cc8:	015b      	lsls	r3, r3, #5
    2cca:	469c      	mov	ip, r3
    2ccc:	4460      	add	r0, ip
    2cce:	4b2b      	ldr	r3, [pc, #172]	; (2d7c <ctlsocket+0x12c>)
    2cd0:	4798      	blx	r3
    2cd2:	b280      	uxth	r0, r0
    2cd4:	0280      	lsls	r0, r0, #10
    2cd6:	8020      	strh	r0, [r4, #0]
   return SOCK_OK;
    2cd8:	2001      	movs	r0, #1
         break;
    2cda:	e7e2      	b.n	2ca2 <ctlsocket+0x52>
         if( (*(uint8_t*)arg) > SIK_ALL) return SOCKERR_ARG;
    2cdc:	7813      	ldrb	r3, [r2, #0]
    2cde:	2b1f      	cmp	r3, #31
    2ce0:	d841      	bhi.n	2d66 <ctlsocket+0x116>
         setSn_IR(sn,*(uint8_t*)arg);
    2ce2:	0080      	lsls	r0, r0, #2
    2ce4:	3001      	adds	r0, #1
    2ce6:	00c0      	lsls	r0, r0, #3
    2ce8:	2280      	movs	r2, #128	; 0x80
    2cea:	0092      	lsls	r2, r2, #2
    2cec:	4694      	mov	ip, r2
    2cee:	4460      	add	r0, ip
    2cf0:	211f      	movs	r1, #31
    2cf2:	4019      	ands	r1, r3
    2cf4:	4b22      	ldr	r3, [pc, #136]	; (2d80 <ctlsocket+0x130>)
    2cf6:	4798      	blx	r3
   return SOCK_OK;
    2cf8:	2001      	movs	r0, #1
         break;
    2cfa:	e7d2      	b.n	2ca2 <ctlsocket+0x52>
         *((uint8_t*)arg) = getSn_IR(sn);
    2cfc:	0080      	lsls	r0, r0, #2
    2cfe:	3001      	adds	r0, #1
    2d00:	00c0      	lsls	r0, r0, #3
    2d02:	2380      	movs	r3, #128	; 0x80
    2d04:	009b      	lsls	r3, r3, #2
    2d06:	469c      	mov	ip, r3
    2d08:	4460      	add	r0, ip
    2d0a:	4b1c      	ldr	r3, [pc, #112]	; (2d7c <ctlsocket+0x12c>)
    2d0c:	4798      	blx	r3
    2d0e:	231f      	movs	r3, #31
    2d10:	4018      	ands	r0, r3
    2d12:	7020      	strb	r0, [r4, #0]
   return SOCK_OK;
    2d14:	2001      	movs	r0, #1
         break;
    2d16:	e7c4      	b.n	2ca2 <ctlsocket+0x52>
         if( (*(uint8_t*)arg) > SIK_ALL) return SOCKERR_ARG;
    2d18:	7813      	ldrb	r3, [r2, #0]
    2d1a:	2b1f      	cmp	r3, #31
    2d1c:	d826      	bhi.n	2d6c <ctlsocket+0x11c>
         setSn_IMR(sn,*(uint8_t*)arg);
    2d1e:	0080      	lsls	r0, r0, #2
    2d20:	3001      	adds	r0, #1
    2d22:	00c0      	lsls	r0, r0, #3
    2d24:	22b0      	movs	r2, #176	; 0xb0
    2d26:	0192      	lsls	r2, r2, #6
    2d28:	4694      	mov	ip, r2
    2d2a:	4460      	add	r0, ip
    2d2c:	211f      	movs	r1, #31
    2d2e:	4019      	ands	r1, r3
    2d30:	4b13      	ldr	r3, [pc, #76]	; (2d80 <ctlsocket+0x130>)
    2d32:	4798      	blx	r3
   return SOCK_OK;
    2d34:	2001      	movs	r0, #1
         break;
    2d36:	e7b4      	b.n	2ca2 <ctlsocket+0x52>
         *((uint8_t*)arg) = getSn_IMR(sn);
    2d38:	0080      	lsls	r0, r0, #2
    2d3a:	3001      	adds	r0, #1
    2d3c:	00c0      	lsls	r0, r0, #3
    2d3e:	23b0      	movs	r3, #176	; 0xb0
    2d40:	019b      	lsls	r3, r3, #6
    2d42:	469c      	mov	ip, r3
    2d44:	4460      	add	r0, ip
    2d46:	4b0d      	ldr	r3, [pc, #52]	; (2d7c <ctlsocket+0x12c>)
    2d48:	4798      	blx	r3
    2d4a:	231f      	movs	r3, #31
    2d4c:	4018      	ands	r0, r3
    2d4e:	7020      	strb	r0, [r4, #0]
   return SOCK_OK;
    2d50:	2001      	movs	r0, #1
         break;
    2d52:	e7a6      	b.n	2ca2 <ctlsocket+0x52>
   CHECK_SOCKNUM();
    2d54:	2001      	movs	r0, #1
    2d56:	4240      	negs	r0, r0
    2d58:	e7a3      	b.n	2ca2 <ctlsocket+0x52>
         return SOCKERR_ARG;
    2d5a:	200a      	movs	r0, #10
    2d5c:	4240      	negs	r0, r0
    2d5e:	e7a0      	b.n	2ca2 <ctlsocket+0x52>
         else return SOCKERR_ARG;
    2d60:	200a      	movs	r0, #10
    2d62:	4240      	negs	r0, r0
    2d64:	e79d      	b.n	2ca2 <ctlsocket+0x52>
         if( (*(uint8_t*)arg) > SIK_ALL) return SOCKERR_ARG;
    2d66:	200a      	movs	r0, #10
    2d68:	4240      	negs	r0, r0
    2d6a:	e79a      	b.n	2ca2 <ctlsocket+0x52>
         if( (*(uint8_t*)arg) > SIK_ALL) return SOCKERR_ARG;
    2d6c:	200a      	movs	r0, #10
    2d6e:	4240      	negs	r0, r0
    2d70:	e797      	b.n	2ca2 <ctlsocket+0x52>
    2d72:	46c0      	nop			; (mov r8, r8)
    2d74:	00004ae4 	.word	0x00004ae4
    2d78:	20000148 	.word	0x20000148
    2d7c:	00003065 	.word	0x00003065
    2d80:	000030c9 	.word	0x000030c9

00002d84 <setsockopt>:

int8_t  setsockopt(uint8_t sn, sockopt_type sotype, void* arg)
{
    2d84:	b570      	push	{r4, r5, r6, lr}
    2d86:	0015      	movs	r5, r2
 // M20131220 : Remove warning
 //uint8_t tmp;
   CHECK_SOCKNUM();
    2d88:	2808      	cmp	r0, #8
    2d8a:	d900      	bls.n	2d8e <setsockopt+0xa>
    2d8c:	e08c      	b.n	2ea8 <setsockopt+0x124>
   switch(sotype)
    2d8e:	2907      	cmp	r1, #7
    2d90:	d900      	bls.n	2d94 <setsockopt+0x10>
    2d92:	e08c      	b.n	2eae <setsockopt+0x12a>
    2d94:	0089      	lsls	r1, r1, #2
    2d96:	4b4c      	ldr	r3, [pc, #304]	; (2ec8 <setsockopt+0x144>)
    2d98:	585b      	ldr	r3, [r3, r1]
    2d9a:	469f      	mov	pc, r3
   {
      case SO_TTL:
         setSn_TTL(sn,*(uint8_t*)arg);
    2d9c:	0080      	lsls	r0, r0, #2
    2d9e:	3001      	adds	r0, #1
    2da0:	00c0      	lsls	r0, r0, #3
    2da2:	23b0      	movs	r3, #176	; 0xb0
    2da4:	015b      	lsls	r3, r3, #5
    2da6:	469c      	mov	ip, r3
    2da8:	4460      	add	r0, ip
    2daa:	7811      	ldrb	r1, [r2, #0]
    2dac:	4b47      	ldr	r3, [pc, #284]	; (2ecc <setsockopt+0x148>)
    2dae:	4798      	blx	r3
   #endif      
#endif   
      default:
         return SOCKERR_ARG;
   }   
   return SOCK_OK;
    2db0:	2001      	movs	r0, #1
}
    2db2:	bd70      	pop	{r4, r5, r6, pc}
         setSn_TOS(sn,*(uint8_t*)arg);
    2db4:	0080      	lsls	r0, r0, #2
    2db6:	3001      	adds	r0, #1
    2db8:	00c0      	lsls	r0, r0, #3
    2dba:	23a8      	movs	r3, #168	; 0xa8
    2dbc:	015b      	lsls	r3, r3, #5
    2dbe:	469c      	mov	ip, r3
    2dc0:	4460      	add	r0, ip
    2dc2:	7811      	ldrb	r1, [r2, #0]
    2dc4:	4b41      	ldr	r3, [pc, #260]	; (2ecc <setsockopt+0x148>)
    2dc6:	4798      	blx	r3
   return SOCK_OK;
    2dc8:	2001      	movs	r0, #1
         break;
    2dca:	e7f2      	b.n	2db2 <setsockopt+0x2e>
         setSn_MSSR(sn,*(uint16_t*)arg);
    2dcc:	0084      	lsls	r4, r0, #2
    2dce:	3401      	adds	r4, #1
    2dd0:	00e4      	lsls	r4, r4, #3
    2dd2:	2390      	movs	r3, #144	; 0x90
    2dd4:	015b      	lsls	r3, r3, #5
    2dd6:	18e0      	adds	r0, r4, r3
    2dd8:	8811      	ldrh	r1, [r2, #0]
    2dda:	0a09      	lsrs	r1, r1, #8
    2ddc:	4e3b      	ldr	r6, [pc, #236]	; (2ecc <setsockopt+0x148>)
    2dde:	47b0      	blx	r6
    2de0:	2398      	movs	r3, #152	; 0x98
    2de2:	015b      	lsls	r3, r3, #5
    2de4:	18e0      	adds	r0, r4, r3
    2de6:	7829      	ldrb	r1, [r5, #0]
    2de8:	47b0      	blx	r6
   return SOCK_OK;
    2dea:	2001      	movs	r0, #1
         break;
    2dec:	e7e1      	b.n	2db2 <setsockopt+0x2e>
         setSn_DIPR(sn, (uint8_t*)arg);
    2dee:	0080      	lsls	r0, r0, #2
    2df0:	3001      	adds	r0, #1
    2df2:	00c0      	lsls	r0, r0, #3
    2df4:	23c0      	movs	r3, #192	; 0xc0
    2df6:	011b      	lsls	r3, r3, #4
    2df8:	469c      	mov	ip, r3
    2dfa:	4460      	add	r0, ip
    2dfc:	2204      	movs	r2, #4
    2dfe:	0029      	movs	r1, r5
    2e00:	4b33      	ldr	r3, [pc, #204]	; (2ed0 <setsockopt+0x14c>)
    2e02:	4798      	blx	r3
   return SOCK_OK;
    2e04:	2001      	movs	r0, #1
         break;
    2e06:	e7d4      	b.n	2db2 <setsockopt+0x2e>
         setSn_DPORT(sn, *(uint16_t*)arg);
    2e08:	0084      	lsls	r4, r0, #2
    2e0a:	3401      	adds	r4, #1
    2e0c:	00e4      	lsls	r4, r4, #3
    2e0e:	2380      	movs	r3, #128	; 0x80
    2e10:	015b      	lsls	r3, r3, #5
    2e12:	18e0      	adds	r0, r4, r3
    2e14:	8811      	ldrh	r1, [r2, #0]
    2e16:	0a09      	lsrs	r1, r1, #8
    2e18:	4e2c      	ldr	r6, [pc, #176]	; (2ecc <setsockopt+0x148>)
    2e1a:	47b0      	blx	r6
    2e1c:	2388      	movs	r3, #136	; 0x88
    2e1e:	015b      	lsls	r3, r3, #5
    2e20:	18e0      	adds	r0, r4, r3
    2e22:	7829      	ldrb	r1, [r5, #0]
    2e24:	47b0      	blx	r6
   return SOCK_OK;
    2e26:	2001      	movs	r0, #1
         break;
    2e28:	e7c3      	b.n	2db2 <setsockopt+0x2e>
         CHECK_SOCKMODE(Sn_MR_TCP);
    2e2a:	0084      	lsls	r4, r0, #2
    2e2c:	3401      	adds	r4, #1
    2e2e:	00e4      	lsls	r4, r4, #3
    2e30:	0020      	movs	r0, r4
    2e32:	4b28      	ldr	r3, [pc, #160]	; (2ed4 <setsockopt+0x150>)
    2e34:	4798      	blx	r3
    2e36:	230f      	movs	r3, #15
    2e38:	4018      	ands	r0, r3
    2e3a:	2801      	cmp	r0, #1
    2e3c:	d13a      	bne.n	2eb4 <setsockopt+0x130>
            if(getSn_KPALVTR(sn) != 0) return SOCKERR_SOCKOPT;
    2e3e:	23bc      	movs	r3, #188	; 0xbc
    2e40:	019b      	lsls	r3, r3, #6
    2e42:	18e0      	adds	r0, r4, r3
    2e44:	4b23      	ldr	r3, [pc, #140]	; (2ed4 <setsockopt+0x150>)
    2e46:	4798      	blx	r3
    2e48:	2800      	cmp	r0, #0
    2e4a:	d136      	bne.n	2eba <setsockopt+0x136>
            setSn_CR(sn,Sn_CR_SEND_KEEP);
    2e4c:	1c65      	adds	r5, r4, #1
    2e4e:	35ff      	adds	r5, #255	; 0xff
    2e50:	2122      	movs	r1, #34	; 0x22
    2e52:	0028      	movs	r0, r5
    2e54:	4b1d      	ldr	r3, [pc, #116]	; (2ecc <setsockopt+0x148>)
    2e56:	4798      	blx	r3
            while(getSn_CR(sn) != 0)
    2e58:	0028      	movs	r0, r5
    2e5a:	4b1e      	ldr	r3, [pc, #120]	; (2ed4 <setsockopt+0x150>)
    2e5c:	4798      	blx	r3
    2e5e:	2800      	cmp	r0, #0
    2e60:	d00e      	beq.n	2e80 <setsockopt+0xfc>
               if (getSn_IR(sn) & Sn_IR_TIMEOUT)
    2e62:	2380      	movs	r3, #128	; 0x80
    2e64:	009b      	lsls	r3, r3, #2
    2e66:	18e6      	adds	r6, r4, r3
    2e68:	0030      	movs	r0, r6
    2e6a:	4b1a      	ldr	r3, [pc, #104]	; (2ed4 <setsockopt+0x150>)
    2e6c:	4798      	blx	r3
    2e6e:	0703      	lsls	r3, r0, #28
    2e70:	d5f2      	bpl.n	2e58 <setsockopt+0xd4>
         			setSn_IR(sn, Sn_IR_TIMEOUT);
    2e72:	2108      	movs	r1, #8
    2e74:	0030      	movs	r0, r6
    2e76:	4b15      	ldr	r3, [pc, #84]	; (2ecc <setsockopt+0x148>)
    2e78:	4798      	blx	r3
                  return SOCKERR_TIMEOUT;
    2e7a:	200d      	movs	r0, #13
    2e7c:	4240      	negs	r0, r0
    2e7e:	e798      	b.n	2db2 <setsockopt+0x2e>
   return SOCK_OK;
    2e80:	3001      	adds	r0, #1
    2e82:	e796      	b.n	2db2 <setsockopt+0x2e>
         CHECK_SOCKMODE(Sn_MR_TCP);
    2e84:	0084      	lsls	r4, r0, #2
    2e86:	3401      	adds	r4, #1
    2e88:	00e4      	lsls	r4, r4, #3
    2e8a:	0020      	movs	r0, r4
    2e8c:	4b11      	ldr	r3, [pc, #68]	; (2ed4 <setsockopt+0x150>)
    2e8e:	4798      	blx	r3
    2e90:	230f      	movs	r3, #15
    2e92:	4018      	ands	r0, r3
    2e94:	2801      	cmp	r0, #1
    2e96:	d113      	bne.n	2ec0 <setsockopt+0x13c>
         setSn_KPALVTR(sn,*(uint8_t*)arg);
    2e98:	23bc      	movs	r3, #188	; 0xbc
    2e9a:	019b      	lsls	r3, r3, #6
    2e9c:	18e0      	adds	r0, r4, r3
    2e9e:	7829      	ldrb	r1, [r5, #0]
    2ea0:	4b0a      	ldr	r3, [pc, #40]	; (2ecc <setsockopt+0x148>)
    2ea2:	4798      	blx	r3
   return SOCK_OK;
    2ea4:	2001      	movs	r0, #1
         break;
    2ea6:	e784      	b.n	2db2 <setsockopt+0x2e>
   CHECK_SOCKNUM();
    2ea8:	2001      	movs	r0, #1
    2eaa:	4240      	negs	r0, r0
    2eac:	e781      	b.n	2db2 <setsockopt+0x2e>
         return SOCKERR_ARG;
    2eae:	200a      	movs	r0, #10
    2eb0:	4240      	negs	r0, r0
    2eb2:	e77e      	b.n	2db2 <setsockopt+0x2e>
         CHECK_SOCKMODE(Sn_MR_TCP);
    2eb4:	2005      	movs	r0, #5
    2eb6:	4240      	negs	r0, r0
    2eb8:	e77b      	b.n	2db2 <setsockopt+0x2e>
            if(getSn_KPALVTR(sn) != 0) return SOCKERR_SOCKOPT;
    2eba:	2002      	movs	r0, #2
    2ebc:	4240      	negs	r0, r0
    2ebe:	e778      	b.n	2db2 <setsockopt+0x2e>
         CHECK_SOCKMODE(Sn_MR_TCP);
    2ec0:	2005      	movs	r0, #5
    2ec2:	4240      	negs	r0, r0
    2ec4:	e775      	b.n	2db2 <setsockopt+0x2e>
    2ec6:	46c0      	nop			; (mov r8, r8)
    2ec8:	00004b04 	.word	0x00004b04
    2ecc:	000030c9 	.word	0x000030c9
    2ed0:	000031a9 	.word	0x000031a9
    2ed4:	00003065 	.word	0x00003065

00002ed8 <getsockopt>:

int8_t  getsockopt(uint8_t sn, sockopt_type sotype, void* arg)
{
    2ed8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2eda:	0004      	movs	r4, r0
    2edc:	0015      	movs	r5, r2
   CHECK_SOCKNUM();
    2ede:	2808      	cmp	r0, #8
    2ee0:	d900      	bls.n	2ee4 <getsockopt+0xc>
    2ee2:	e0a6      	b.n	3032 <getsockopt+0x15a>
   switch(sotype)
    2ee4:	290c      	cmp	r1, #12
    2ee6:	d900      	bls.n	2eea <getsockopt+0x12>
    2ee8:	e0a6      	b.n	3038 <getsockopt+0x160>
    2eea:	0089      	lsls	r1, r1, #2
    2eec:	4b57      	ldr	r3, [pc, #348]	; (304c <getsockopt+0x174>)
    2eee:	585b      	ldr	r3, [r3, r1]
    2ef0:	469f      	mov	pc, r3
   {
      case SO_FLAG:
         *(uint8_t*)arg = getSn_MR(sn) & 0xF0;
    2ef2:	0080      	lsls	r0, r0, #2
    2ef4:	3001      	adds	r0, #1
    2ef6:	00c0      	lsls	r0, r0, #3
    2ef8:	4b55      	ldr	r3, [pc, #340]	; (3050 <getsockopt+0x178>)
    2efa:	4798      	blx	r3
    2efc:	230f      	movs	r3, #15
    2efe:	4398      	bics	r0, r3
    2f00:	7028      	strb	r0, [r5, #0]
         *(uint8_t*)arg = sock_pack_info[sn];
         break;
      default:
         return SOCKERR_SOCKOPT;
   }
   return SOCK_OK;
    2f02:	2001      	movs	r0, #1
}
    2f04:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
         *(uint8_t*) arg = getSn_TTL(sn);
    2f06:	0080      	lsls	r0, r0, #2
    2f08:	3001      	adds	r0, #1
    2f0a:	00c0      	lsls	r0, r0, #3
    2f0c:	23b0      	movs	r3, #176	; 0xb0
    2f0e:	015b      	lsls	r3, r3, #5
    2f10:	469c      	mov	ip, r3
    2f12:	4460      	add	r0, ip
    2f14:	4b4e      	ldr	r3, [pc, #312]	; (3050 <getsockopt+0x178>)
    2f16:	4798      	blx	r3
    2f18:	7028      	strb	r0, [r5, #0]
   return SOCK_OK;
    2f1a:	2001      	movs	r0, #1
         break;
    2f1c:	e7f2      	b.n	2f04 <getsockopt+0x2c>
         *(uint8_t*) arg = getSn_TOS(sn);
    2f1e:	0080      	lsls	r0, r0, #2
    2f20:	3001      	adds	r0, #1
    2f22:	00c0      	lsls	r0, r0, #3
    2f24:	23a8      	movs	r3, #168	; 0xa8
    2f26:	015b      	lsls	r3, r3, #5
    2f28:	469c      	mov	ip, r3
    2f2a:	4460      	add	r0, ip
    2f2c:	4b48      	ldr	r3, [pc, #288]	; (3050 <getsockopt+0x178>)
    2f2e:	4798      	blx	r3
    2f30:	7028      	strb	r0, [r5, #0]
   return SOCK_OK;
    2f32:	2001      	movs	r0, #1
         break;
    2f34:	e7e6      	b.n	2f04 <getsockopt+0x2c>
         *(uint16_t*) arg = getSn_MSSR(sn);
    2f36:	0084      	lsls	r4, r0, #2
    2f38:	3401      	adds	r4, #1
    2f3a:	00e4      	lsls	r4, r4, #3
    2f3c:	2390      	movs	r3, #144	; 0x90
    2f3e:	015b      	lsls	r3, r3, #5
    2f40:	18e0      	adds	r0, r4, r3
    2f42:	4f43      	ldr	r7, [pc, #268]	; (3050 <getsockopt+0x178>)
    2f44:	47b8      	blx	r7
    2f46:	b286      	uxth	r6, r0
    2f48:	0236      	lsls	r6, r6, #8
    2f4a:	b2b6      	uxth	r6, r6
    2f4c:	2398      	movs	r3, #152	; 0x98
    2f4e:	015b      	lsls	r3, r3, #5
    2f50:	18e0      	adds	r0, r4, r3
    2f52:	47b8      	blx	r7
    2f54:	b280      	uxth	r0, r0
    2f56:	1836      	adds	r6, r6, r0
    2f58:	802e      	strh	r6, [r5, #0]
   return SOCK_OK;
    2f5a:	2001      	movs	r0, #1
         break;
    2f5c:	e7d2      	b.n	2f04 <getsockopt+0x2c>
         getSn_DIPR(sn, (uint8_t*)arg);
    2f5e:	0080      	lsls	r0, r0, #2
    2f60:	3001      	adds	r0, #1
    2f62:	00c0      	lsls	r0, r0, #3
    2f64:	23c0      	movs	r3, #192	; 0xc0
    2f66:	011b      	lsls	r3, r3, #4
    2f68:	469c      	mov	ip, r3
    2f6a:	4460      	add	r0, ip
    2f6c:	2204      	movs	r2, #4
    2f6e:	0029      	movs	r1, r5
    2f70:	4b38      	ldr	r3, [pc, #224]	; (3054 <getsockopt+0x17c>)
    2f72:	4798      	blx	r3
   return SOCK_OK;
    2f74:	2001      	movs	r0, #1
         break;
    2f76:	e7c5      	b.n	2f04 <getsockopt+0x2c>
         *(uint16_t*) arg = getSn_DPORT(sn);
    2f78:	0084      	lsls	r4, r0, #2
    2f7a:	3401      	adds	r4, #1
    2f7c:	00e4      	lsls	r4, r4, #3
    2f7e:	2380      	movs	r3, #128	; 0x80
    2f80:	015b      	lsls	r3, r3, #5
    2f82:	18e0      	adds	r0, r4, r3
    2f84:	4f32      	ldr	r7, [pc, #200]	; (3050 <getsockopt+0x178>)
    2f86:	47b8      	blx	r7
    2f88:	b286      	uxth	r6, r0
    2f8a:	0236      	lsls	r6, r6, #8
    2f8c:	b2b6      	uxth	r6, r6
    2f8e:	2388      	movs	r3, #136	; 0x88
    2f90:	015b      	lsls	r3, r3, #5
    2f92:	18e0      	adds	r0, r4, r3
    2f94:	47b8      	blx	r7
    2f96:	b280      	uxth	r0, r0
    2f98:	1836      	adds	r6, r6, r0
    2f9a:	802e      	strh	r6, [r5, #0]
   return SOCK_OK;
    2f9c:	2001      	movs	r0, #1
         break;
    2f9e:	e7b1      	b.n	2f04 <getsockopt+0x2c>
         CHECK_SOCKMODE(Sn_MR_TCP);
    2fa0:	0084      	lsls	r4, r0, #2
    2fa2:	3401      	adds	r4, #1
    2fa4:	00e4      	lsls	r4, r4, #3
    2fa6:	0020      	movs	r0, r4
    2fa8:	4b29      	ldr	r3, [pc, #164]	; (3050 <getsockopt+0x178>)
    2faa:	4798      	blx	r3
    2fac:	230f      	movs	r3, #15
    2fae:	4018      	ands	r0, r3
    2fb0:	2801      	cmp	r0, #1
    2fb2:	d144      	bne.n	303e <getsockopt+0x166>
         *(uint16_t*) arg = getSn_KPALVTR(sn);
    2fb4:	23bc      	movs	r3, #188	; 0xbc
    2fb6:	019b      	lsls	r3, r3, #6
    2fb8:	18e0      	adds	r0, r4, r3
    2fba:	4b25      	ldr	r3, [pc, #148]	; (3050 <getsockopt+0x178>)
    2fbc:	4798      	blx	r3
    2fbe:	8028      	strh	r0, [r5, #0]
   return SOCK_OK;
    2fc0:	2001      	movs	r0, #1
         break;
    2fc2:	e79f      	b.n	2f04 <getsockopt+0x2c>
         *(uint16_t*) arg = getSn_TX_FSR(sn);
    2fc4:	4b24      	ldr	r3, [pc, #144]	; (3058 <getsockopt+0x180>)
    2fc6:	4798      	blx	r3
    2fc8:	8028      	strh	r0, [r5, #0]
   return SOCK_OK;
    2fca:	2001      	movs	r0, #1
         break;
    2fcc:	e79a      	b.n	2f04 <getsockopt+0x2c>
         *(uint16_t*) arg = getSn_RX_RSR(sn);
    2fce:	4b23      	ldr	r3, [pc, #140]	; (305c <getsockopt+0x184>)
    2fd0:	4798      	blx	r3
    2fd2:	8028      	strh	r0, [r5, #0]
   return SOCK_OK;
    2fd4:	2001      	movs	r0, #1
         break;
    2fd6:	e795      	b.n	2f04 <getsockopt+0x2c>
         *(uint8_t*) arg = getSn_SR(sn);
    2fd8:	0080      	lsls	r0, r0, #2
    2fda:	3001      	adds	r0, #1
    2fdc:	00c0      	lsls	r0, r0, #3
    2fde:	23c0      	movs	r3, #192	; 0xc0
    2fe0:	009b      	lsls	r3, r3, #2
    2fe2:	469c      	mov	ip, r3
    2fe4:	4460      	add	r0, ip
    2fe6:	4b1a      	ldr	r3, [pc, #104]	; (3050 <getsockopt+0x178>)
    2fe8:	4798      	blx	r3
    2fea:	7028      	strb	r0, [r5, #0]
   return SOCK_OK;
    2fec:	2001      	movs	r0, #1
         break;
    2fee:	e789      	b.n	2f04 <getsockopt+0x2c>
         if(getSn_MR(sn) & Sn_MR_TCP)
    2ff0:	0080      	lsls	r0, r0, #2
    2ff2:	3001      	adds	r0, #1
    2ff4:	00c0      	lsls	r0, r0, #3
    2ff6:	4b16      	ldr	r3, [pc, #88]	; (3050 <getsockopt+0x178>)
    2ff8:	4798      	blx	r3
    2ffa:	07c3      	lsls	r3, r0, #31
    2ffc:	d406      	bmi.n	300c <getsockopt+0x134>
            *(uint16_t*)arg = sock_remained_size[sn];
    2ffe:	0064      	lsls	r4, r4, #1
    3000:	4b17      	ldr	r3, [pc, #92]	; (3060 <getsockopt+0x188>)
    3002:	191c      	adds	r4, r3, r4
    3004:	88a3      	ldrh	r3, [r4, #4]
    3006:	802b      	strh	r3, [r5, #0]
   return SOCK_OK;
    3008:	2001      	movs	r0, #1
    300a:	e77b      	b.n	2f04 <getsockopt+0x2c>
            *(uint16_t*)arg = getSn_RX_RSR(sn);
    300c:	0020      	movs	r0, r4
    300e:	4b13      	ldr	r3, [pc, #76]	; (305c <getsockopt+0x184>)
    3010:	4798      	blx	r3
    3012:	8028      	strh	r0, [r5, #0]
   return SOCK_OK;
    3014:	2001      	movs	r0, #1
    3016:	e775      	b.n	2f04 <getsockopt+0x2c>
         if((getSn_MR(sn) == Sn_MR_TCP))
    3018:	0080      	lsls	r0, r0, #2
    301a:	3001      	adds	r0, #1
    301c:	00c0      	lsls	r0, r0, #3
    301e:	4b0c      	ldr	r3, [pc, #48]	; (3050 <getsockopt+0x178>)
    3020:	4798      	blx	r3
    3022:	2801      	cmp	r0, #1
    3024:	d00e      	beq.n	3044 <getsockopt+0x16c>
         *(uint8_t*)arg = sock_pack_info[sn];
    3026:	480e      	ldr	r0, [pc, #56]	; (3060 <getsockopt+0x188>)
    3028:	1904      	adds	r4, r0, r4
    302a:	7d23      	ldrb	r3, [r4, #20]
    302c:	702b      	strb	r3, [r5, #0]
   return SOCK_OK;
    302e:	2001      	movs	r0, #1
         break;
    3030:	e768      	b.n	2f04 <getsockopt+0x2c>
   CHECK_SOCKNUM();
    3032:	2001      	movs	r0, #1
    3034:	4240      	negs	r0, r0
    3036:	e765      	b.n	2f04 <getsockopt+0x2c>
         return SOCKERR_SOCKOPT;
    3038:	2002      	movs	r0, #2
    303a:	4240      	negs	r0, r0
    303c:	e762      	b.n	2f04 <getsockopt+0x2c>
         CHECK_SOCKMODE(Sn_MR_TCP);
    303e:	2005      	movs	r0, #5
    3040:	4240      	negs	r0, r0
    3042:	e75f      	b.n	2f04 <getsockopt+0x2c>
             return SOCKERR_SOCKMODE;
    3044:	2005      	movs	r0, #5
    3046:	4240      	negs	r0, r0
    3048:	e75c      	b.n	2f04 <getsockopt+0x2c>
    304a:	46c0      	nop			; (mov r8, r8)
    304c:	00004b24 	.word	0x00004b24
    3050:	00003065 	.word	0x00003065
    3054:	00003129 	.word	0x00003129
    3058:	00003221 	.word	0x00003221
    305c:	0000328d 	.word	0x0000328d
    3060:	20000148 	.word	0x20000148

00003064 <WIZCHIP_READ>:

#if   (_WIZCHIP_ == 5500)
////////////////////////////////////////////////////

uint8_t  WIZCHIP_READ(uint32_t AddrSel)
{
    3064:	b530      	push	{r4, r5, lr}
    3066:	b083      	sub	sp, #12
    3068:	0004      	movs	r4, r0
   uint8_t ret;
   uint8_t spi_data[3];

   WIZCHIP_CRITICAL_ENTER();
    306a:	4d16      	ldr	r5, [pc, #88]	; (30c4 <WIZCHIP_READ+0x60>)
    306c:	68eb      	ldr	r3, [r5, #12]
    306e:	4798      	blx	r3
   WIZCHIP.CS._select();
    3070:	696b      	ldr	r3, [r5, #20]
    3072:	4798      	blx	r3

   AddrSel |= (_W5500_SPI_READ_ | _W5500_SPI_VDM_OP_);

   if(!WIZCHIP.IF.SPI._read_burst || !WIZCHIP.IF.SPI._write_burst) 	// byte operation
    3074:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    3076:	2b00      	cmp	r3, #0
    3078:	d016      	beq.n	30a8 <WIZCHIP_READ+0x44>
    307a:	4b12      	ldr	r3, [pc, #72]	; (30c4 <WIZCHIP_READ+0x60>)
    307c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    307e:	2b00      	cmp	r3, #0
    3080:	d012      	beq.n	30a8 <WIZCHIP_READ+0x44>
		WIZCHIP.IF.SPI._write_byte((AddrSel & 0x0000FF00) >>  8);
		WIZCHIP.IF.SPI._write_byte((AddrSel & 0x000000FF) >>  0);
   }
   else																// burst operation
   {
		spi_data[0] = (AddrSel & 0x00FF0000) >> 16;
    3082:	0c22      	lsrs	r2, r4, #16
    3084:	a801      	add	r0, sp, #4
    3086:	7002      	strb	r2, [r0, #0]
		spi_data[1] = (AddrSel & 0x0000FF00) >> 8;
    3088:	0a22      	lsrs	r2, r4, #8
    308a:	7042      	strb	r2, [r0, #1]
		spi_data[2] = (AddrSel & 0x000000FF) >> 0;
    308c:	7084      	strb	r4, [r0, #2]
		WIZCHIP.IF.SPI._write_burst(spi_data, 3);
    308e:	2103      	movs	r1, #3
    3090:	4798      	blx	r3
   }
   ret = WIZCHIP.IF.SPI._read_byte();
    3092:	4c0c      	ldr	r4, [pc, #48]	; (30c4 <WIZCHIP_READ+0x60>)
    3094:	69e3      	ldr	r3, [r4, #28]
    3096:	4798      	blx	r3
    3098:	0005      	movs	r5, r0

   WIZCHIP.CS._deselect();
    309a:	69a3      	ldr	r3, [r4, #24]
    309c:	4798      	blx	r3
   WIZCHIP_CRITICAL_EXIT();
    309e:	6923      	ldr	r3, [r4, #16]
    30a0:	4798      	blx	r3
   return ret;
}
    30a2:	0028      	movs	r0, r5
    30a4:	b003      	add	sp, #12
    30a6:	bd30      	pop	{r4, r5, pc}
	   WIZCHIP.IF.SPI._write_byte((AddrSel & 0x00FF0000) >> 16);
    30a8:	4d06      	ldr	r5, [pc, #24]	; (30c4 <WIZCHIP_READ+0x60>)
    30aa:	0c20      	lsrs	r0, r4, #16
    30ac:	b2c0      	uxtb	r0, r0
    30ae:	6a2b      	ldr	r3, [r5, #32]
    30b0:	4798      	blx	r3
		WIZCHIP.IF.SPI._write_byte((AddrSel & 0x0000FF00) >>  8);
    30b2:	0a20      	lsrs	r0, r4, #8
    30b4:	b2c0      	uxtb	r0, r0
    30b6:	6a2b      	ldr	r3, [r5, #32]
    30b8:	4798      	blx	r3
		WIZCHIP.IF.SPI._write_byte((AddrSel & 0x000000FF) >>  0);
    30ba:	6a2b      	ldr	r3, [r5, #32]
    30bc:	b2e0      	uxtb	r0, r4
    30be:	4798      	blx	r3
    30c0:	e7e7      	b.n	3092 <WIZCHIP_READ+0x2e>
    30c2:	46c0      	nop			; (mov r8, r8)
    30c4:	2000002c 	.word	0x2000002c

000030c8 <WIZCHIP_WRITE>:

void     WIZCHIP_WRITE(uint32_t AddrSel, uint8_t wb )
{
    30c8:	b570      	push	{r4, r5, r6, lr}
    30ca:	b082      	sub	sp, #8
    30cc:	0004      	movs	r4, r0
    30ce:	000e      	movs	r6, r1
   uint8_t spi_data[4];

   WIZCHIP_CRITICAL_ENTER();
    30d0:	4d14      	ldr	r5, [pc, #80]	; (3124 <WIZCHIP_WRITE+0x5c>)
    30d2:	68eb      	ldr	r3, [r5, #12]
    30d4:	4798      	blx	r3
   WIZCHIP.CS._select();
    30d6:	696b      	ldr	r3, [r5, #20]
    30d8:	4798      	blx	r3

   AddrSel |= (_W5500_SPI_WRITE_ | _W5500_SPI_VDM_OP_);
    30da:	2004      	movs	r0, #4
    30dc:	4304      	orrs	r4, r0

   //if(!WIZCHIP.IF.SPI._read_burst || !WIZCHIP.IF.SPI._write_burst) 	// byte operation
   if(!WIZCHIP.IF.SPI._write_burst) 	// byte operation
    30de:	6aab      	ldr	r3, [r5, #40]	; 0x28
    30e0:	2b00      	cmp	r3, #0
    30e2:	d00f      	beq.n	3104 <WIZCHIP_WRITE+0x3c>
		WIZCHIP.IF.SPI._write_byte((AddrSel & 0x000000FF) >>  0);
		WIZCHIP.IF.SPI._write_byte(wb);
   }
   else									// burst operation
   {
		spi_data[0] = (AddrSel & 0x00FF0000) >> 16;
    30e4:	0c22      	lsrs	r2, r4, #16
    30e6:	a801      	add	r0, sp, #4
    30e8:	7002      	strb	r2, [r0, #0]
		spi_data[1] = (AddrSel & 0x0000FF00) >> 8;
    30ea:	0a22      	lsrs	r2, r4, #8
    30ec:	7042      	strb	r2, [r0, #1]
		spi_data[2] = (AddrSel & 0x000000FF) >> 0;
    30ee:	7084      	strb	r4, [r0, #2]
		spi_data[3] = wb;
    30f0:	70c6      	strb	r6, [r0, #3]
		WIZCHIP.IF.SPI._write_burst(spi_data, 4);
    30f2:	2104      	movs	r1, #4
    30f4:	4798      	blx	r3
   }

   WIZCHIP.CS._deselect();
    30f6:	4c0b      	ldr	r4, [pc, #44]	; (3124 <WIZCHIP_WRITE+0x5c>)
    30f8:	69a3      	ldr	r3, [r4, #24]
    30fa:	4798      	blx	r3
   WIZCHIP_CRITICAL_EXIT();
    30fc:	6923      	ldr	r3, [r4, #16]
    30fe:	4798      	blx	r3
}
    3100:	b002      	add	sp, #8
    3102:	bd70      	pop	{r4, r5, r6, pc}
		WIZCHIP.IF.SPI._write_byte((AddrSel & 0x00FF0000) >> 16);
    3104:	4d07      	ldr	r5, [pc, #28]	; (3124 <WIZCHIP_WRITE+0x5c>)
    3106:	0c20      	lsrs	r0, r4, #16
    3108:	b2c0      	uxtb	r0, r0
    310a:	6a2b      	ldr	r3, [r5, #32]
    310c:	4798      	blx	r3
		WIZCHIP.IF.SPI._write_byte((AddrSel & 0x0000FF00) >>  8);
    310e:	0a20      	lsrs	r0, r4, #8
    3110:	b2c0      	uxtb	r0, r0
    3112:	6a2b      	ldr	r3, [r5, #32]
    3114:	4798      	blx	r3
		WIZCHIP.IF.SPI._write_byte((AddrSel & 0x000000FF) >>  0);
    3116:	b2e0      	uxtb	r0, r4
    3118:	6a2b      	ldr	r3, [r5, #32]
    311a:	4798      	blx	r3
		WIZCHIP.IF.SPI._write_byte(wb);
    311c:	6a2b      	ldr	r3, [r5, #32]
    311e:	0030      	movs	r0, r6
    3120:	4798      	blx	r3
    3122:	e7e8      	b.n	30f6 <WIZCHIP_WRITE+0x2e>
    3124:	2000002c 	.word	0x2000002c

00003128 <WIZCHIP_READ_BUF>:
         
void     WIZCHIP_READ_BUF (uint32_t AddrSel, uint8_t* pBuf, uint16_t len)
{
    3128:	b5f0      	push	{r4, r5, r6, r7, lr}
    312a:	b083      	sub	sp, #12
    312c:	0004      	movs	r4, r0
    312e:	000f      	movs	r7, r1
    3130:	0016      	movs	r6, r2
   uint8_t spi_data[3];
   uint16_t i;

   WIZCHIP_CRITICAL_ENTER();
    3132:	4d1c      	ldr	r5, [pc, #112]	; (31a4 <WIZCHIP_READ_BUF+0x7c>)
    3134:	68eb      	ldr	r3, [r5, #12]
    3136:	4798      	blx	r3
   WIZCHIP.CS._select();
    3138:	696b      	ldr	r3, [r5, #20]
    313a:	4798      	blx	r3

   AddrSel |= (_W5500_SPI_READ_ | _W5500_SPI_VDM_OP_);

   if(!WIZCHIP.IF.SPI._read_burst || !WIZCHIP.IF.SPI._write_burst) 	// byte operation
    313c:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    313e:	2b00      	cmp	r3, #0
    3140:	d017      	beq.n	3172 <WIZCHIP_READ_BUF+0x4a>
    3142:	4b18      	ldr	r3, [pc, #96]	; (31a4 <WIZCHIP_READ_BUF+0x7c>)
    3144:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    3146:	2b00      	cmp	r3, #0
    3148:	d013      	beq.n	3172 <WIZCHIP_READ_BUF+0x4a>
		for(i = 0; i < len; i++)
		   pBuf[i] = WIZCHIP.IF.SPI._read_byte();
   }
   else																// burst operation
   {
		spi_data[0] = (AddrSel & 0x00FF0000) >> 16;
    314a:	0c22      	lsrs	r2, r4, #16
    314c:	a801      	add	r0, sp, #4
    314e:	7002      	strb	r2, [r0, #0]
		spi_data[1] = (AddrSel & 0x0000FF00) >> 8;
    3150:	0a22      	lsrs	r2, r4, #8
    3152:	7042      	strb	r2, [r0, #1]
		spi_data[2] = (AddrSel & 0x000000FF) >> 0;
    3154:	7084      	strb	r4, [r0, #2]
		WIZCHIP.IF.SPI._write_burst(spi_data, 3);
    3156:	2103      	movs	r1, #3
    3158:	4798      	blx	r3
		WIZCHIP.IF.SPI._read_burst(pBuf, len);
    315a:	4b12      	ldr	r3, [pc, #72]	; (31a4 <WIZCHIP_READ_BUF+0x7c>)
    315c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    315e:	0031      	movs	r1, r6
    3160:	0038      	movs	r0, r7
    3162:	4798      	blx	r3
   }

   WIZCHIP.CS._deselect();
    3164:	4c0f      	ldr	r4, [pc, #60]	; (31a4 <WIZCHIP_READ_BUF+0x7c>)
    3166:	69a3      	ldr	r3, [r4, #24]
    3168:	4798      	blx	r3
   WIZCHIP_CRITICAL_EXIT();
    316a:	6923      	ldr	r3, [r4, #16]
    316c:	4798      	blx	r3
}
    316e:	b003      	add	sp, #12
    3170:	bdf0      	pop	{r4, r5, r6, r7, pc}
		WIZCHIP.IF.SPI._write_byte((AddrSel & 0x00FF0000) >> 16);
    3172:	4d0c      	ldr	r5, [pc, #48]	; (31a4 <WIZCHIP_READ_BUF+0x7c>)
    3174:	0c20      	lsrs	r0, r4, #16
    3176:	b2c0      	uxtb	r0, r0
    3178:	6a2b      	ldr	r3, [r5, #32]
    317a:	4798      	blx	r3
		WIZCHIP.IF.SPI._write_byte((AddrSel & 0x0000FF00) >>  8);
    317c:	0a20      	lsrs	r0, r4, #8
    317e:	b2c0      	uxtb	r0, r0
    3180:	6a2b      	ldr	r3, [r5, #32]
    3182:	4798      	blx	r3
		WIZCHIP.IF.SPI._write_byte((AddrSel & 0x000000FF) >>  0);
    3184:	6a2b      	ldr	r3, [r5, #32]
    3186:	b2e0      	uxtb	r0, r4
    3188:	4798      	blx	r3
		for(i = 0; i < len; i++)
    318a:	2400      	movs	r4, #0
    318c:	e006      	b.n	319c <WIZCHIP_READ_BUF+0x74>
		   pBuf[i] = WIZCHIP.IF.SPI._read_byte();
    318e:	193d      	adds	r5, r7, r4
    3190:	4b04      	ldr	r3, [pc, #16]	; (31a4 <WIZCHIP_READ_BUF+0x7c>)
    3192:	69db      	ldr	r3, [r3, #28]
    3194:	4798      	blx	r3
    3196:	7028      	strb	r0, [r5, #0]
		for(i = 0; i < len; i++)
    3198:	3401      	adds	r4, #1
    319a:	b2a4      	uxth	r4, r4
    319c:	42b4      	cmp	r4, r6
    319e:	d3f6      	bcc.n	318e <WIZCHIP_READ_BUF+0x66>
    31a0:	e7e0      	b.n	3164 <WIZCHIP_READ_BUF+0x3c>
    31a2:	46c0      	nop			; (mov r8, r8)
    31a4:	2000002c 	.word	0x2000002c

000031a8 <WIZCHIP_WRITE_BUF>:

void     WIZCHIP_WRITE_BUF(uint32_t AddrSel, uint8_t* pBuf, uint16_t len)
{
    31a8:	b5f0      	push	{r4, r5, r6, r7, lr}
    31aa:	b083      	sub	sp, #12
    31ac:	0004      	movs	r4, r0
    31ae:	000f      	movs	r7, r1
    31b0:	0016      	movs	r6, r2
   uint8_t spi_data[3];
   uint16_t i;

   WIZCHIP_CRITICAL_ENTER();
    31b2:	4d1a      	ldr	r5, [pc, #104]	; (321c <WIZCHIP_WRITE_BUF+0x74>)
    31b4:	68eb      	ldr	r3, [r5, #12]
    31b6:	4798      	blx	r3
   WIZCHIP.CS._select();
    31b8:	696b      	ldr	r3, [r5, #20]
    31ba:	4798      	blx	r3

   AddrSel |= (_W5500_SPI_WRITE_ | _W5500_SPI_VDM_OP_);
    31bc:	2004      	movs	r0, #4
    31be:	4304      	orrs	r4, r0

   if(!WIZCHIP.IF.SPI._write_burst) 	// byte operation
    31c0:	6aab      	ldr	r3, [r5, #40]	; 0x28
    31c2:	2b00      	cmp	r3, #0
    31c4:	d013      	beq.n	31ee <WIZCHIP_WRITE_BUF+0x46>
		for(i = 0; i < len; i++)
			WIZCHIP.IF.SPI._write_byte(pBuf[i]);
   }
   else									// burst operation
   {
		spi_data[0] = (AddrSel & 0x00FF0000) >> 16;
    31c6:	0c22      	lsrs	r2, r4, #16
    31c8:	a801      	add	r0, sp, #4
    31ca:	7002      	strb	r2, [r0, #0]
		spi_data[1] = (AddrSel & 0x0000FF00) >> 8;
    31cc:	0a22      	lsrs	r2, r4, #8
    31ce:	7042      	strb	r2, [r0, #1]
		spi_data[2] = (AddrSel & 0x000000FF) >> 0;
    31d0:	7084      	strb	r4, [r0, #2]
		WIZCHIP.IF.SPI._write_burst(spi_data, 3);
    31d2:	2103      	movs	r1, #3
    31d4:	4798      	blx	r3
		WIZCHIP.IF.SPI._write_burst(pBuf, len);
    31d6:	4b11      	ldr	r3, [pc, #68]	; (321c <WIZCHIP_WRITE_BUF+0x74>)
    31d8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    31da:	0031      	movs	r1, r6
    31dc:	0038      	movs	r0, r7
    31de:	4798      	blx	r3
   }

   WIZCHIP.CS._deselect();
    31e0:	4c0e      	ldr	r4, [pc, #56]	; (321c <WIZCHIP_WRITE_BUF+0x74>)
    31e2:	69a3      	ldr	r3, [r4, #24]
    31e4:	4798      	blx	r3
   WIZCHIP_CRITICAL_EXIT();
    31e6:	6923      	ldr	r3, [r4, #16]
    31e8:	4798      	blx	r3
}
    31ea:	b003      	add	sp, #12
    31ec:	bdf0      	pop	{r4, r5, r6, r7, pc}
		WIZCHIP.IF.SPI._write_byte((AddrSel & 0x00FF0000) >> 16);
    31ee:	4d0b      	ldr	r5, [pc, #44]	; (321c <WIZCHIP_WRITE_BUF+0x74>)
    31f0:	0c20      	lsrs	r0, r4, #16
    31f2:	b2c0      	uxtb	r0, r0
    31f4:	6a2b      	ldr	r3, [r5, #32]
    31f6:	4798      	blx	r3
		WIZCHIP.IF.SPI._write_byte((AddrSel & 0x0000FF00) >>  8);
    31f8:	0a20      	lsrs	r0, r4, #8
    31fa:	b2c0      	uxtb	r0, r0
    31fc:	6a2b      	ldr	r3, [r5, #32]
    31fe:	4798      	blx	r3
		WIZCHIP.IF.SPI._write_byte((AddrSel & 0x000000FF) >>  0);
    3200:	6a2b      	ldr	r3, [r5, #32]
    3202:	b2e0      	uxtb	r0, r4
    3204:	4798      	blx	r3
		for(i = 0; i < len; i++)
    3206:	2400      	movs	r4, #0
    3208:	e005      	b.n	3216 <WIZCHIP_WRITE_BUF+0x6e>
			WIZCHIP.IF.SPI._write_byte(pBuf[i]);
    320a:	4b04      	ldr	r3, [pc, #16]	; (321c <WIZCHIP_WRITE_BUF+0x74>)
    320c:	6a1b      	ldr	r3, [r3, #32]
    320e:	5d38      	ldrb	r0, [r7, r4]
    3210:	4798      	blx	r3
		for(i = 0; i < len; i++)
    3212:	3401      	adds	r4, #1
    3214:	b2a4      	uxth	r4, r4
    3216:	42b4      	cmp	r4, r6
    3218:	d3f7      	bcc.n	320a <WIZCHIP_WRITE_BUF+0x62>
    321a:	e7e1      	b.n	31e0 <WIZCHIP_WRITE_BUF+0x38>
    321c:	2000002c 	.word	0x2000002c

00003220 <getSn_TX_FSR>:


uint16_t getSn_TX_FSR(uint8_t sn)
{
    3220:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3222:	46ce      	mov	lr, r9
    3224:	4647      	mov	r7, r8
    3226:	b580      	push	{r7, lr}
    3228:	4680      	mov	r8, r0
   uint16_t val=0,val1=0;
    322a:	2600      	movs	r6, #0
    322c:	e001      	b.n	3232 <getSn_TX_FSR+0x12>
      if (val1 != 0)
      {
        val = WIZCHIP_READ(Sn_TX_FSR(sn));
        val = (val << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_TX_FSR(sn),1));
      }
   }while (val != val1);
    322e:	42a6      	cmp	r6, r4
    3230:	d024      	beq.n	327c <getSn_TX_FSR+0x5c>
      val1 = WIZCHIP_READ(Sn_TX_FSR(sn));
    3232:	4643      	mov	r3, r8
    3234:	009d      	lsls	r5, r3, #2
    3236:	3501      	adds	r5, #1
    3238:	00ed      	lsls	r5, r5, #3
    323a:	2380      	movs	r3, #128	; 0x80
    323c:	019b      	lsls	r3, r3, #6
    323e:	4699      	mov	r9, r3
    3240:	44a9      	add	r9, r5
    3242:	4648      	mov	r0, r9
    3244:	4f10      	ldr	r7, [pc, #64]	; (3288 <getSn_TX_FSR+0x68>)
    3246:	47b8      	blx	r7
    3248:	b284      	uxth	r4, r0
      val1 = (val1 << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_TX_FSR(sn),1));
    324a:	0224      	lsls	r4, r4, #8
    324c:	b2a4      	uxth	r4, r4
    324e:	2384      	movs	r3, #132	; 0x84
    3250:	019b      	lsls	r3, r3, #6
    3252:	469c      	mov	ip, r3
    3254:	4465      	add	r5, ip
    3256:	0028      	movs	r0, r5
    3258:	47b8      	blx	r7
    325a:	b280      	uxth	r0, r0
    325c:	1824      	adds	r4, r4, r0
    325e:	b2a4      	uxth	r4, r4
      if (val1 != 0)
    3260:	2c00      	cmp	r4, #0
    3262:	d0e4      	beq.n	322e <getSn_TX_FSR+0xe>
        val = WIZCHIP_READ(Sn_TX_FSR(sn));
    3264:	4648      	mov	r0, r9
    3266:	4f08      	ldr	r7, [pc, #32]	; (3288 <getSn_TX_FSR+0x68>)
    3268:	47b8      	blx	r7
    326a:	b280      	uxth	r0, r0
        val = (val << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_TX_FSR(sn),1));
    326c:	0200      	lsls	r0, r0, #8
    326e:	b286      	uxth	r6, r0
    3270:	0028      	movs	r0, r5
    3272:	47b8      	blx	r7
    3274:	b280      	uxth	r0, r0
    3276:	1836      	adds	r6, r6, r0
    3278:	b2b6      	uxth	r6, r6
    327a:	e7d8      	b.n	322e <getSn_TX_FSR+0xe>
   return val;
}
    327c:	0030      	movs	r0, r6
    327e:	bc0c      	pop	{r2, r3}
    3280:	4690      	mov	r8, r2
    3282:	4699      	mov	r9, r3
    3284:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    3286:	46c0      	nop			; (mov r8, r8)
    3288:	00003065 	.word	0x00003065

0000328c <getSn_RX_RSR>:


uint16_t getSn_RX_RSR(uint8_t sn)
{
    328c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    328e:	46ce      	mov	lr, r9
    3290:	4647      	mov	r7, r8
    3292:	b580      	push	{r7, lr}
    3294:	4680      	mov	r8, r0
   uint16_t val=0,val1=0;
    3296:	2600      	movs	r6, #0
    3298:	e001      	b.n	329e <getSn_RX_RSR+0x12>
      if (val1 != 0)
      {
        val = WIZCHIP_READ(Sn_RX_RSR(sn));
        val = (val << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_RX_RSR(sn),1));
      }
   }while (val != val1);
    329a:	42a6      	cmp	r6, r4
    329c:	d024      	beq.n	32e8 <getSn_RX_RSR+0x5c>
      val1 = WIZCHIP_READ(Sn_RX_RSR(sn));
    329e:	4643      	mov	r3, r8
    32a0:	009d      	lsls	r5, r3, #2
    32a2:	3501      	adds	r5, #1
    32a4:	00ed      	lsls	r5, r5, #3
    32a6:	2398      	movs	r3, #152	; 0x98
    32a8:	019b      	lsls	r3, r3, #6
    32aa:	4699      	mov	r9, r3
    32ac:	44a9      	add	r9, r5
    32ae:	4648      	mov	r0, r9
    32b0:	4f10      	ldr	r7, [pc, #64]	; (32f4 <getSn_RX_RSR+0x68>)
    32b2:	47b8      	blx	r7
    32b4:	b284      	uxth	r4, r0
      val1 = (val1 << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_RX_RSR(sn),1));
    32b6:	0224      	lsls	r4, r4, #8
    32b8:	b2a4      	uxth	r4, r4
    32ba:	239c      	movs	r3, #156	; 0x9c
    32bc:	019b      	lsls	r3, r3, #6
    32be:	469c      	mov	ip, r3
    32c0:	4465      	add	r5, ip
    32c2:	0028      	movs	r0, r5
    32c4:	47b8      	blx	r7
    32c6:	b280      	uxth	r0, r0
    32c8:	1824      	adds	r4, r4, r0
    32ca:	b2a4      	uxth	r4, r4
      if (val1 != 0)
    32cc:	2c00      	cmp	r4, #0
    32ce:	d0e4      	beq.n	329a <getSn_RX_RSR+0xe>
        val = WIZCHIP_READ(Sn_RX_RSR(sn));
    32d0:	4648      	mov	r0, r9
    32d2:	4f08      	ldr	r7, [pc, #32]	; (32f4 <getSn_RX_RSR+0x68>)
    32d4:	47b8      	blx	r7
    32d6:	b280      	uxth	r0, r0
        val = (val << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_RX_RSR(sn),1));
    32d8:	0200      	lsls	r0, r0, #8
    32da:	b286      	uxth	r6, r0
    32dc:	0028      	movs	r0, r5
    32de:	47b8      	blx	r7
    32e0:	b280      	uxth	r0, r0
    32e2:	1836      	adds	r6, r6, r0
    32e4:	b2b6      	uxth	r6, r6
    32e6:	e7d8      	b.n	329a <getSn_RX_RSR+0xe>
   return val;
}
    32e8:	0030      	movs	r0, r6
    32ea:	bc0c      	pop	{r2, r3}
    32ec:	4690      	mov	r8, r2
    32ee:	4699      	mov	r9, r3
    32f0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    32f2:	46c0      	nop			; (mov r8, r8)
    32f4:	00003065 	.word	0x00003065

000032f8 <wiz_send_data>:

void wiz_send_data(uint8_t sn, uint8_t *wizdata, uint16_t len)
{
    32f8:	b5f0      	push	{r4, r5, r6, r7, lr}
    32fa:	46d6      	mov	lr, sl
    32fc:	b500      	push	{lr}
    32fe:	b082      	sub	sp, #8
    3300:	9100      	str	r1, [sp, #0]
    3302:	1e14      	subs	r4, r2, #0
   uint16_t ptr = 0;
   uint32_t addrsel = 0;

   if(len == 0)  return;
    3304:	d103      	bne.n	330e <wiz_send_data+0x16>
   //
   WIZCHIP_WRITE_BUF(addrsel,wizdata, len);
   
   ptr += len;
   setSn_TX_WR(sn,ptr);
}
    3306:	b002      	add	sp, #8
    3308:	bc04      	pop	{r2}
    330a:	4692      	mov	sl, r2
    330c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   ptr = getSn_TX_WR(sn);
    330e:	0086      	lsls	r6, r0, #2
    3310:	1c75      	adds	r5, r6, #1
    3312:	00ed      	lsls	r5, r5, #3
    3314:	2390      	movs	r3, #144	; 0x90
    3316:	019b      	lsls	r3, r3, #6
    3318:	469c      	mov	ip, r3
    331a:	44ac      	add	ip, r5
    331c:	4663      	mov	r3, ip
    331e:	9301      	str	r3, [sp, #4]
    3320:	4660      	mov	r0, ip
    3322:	4a10      	ldr	r2, [pc, #64]	; (3364 <wiz_send_data+0x6c>)
    3324:	4692      	mov	sl, r2
    3326:	4790      	blx	r2
    3328:	b280      	uxth	r0, r0
    332a:	0200      	lsls	r0, r0, #8
    332c:	b287      	uxth	r7, r0
    332e:	2294      	movs	r2, #148	; 0x94
    3330:	0192      	lsls	r2, r2, #6
    3332:	4694      	mov	ip, r2
    3334:	4465      	add	r5, ip
    3336:	0028      	movs	r0, r5
    3338:	47d0      	blx	sl
    333a:	b280      	uxth	r0, r0
    333c:	1838      	adds	r0, r7, r0
    333e:	b287      	uxth	r7, r0
   addrsel = ((uint32_t)ptr << 8) + (WIZCHIP_TXBUF_BLOCK(sn) << 3);
    3340:	023b      	lsls	r3, r7, #8
    3342:	1cb0      	adds	r0, r6, #2
    3344:	00c0      	lsls	r0, r0, #3
    3346:	1818      	adds	r0, r3, r0
   WIZCHIP_WRITE_BUF(addrsel,wizdata, len);
    3348:	0022      	movs	r2, r4
    334a:	9900      	ldr	r1, [sp, #0]
    334c:	4b06      	ldr	r3, [pc, #24]	; (3368 <wiz_send_data+0x70>)
    334e:	4798      	blx	r3
   ptr += len;
    3350:	19e4      	adds	r4, r4, r7
    3352:	b2a4      	uxth	r4, r4
   setSn_TX_WR(sn,ptr);
    3354:	0a21      	lsrs	r1, r4, #8
    3356:	9801      	ldr	r0, [sp, #4]
    3358:	4e04      	ldr	r6, [pc, #16]	; (336c <wiz_send_data+0x74>)
    335a:	47b0      	blx	r6
    335c:	b2e1      	uxtb	r1, r4
    335e:	0028      	movs	r0, r5
    3360:	47b0      	blx	r6
    3362:	e7d0      	b.n	3306 <wiz_send_data+0xe>
    3364:	00003065 	.word	0x00003065
    3368:	000031a9 	.word	0x000031a9
    336c:	000030c9 	.word	0x000030c9

00003370 <wiz_recv_data>:

void wiz_recv_data(uint8_t sn, uint8_t *wizdata, uint16_t len)
{
    3370:	b5f0      	push	{r4, r5, r6, r7, lr}
    3372:	46d6      	mov	lr, sl
    3374:	b500      	push	{lr}
    3376:	b082      	sub	sp, #8
    3378:	9100      	str	r1, [sp, #0]
    337a:	1e14      	subs	r4, r2, #0
   uint16_t ptr = 0;
   uint32_t addrsel = 0;
   
   if(len == 0) return;
    337c:	d103      	bne.n	3386 <wiz_recv_data+0x16>
   //
   WIZCHIP_READ_BUF(addrsel, wizdata, len);
   ptr += len;
   
   setSn_RX_RD(sn,ptr);
}
    337e:	b002      	add	sp, #8
    3380:	bc04      	pop	{r2}
    3382:	4692      	mov	sl, r2
    3384:	bdf0      	pop	{r4, r5, r6, r7, pc}
   ptr = getSn_RX_RD(sn);
    3386:	0086      	lsls	r6, r0, #2
    3388:	1c75      	adds	r5, r6, #1
    338a:	00ed      	lsls	r5, r5, #3
    338c:	23a0      	movs	r3, #160	; 0xa0
    338e:	019b      	lsls	r3, r3, #6
    3390:	469c      	mov	ip, r3
    3392:	44ac      	add	ip, r5
    3394:	4663      	mov	r3, ip
    3396:	9301      	str	r3, [sp, #4]
    3398:	4660      	mov	r0, ip
    339a:	4a10      	ldr	r2, [pc, #64]	; (33dc <wiz_recv_data+0x6c>)
    339c:	4692      	mov	sl, r2
    339e:	4790      	blx	r2
    33a0:	b280      	uxth	r0, r0
    33a2:	0200      	lsls	r0, r0, #8
    33a4:	b287      	uxth	r7, r0
    33a6:	22a4      	movs	r2, #164	; 0xa4
    33a8:	0192      	lsls	r2, r2, #6
    33aa:	4694      	mov	ip, r2
    33ac:	4465      	add	r5, ip
    33ae:	0028      	movs	r0, r5
    33b0:	47d0      	blx	sl
    33b2:	b280      	uxth	r0, r0
    33b4:	1838      	adds	r0, r7, r0
    33b6:	b287      	uxth	r7, r0
   addrsel = ((uint32_t)ptr << 8) + (WIZCHIP_RXBUF_BLOCK(sn) << 3);
    33b8:	023b      	lsls	r3, r7, #8
    33ba:	1cf0      	adds	r0, r6, #3
    33bc:	00c0      	lsls	r0, r0, #3
    33be:	1818      	adds	r0, r3, r0
   WIZCHIP_READ_BUF(addrsel, wizdata, len);
    33c0:	0022      	movs	r2, r4
    33c2:	9900      	ldr	r1, [sp, #0]
    33c4:	4b06      	ldr	r3, [pc, #24]	; (33e0 <wiz_recv_data+0x70>)
    33c6:	4798      	blx	r3
   ptr += len;
    33c8:	19e4      	adds	r4, r4, r7
    33ca:	b2a4      	uxth	r4, r4
   setSn_RX_RD(sn,ptr);
    33cc:	0a21      	lsrs	r1, r4, #8
    33ce:	9801      	ldr	r0, [sp, #4]
    33d0:	4e04      	ldr	r6, [pc, #16]	; (33e4 <wiz_recv_data+0x74>)
    33d2:	47b0      	blx	r6
    33d4:	b2e1      	uxtb	r1, r4
    33d6:	0028      	movs	r0, r5
    33d8:	47b0      	blx	r6
    33da:	e7d0      	b.n	337e <wiz_recv_data+0xe>
    33dc:	00003065 	.word	0x00003065
    33e0:	00003129 	.word	0x00003129
    33e4:	000030c9 	.word	0x000030c9

000033e8 <wiz_recv_ignore>:


void wiz_recv_ignore(uint8_t sn, uint16_t len)
{
    33e8:	b5f0      	push	{r4, r5, r6, r7, lr}
    33ea:	b083      	sub	sp, #12
    33ec:	000c      	movs	r4, r1
   uint16_t ptr = 0;

   ptr = getSn_RX_RD(sn);
    33ee:	0087      	lsls	r7, r0, #2
    33f0:	3701      	adds	r7, #1
    33f2:	00ff      	lsls	r7, r7, #3
    33f4:	23a0      	movs	r3, #160	; 0xa0
    33f6:	019b      	lsls	r3, r3, #6
    33f8:	469c      	mov	ip, r3
    33fa:	44bc      	add	ip, r7
    33fc:	4663      	mov	r3, ip
    33fe:	9301      	str	r3, [sp, #4]
    3400:	4660      	mov	r0, ip
    3402:	4e0c      	ldr	r6, [pc, #48]	; (3434 <wiz_recv_ignore+0x4c>)
    3404:	47b0      	blx	r6
    3406:	b280      	uxth	r0, r0
    3408:	0200      	lsls	r0, r0, #8
    340a:	b285      	uxth	r5, r0
    340c:	22a4      	movs	r2, #164	; 0xa4
    340e:	0192      	lsls	r2, r2, #6
    3410:	4694      	mov	ip, r2
    3412:	4467      	add	r7, ip
    3414:	0038      	movs	r0, r7
    3416:	47b0      	blx	r6
    3418:	b280      	uxth	r0, r0
    341a:	182d      	adds	r5, r5, r0
    341c:	b2ad      	uxth	r5, r5
   ptr += len;
    341e:	192c      	adds	r4, r5, r4
    3420:	b2a4      	uxth	r4, r4
   setSn_RX_RD(sn,ptr);
    3422:	0a21      	lsrs	r1, r4, #8
    3424:	9801      	ldr	r0, [sp, #4]
    3426:	4d04      	ldr	r5, [pc, #16]	; (3438 <wiz_recv_ignore+0x50>)
    3428:	47a8      	blx	r5
    342a:	b2e1      	uxtb	r1, r4
    342c:	0038      	movs	r0, r7
    342e:	47a8      	blx	r5
}
    3430:	b003      	add	sp, #12
    3432:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3434:	00003065 	.word	0x00003065
    3438:	000030c9 	.word	0x000030c9

0000343c <wizchip_cris_enter>:
 * @brief Default function to enable interrupt.
 * @note This function help not to access wrong address. If you do not describe this function or register any functions,
 * null function is called.
 */
//void 	  wizchip_cris_enter(void)           {};
void 	  wizchip_cris_enter(void)           {}
    343c:	4770      	bx	lr

0000343e <wizchip_cris_exit>:
 * @brief Default function to disable interrupt.
 * @note This function help not to access wrong address. If you do not describe this function or register any functions,
 * null function is called.
 */
//void 	  wizchip_cris_exit(void)          {};
void 	  wizchip_cris_exit(void)          {}
    343e:	4770      	bx	lr

00003440 <wizchip_cs_select>:
 * @brief Default function to select chip.
 * @note This function help not to access wrong address. If you do not describe this function or register any functions,
 * null function is called.
 */
//void 	wizchip_cs_select(void)            {};
void 	wizchip_cs_select(void)            {}
    3440:	4770      	bx	lr

00003442 <wizchip_cs_deselect>:
 * @brief Default function to deselect chip.
 * @note This function help not to access wrong address. If you do not describe this function or register any functions,
 * null function is called.
 */
//void 	wizchip_cs_deselect(void)          {};
void 	wizchip_cs_deselect(void)          {}
    3442:	4770      	bx	lr

00003444 <wizchip_bus_readdata>:
 * @note This function help not to access wrong address. If you do not describe this function or register any functions,
 * null function is called.
 */
 //M20150601 : Rename the function for integrating with W5300
//uint8_t wizchip_bus_readbyte(uint32_t AddrSel) { return * ((volatile uint8_t *)((ptrdiff_t) AddrSel)); }
iodata_t wizchip_bus_readdata(uint32_t AddrSel) { return * ((volatile iodata_t *)((ptrdiff_t) AddrSel)); }
    3444:	7800      	ldrb	r0, [r0, #0]
    3446:	b2c0      	uxtb	r0, r0
    3448:	4770      	bx	lr

0000344a <wizchip_bus_writedata>:
 * @note This function help not to access wrong address. If you do not describe this function or register any functions,
 * null function is called.
 */
//M20150601 : Rename the function for integrating with W5300
//void 	wizchip_bus_writebyte(uint32_t AddrSel, uint8_t wb)  { *((volatile uint8_t*)((ptrdiff_t)AddrSel)) = wb; }
void 	wizchip_bus_writedata(uint32_t AddrSel, iodata_t wb)  { *((volatile iodata_t*)((ptrdiff_t)AddrSel)) = wb; }
    344a:	7001      	strb	r1, [r0, #0]
    344c:	4770      	bx	lr

0000344e <wizchip_spi_readbyte>:
 * @brief Default function to read in SPI interface.
 * @note This function help not to access wrong address. If you do not describe this function or register any functions,
 * null function is called.
 */
//uint8_t wizchip_spi_readbyte(void)        {return 0;};
uint8_t wizchip_spi_readbyte(void)        {return 0;}
    344e:	2000      	movs	r0, #0
    3450:	4770      	bx	lr

00003452 <wizchip_spi_writebyte>:
 * @brief Default function to write in SPI interface.
 * @note This function help not to access wrong address. If you do not describe this function or register any functions,
 * null function is called.
 */
//void 	wizchip_spi_writebyte(uint8_t wb) {};
void 	wizchip_spi_writebyte(uint8_t wb) {}
    3452:	4770      	bx	lr

00003454 <wizchip_spi_readburst>:
 * @brief Default function to burst read in SPI interface.
 * @note This function help not to access wrong address. If you do not describe this function or register any functions,
 * null function is called.
 */
//void 	wizchip_spi_readburst(uint8_t* pBuf, uint16_t len) 	{}; 
void 	wizchip_spi_readburst(uint8_t* pBuf, uint16_t len) 	{}
    3454:	4770      	bx	lr

00003456 <wizchip_spi_writeburst>:
 * @brief Default function to burst write in SPI interface.
 * @note This function help not to access wrong address. If you do not describe this function or register any functions,
 * null function is called.
 */
//void 	wizchip_spi_writeburst(uint8_t* pBuf, uint16_t len) {};
void 	wizchip_spi_writeburst(uint8_t* pBuf, uint16_t len) {}
    3456:	4770      	bx	lr

00003458 <reg_wizchip_cs_cbfunc>:
   }
}

void reg_wizchip_cs_cbfunc(void(*cs_sel)(void), void(*cs_desel)(void))
{
   if(!cs_sel || !cs_desel)
    3458:	2800      	cmp	r0, #0
    345a:	d005      	beq.n	3468 <reg_wizchip_cs_cbfunc+0x10>
    345c:	2900      	cmp	r1, #0
    345e:	d003      	beq.n	3468 <reg_wizchip_cs_cbfunc+0x10>
      WIZCHIP.CS._select   = wizchip_cs_select;
      WIZCHIP.CS._deselect = wizchip_cs_deselect;
   }
   else
   {
      WIZCHIP.CS._select   = cs_sel;
    3460:	4b04      	ldr	r3, [pc, #16]	; (3474 <reg_wizchip_cs_cbfunc+0x1c>)
    3462:	6158      	str	r0, [r3, #20]
      WIZCHIP.CS._deselect = cs_desel;
    3464:	6199      	str	r1, [r3, #24]
   }
}
    3466:	4770      	bx	lr
      WIZCHIP.CS._select   = wizchip_cs_select;
    3468:	4b02      	ldr	r3, [pc, #8]	; (3474 <reg_wizchip_cs_cbfunc+0x1c>)
    346a:	4a03      	ldr	r2, [pc, #12]	; (3478 <reg_wizchip_cs_cbfunc+0x20>)
    346c:	615a      	str	r2, [r3, #20]
      WIZCHIP.CS._deselect = wizchip_cs_deselect;
    346e:	4a03      	ldr	r2, [pc, #12]	; (347c <reg_wizchip_cs_cbfunc+0x24>)
    3470:	619a      	str	r2, [r3, #24]
    3472:	e7f8      	b.n	3466 <reg_wizchip_cs_cbfunc+0xe>
    3474:	2000002c 	.word	0x2000002c
    3478:	00003441 	.word	0x00003441
    347c:	00003443 	.word	0x00003443

00003480 <reg_wizchip_spi_cbfunc>:
   }
}

void reg_wizchip_spi_cbfunc(uint8_t (*spi_rb)(void), void (*spi_wb)(uint8_t wb))
{
   while(!(WIZCHIP.if_mode & _WIZCHIP_IO_MODE_SPI_));
    3480:	4b08      	ldr	r3, [pc, #32]	; (34a4 <reg_wizchip_spi_cbfunc+0x24>)
    3482:	881b      	ldrh	r3, [r3, #0]
    3484:	059b      	lsls	r3, r3, #22
    3486:	d5fb      	bpl.n	3480 <reg_wizchip_spi_cbfunc>
   
   if(!spi_rb || !spi_wb)
    3488:	2800      	cmp	r0, #0
    348a:	d005      	beq.n	3498 <reg_wizchip_spi_cbfunc+0x18>
    348c:	2900      	cmp	r1, #0
    348e:	d003      	beq.n	3498 <reg_wizchip_spi_cbfunc+0x18>
      WIZCHIP.IF.SPI._read_byte   = wizchip_spi_readbyte;
      WIZCHIP.IF.SPI._write_byte  = wizchip_spi_writebyte;
   }
   else
   {
      WIZCHIP.IF.SPI._read_byte   = spi_rb;
    3490:	4b04      	ldr	r3, [pc, #16]	; (34a4 <reg_wizchip_spi_cbfunc+0x24>)
    3492:	61d8      	str	r0, [r3, #28]
      WIZCHIP.IF.SPI._write_byte  = spi_wb;
    3494:	6219      	str	r1, [r3, #32]
   }
}
    3496:	4770      	bx	lr
      WIZCHIP.IF.SPI._read_byte   = wizchip_spi_readbyte;
    3498:	4b02      	ldr	r3, [pc, #8]	; (34a4 <reg_wizchip_spi_cbfunc+0x24>)
    349a:	4a03      	ldr	r2, [pc, #12]	; (34a8 <reg_wizchip_spi_cbfunc+0x28>)
    349c:	61da      	str	r2, [r3, #28]
      WIZCHIP.IF.SPI._write_byte  = wizchip_spi_writebyte;
    349e:	4a03      	ldr	r2, [pc, #12]	; (34ac <reg_wizchip_spi_cbfunc+0x2c>)
    34a0:	621a      	str	r2, [r3, #32]
    34a2:	e7f8      	b.n	3496 <reg_wizchip_spi_cbfunc+0x16>
    34a4:	2000002c 	.word	0x2000002c
    34a8:	0000344f 	.word	0x0000344f
    34ac:	00003453 	.word	0x00003453

000034b0 <reg_wizchip_spiburst_cbfunc>:

// 20140626 Eric Added for SPI burst operations
void reg_wizchip_spiburst_cbfunc(void (*spi_rb)(uint8_t* pBuf, uint16_t len), void (*spi_wb)(uint8_t* pBuf, uint16_t len))
{
   while(!(WIZCHIP.if_mode & _WIZCHIP_IO_MODE_SPI_));
    34b0:	4b08      	ldr	r3, [pc, #32]	; (34d4 <reg_wizchip_spiburst_cbfunc+0x24>)
    34b2:	881b      	ldrh	r3, [r3, #0]
    34b4:	059b      	lsls	r3, r3, #22
    34b6:	d5fb      	bpl.n	34b0 <reg_wizchip_spiburst_cbfunc>

   if(!spi_rb || !spi_wb)
    34b8:	2800      	cmp	r0, #0
    34ba:	d005      	beq.n	34c8 <reg_wizchip_spiburst_cbfunc+0x18>
    34bc:	2900      	cmp	r1, #0
    34be:	d003      	beq.n	34c8 <reg_wizchip_spiburst_cbfunc+0x18>
      WIZCHIP.IF.SPI._read_burst   = wizchip_spi_readburst;
      WIZCHIP.IF.SPI._write_burst  = wizchip_spi_writeburst;
   }
   else
   {
      WIZCHIP.IF.SPI._read_burst   = spi_rb;
    34c0:	4b04      	ldr	r3, [pc, #16]	; (34d4 <reg_wizchip_spiburst_cbfunc+0x24>)
    34c2:	6258      	str	r0, [r3, #36]	; 0x24
      WIZCHIP.IF.SPI._write_burst  = spi_wb;
    34c4:	6299      	str	r1, [r3, #40]	; 0x28
   }
}
    34c6:	4770      	bx	lr
      WIZCHIP.IF.SPI._read_burst   = wizchip_spi_readburst;
    34c8:	4b02      	ldr	r3, [pc, #8]	; (34d4 <reg_wizchip_spiburst_cbfunc+0x24>)
    34ca:	4a03      	ldr	r2, [pc, #12]	; (34d8 <reg_wizchip_spiburst_cbfunc+0x28>)
    34cc:	625a      	str	r2, [r3, #36]	; 0x24
      WIZCHIP.IF.SPI._write_burst  = wizchip_spi_writeburst;
    34ce:	4a03      	ldr	r2, [pc, #12]	; (34dc <reg_wizchip_spiburst_cbfunc+0x2c>)
    34d0:	629a      	str	r2, [r3, #40]	; 0x28
    34d2:	e7f8      	b.n	34c6 <reg_wizchip_spiburst_cbfunc+0x16>
    34d4:	2000002c 	.word	0x2000002c
    34d8:	00003455 	.word	0x00003455
    34dc:	00003457 	.word	0x00003457

000034e0 <wizchip_sw_reset>:
   }
   return 0;
}

void wizchip_sw_reset(void)
{
    34e0:	b5f0      	push	{r4, r5, r6, r7, lr}
    34e2:	b087      	sub	sp, #28
#if _WIZCHIP_IO_MODE_  == _WIZCHIP_IO_MODE_BUS_INDIR_
   uint16_t mr = (uint16_t)getMR();
   setMR(mr | MR_IND);
#endif
//
   getSHAR(mac);
    34e4:	2206      	movs	r2, #6
    34e6:	a901      	add	r1, sp, #4
    34e8:	2090      	movs	r0, #144	; 0x90
    34ea:	0100      	lsls	r0, r0, #4
    34ec:	4c17      	ldr	r4, [pc, #92]	; (354c <wizchip_sw_reset+0x6c>)
    34ee:	47a0      	blx	r4
   getGAR(gw);  getSUBR(sn);  getSIPR(sip);
    34f0:	2780      	movs	r7, #128	; 0x80
    34f2:	007f      	lsls	r7, r7, #1
    34f4:	2204      	movs	r2, #4
    34f6:	a905      	add	r1, sp, #20
    34f8:	0038      	movs	r0, r7
    34fa:	47a0      	blx	r4
    34fc:	26a0      	movs	r6, #160	; 0xa0
    34fe:	00f6      	lsls	r6, r6, #3
    3500:	2204      	movs	r2, #4
    3502:	a904      	add	r1, sp, #16
    3504:	0030      	movs	r0, r6
    3506:	47a0      	blx	r4
    3508:	25f0      	movs	r5, #240	; 0xf0
    350a:	012d      	lsls	r5, r5, #4
    350c:	2204      	movs	r2, #4
    350e:	a903      	add	r1, sp, #12
    3510:	0028      	movs	r0, r5
    3512:	47a0      	blx	r4
   setMR(MR_RST);
    3514:	2180      	movs	r1, #128	; 0x80
    3516:	2000      	movs	r0, #0
    3518:	4b0d      	ldr	r3, [pc, #52]	; (3550 <wizchip_sw_reset+0x70>)
    351a:	4798      	blx	r3
   getMR(); // for delay
    351c:	2000      	movs	r0, #0
    351e:	4b0d      	ldr	r3, [pc, #52]	; (3554 <wizchip_sw_reset+0x74>)
    3520:	4798      	blx	r3
//A2015051 : For indirect bus mode 
#if _WIZCHIP_IO_MODE_  == _WIZCHIP_IO_MODE_BUS_INDIR_
   setMR(mr | MR_IND);
#endif
//
   setSHAR(mac);
    3522:	2206      	movs	r2, #6
    3524:	a901      	add	r1, sp, #4
    3526:	2090      	movs	r0, #144	; 0x90
    3528:	0100      	lsls	r0, r0, #4
    352a:	4c0b      	ldr	r4, [pc, #44]	; (3558 <wizchip_sw_reset+0x78>)
    352c:	47a0      	blx	r4
   setGAR(gw);
    352e:	2204      	movs	r2, #4
    3530:	a905      	add	r1, sp, #20
    3532:	0038      	movs	r0, r7
    3534:	47a0      	blx	r4
   setSUBR(sn);
    3536:	2204      	movs	r2, #4
    3538:	a904      	add	r1, sp, #16
    353a:	0030      	movs	r0, r6
    353c:	47a0      	blx	r4
   setSIPR(sip);
    353e:	2204      	movs	r2, #4
    3540:	a903      	add	r1, sp, #12
    3542:	0028      	movs	r0, r5
    3544:	47a0      	blx	r4
}
    3546:	b007      	add	sp, #28
    3548:	bdf0      	pop	{r4, r5, r6, r7, pc}
    354a:	46c0      	nop			; (mov r8, r8)
    354c:	00003129 	.word	0x00003129
    3550:	000030c9 	.word	0x000030c9
    3554:	00003065 	.word	0x00003065
    3558:	000031a9 	.word	0x000031a9

0000355c <wizchip_init>:

int8_t wizchip_init(uint8_t* txsize, uint8_t* rxsize)
{
    355c:	b570      	push	{r4, r5, r6, lr}
    355e:	0006      	movs	r6, r0
    3560:	000d      	movs	r5, r1
   int8_t i;
#if _WIZCHIP_ < W5200
   int8_t j;
#endif
   int8_t tmp = 0;
   wizchip_sw_reset();
    3562:	4b24      	ldr	r3, [pc, #144]	; (35f4 <wizchip_init+0x98>)
    3564:	4798      	blx	r3
   if(txsize)
    3566:	2e00      	cmp	r6, #0
    3568:	d01b      	beq.n	35a2 <wizchip_init+0x46>
    356a:	2200      	movs	r2, #0
    356c:	2300      	movs	r3, #0
			tmp += txsize[i];
			if(tmp > 128) return -1;
		}
		if(tmp % 8) return -1;
#else
		for(i = 0 ; i < _WIZCHIP_SOCK_NUM_; i++)
    356e:	2b07      	cmp	r3, #7
    3570:	dc07      	bgt.n	3582 <wizchip_init+0x26>
		{
			tmp += txsize[i];
    3572:	5cf1      	ldrb	r1, [r6, r3]
    3574:	188a      	adds	r2, r1, r2
    3576:	b252      	sxtb	r2, r2

#if _WIZCHIP_ < W5200	//2016.10.28 peter add condition for w5100 and w5100s
			if(tmp > 8) return -1;
#else
			if(tmp > 16) return -1;
    3578:	2a10      	cmp	r2, #16
    357a:	dc34      	bgt.n	35e6 <wizchip_init+0x8a>
		for(i = 0 ; i < _WIZCHIP_SOCK_NUM_; i++)
    357c:	3301      	adds	r3, #1
    357e:	b25b      	sxtb	r3, r3
    3580:	e7f5      	b.n	356e <wizchip_init+0x12>
    3582:	2400      	movs	r4, #0
    3584:	e00b      	b.n	359e <wizchip_init+0x42>
#if _WIZCHIP_ < W5200	//2016.10.28 peter add condition for w5100
			j = 0;
			while((txsize[i] >> j != 1)&&(txsize[i] !=0)){j++;}
			setSn_TXBUF_SIZE(i, j);
#else
			setSn_TXBUF_SIZE(i, txsize[i]);
    3586:	00a0      	lsls	r0, r4, #2
    3588:	3001      	adds	r0, #1
    358a:	00c0      	lsls	r0, r0, #3
    358c:	23f8      	movs	r3, #248	; 0xf8
    358e:	015b      	lsls	r3, r3, #5
    3590:	469c      	mov	ip, r3
    3592:	4460      	add	r0, ip
    3594:	5d31      	ldrb	r1, [r6, r4]
    3596:	4b18      	ldr	r3, [pc, #96]	; (35f8 <wizchip_init+0x9c>)
    3598:	4798      	blx	r3
		for(i = 0 ; i < _WIZCHIP_SOCK_NUM_; i++)
    359a:	3401      	adds	r4, #1
    359c:	b264      	sxtb	r4, r4
    359e:	2c07      	cmp	r4, #7
    35a0:	ddf1      	ble.n	3586 <wizchip_init+0x2a>
#endif
		}	
   }

   if(rxsize)
    35a2:	2d00      	cmp	r5, #0
    35a4:	d00b      	beq.n	35be <wizchip_init+0x62>
    35a6:	2200      	movs	r2, #0
    35a8:	2300      	movs	r3, #0
			tmp += rxsize[i];
			if(tmp > 128) return -1;
		}
		if(tmp % 8) return -1;
#else
		for(i = 0 ; i < _WIZCHIP_SOCK_NUM_; i++)
    35aa:	2b07      	cmp	r3, #7
    35ac:	dc09      	bgt.n	35c2 <wizchip_init+0x66>
		{
			tmp += rxsize[i];
    35ae:	5ce9      	ldrb	r1, [r5, r3]
    35b0:	188a      	adds	r2, r1, r2
    35b2:	b252      	sxtb	r2, r2
#if _WIZCHIP_ < W5200	//2016.10.28 peter add condition for w5100 and w5100s
			if(tmp > 8) return -1;
#else
			if(tmp > 16) return -1;
    35b4:	2a10      	cmp	r2, #16
    35b6:	dc19      	bgt.n	35ec <wizchip_init+0x90>
		for(i = 0 ; i < _WIZCHIP_SOCK_NUM_; i++)
    35b8:	3301      	adds	r3, #1
    35ba:	b25b      	sxtb	r3, r3
    35bc:	e7f5      	b.n	35aa <wizchip_init+0x4e>
#else
			setSn_RXBUF_SIZE(i, rxsize[i]);
#endif
		}
   }
   return 0;
    35be:	2000      	movs	r0, #0
    35c0:	e010      	b.n	35e4 <wizchip_init+0x88>
    35c2:	2400      	movs	r4, #0
    35c4:	e00b      	b.n	35de <wizchip_init+0x82>
			setSn_RXBUF_SIZE(i, rxsize[i]);
    35c6:	00a0      	lsls	r0, r4, #2
    35c8:	3001      	adds	r0, #1
    35ca:	00c0      	lsls	r0, r0, #3
    35cc:	23f0      	movs	r3, #240	; 0xf0
    35ce:	015b      	lsls	r3, r3, #5
    35d0:	469c      	mov	ip, r3
    35d2:	4460      	add	r0, ip
    35d4:	5d29      	ldrb	r1, [r5, r4]
    35d6:	4b08      	ldr	r3, [pc, #32]	; (35f8 <wizchip_init+0x9c>)
    35d8:	4798      	blx	r3
		for(i = 0 ; i < _WIZCHIP_SOCK_NUM_; i++)
    35da:	3401      	adds	r4, #1
    35dc:	b264      	sxtb	r4, r4
    35de:	2c07      	cmp	r4, #7
    35e0:	ddf1      	ble.n	35c6 <wizchip_init+0x6a>
   return 0;
    35e2:	2000      	movs	r0, #0
}
    35e4:	bd70      	pop	{r4, r5, r6, pc}
			if(tmp > 16) return -1;
    35e6:	2001      	movs	r0, #1
    35e8:	4240      	negs	r0, r0
    35ea:	e7fb      	b.n	35e4 <wizchip_init+0x88>
			if(tmp > 16) return -1;
    35ec:	2001      	movs	r0, #1
    35ee:	4240      	negs	r0, r0
    35f0:	e7f8      	b.n	35e4 <wizchip_init+0x88>
    35f2:	46c0      	nop			; (mov r8, r8)
    35f4:	000034e1 	.word	0x000034e1
    35f8:	000030c9 	.word	0x000030c9

000035fc <wizchip_clrinterrupt>:

void wizchip_clrinterrupt(intr_kind intr)
{
    35fc:	b570      	push	{r4, r5, r6, lr}
   uint8_t ir  = (uint8_t)intr;
    35fe:	b2c1      	uxtb	r1, r0
   uint8_t sir = (uint8_t)((uint16_t)intr >> 8);
    3600:	0a05      	lsrs	r5, r0, #8
   setIR(ir);
//A20150601 : For integrating with W5300
#elif _WIZCHIP_ == W5300
   setIR( ((((uint16_t)ir) << 8) | (((uint16_t)sir) & 0x00FF)) );
#else
   setIR(ir);
    3602:	230f      	movs	r3, #15
    3604:	4399      	bics	r1, r3
    3606:	20a8      	movs	r0, #168	; 0xa8
    3608:	0140      	lsls	r0, r0, #5
    360a:	4b0c      	ldr	r3, [pc, #48]	; (363c <wizchip_clrinterrupt+0x40>)
    360c:	4798      	blx	r3
//M20200227 : For clear
   //setSIR(sir);
   for(ir=0; ir<8; ir++){
    360e:	2400      	movs	r4, #0
    3610:	e001      	b.n	3616 <wizchip_clrinterrupt+0x1a>
    3612:	3401      	adds	r4, #1
    3614:	b2e4      	uxtb	r4, r4
    3616:	2c07      	cmp	r4, #7
    3618:	d80e      	bhi.n	3638 <wizchip_clrinterrupt+0x3c>
       if(sir & (0x01 <<ir) ) setSn_IR(ir, 0xff);
    361a:	002b      	movs	r3, r5
    361c:	4123      	asrs	r3, r4
    361e:	07db      	lsls	r3, r3, #31
    3620:	d5f7      	bpl.n	3612 <wizchip_clrinterrupt+0x16>
    3622:	00a0      	lsls	r0, r4, #2
    3624:	3001      	adds	r0, #1
    3626:	00c0      	lsls	r0, r0, #3
    3628:	2380      	movs	r3, #128	; 0x80
    362a:	009b      	lsls	r3, r3, #2
    362c:	469c      	mov	ip, r3
    362e:	4460      	add	r0, ip
    3630:	211f      	movs	r1, #31
    3632:	4b02      	ldr	r3, [pc, #8]	; (363c <wizchip_clrinterrupt+0x40>)
    3634:	4798      	blx	r3
    3636:	e7ec      	b.n	3612 <wizchip_clrinterrupt+0x16>
   }

#endif   
}
    3638:	bd70      	pop	{r4, r5, r6, pc}
    363a:	46c0      	nop			; (mov r8, r8)
    363c:	000030c9 	.word	0x000030c9

00003640 <wizchip_getinterrupt>:

intr_kind wizchip_getinterrupt(void)
{
    3640:	b570      	push	{r4, r5, r6, lr}
#elif _WIZCHIP_  == W5300
   ret = getIR();
   ir = (uint8_t)(ret >> 8);
   sir = (uint8_t)ret;
#else
   ir  = getIR();
    3642:	20a8      	movs	r0, #168	; 0xa8
    3644:	0140      	lsls	r0, r0, #5
    3646:	4d07      	ldr	r5, [pc, #28]	; (3664 <wizchip_getinterrupt+0x24>)
    3648:	47a8      	blx	r5
    364a:	230f      	movs	r3, #15
    364c:	4398      	bics	r0, r3
    364e:	b2c4      	uxtb	r4, r0
   sir = getSIR();
    3650:	20b8      	movs	r0, #184	; 0xb8
    3652:	0140      	lsls	r0, r0, #5
    3654:	47a8      	blx	r5
   ir &= ~(1<<4); // IK_WOL
#endif
#if _WIZCHIP_ == W5200
   ir &= ~(1 << 6);
#endif
  ret = sir;
    3656:	b280      	uxth	r0, r0
  ret = (ret << 8) + ir;
    3658:	0200      	lsls	r0, r0, #8
    365a:	b280      	uxth	r0, r0
    365c:	1820      	adds	r0, r4, r0
    365e:	b280      	uxth	r0, r0
  return (intr_kind)ret;
}
    3660:	bd70      	pop	{r4, r5, r6, pc}
    3662:	46c0      	nop			; (mov r8, r8)
    3664:	00003065 	.word	0x00003065

00003668 <wizchip_setinterruptmask>:

void wizchip_setinterruptmask(intr_kind intr)
{
    3668:	b570      	push	{r4, r5, r6, lr}
   uint8_t imr  = (uint8_t)intr;
    366a:	b2c1      	uxtb	r1, r0
   uint8_t simr = (uint8_t)((uint16_t)intr >> 8);
    366c:	0a04      	lsrs	r4, r0, #8
   setIMR(imr);
//A20150601 : For integrating with W5300
#elif _WIZCHIP_ == W5300
   setIMR( ((((uint16_t)imr) << 8) | (((uint16_t)simr) & 0x00FF)) );
#else
   setIMR(imr);
    366e:	20b0      	movs	r0, #176	; 0xb0
    3670:	0140      	lsls	r0, r0, #5
    3672:	4d03      	ldr	r5, [pc, #12]	; (3680 <wizchip_setinterruptmask+0x18>)
    3674:	47a8      	blx	r5
   setSIMR(simr);
    3676:	0021      	movs	r1, r4
    3678:	20c0      	movs	r0, #192	; 0xc0
    367a:	0140      	lsls	r0, r0, #5
    367c:	47a8      	blx	r5
#endif   
}
    367e:	bd70      	pop	{r4, r5, r6, pc}
    3680:	000030c9 	.word	0x000030c9

00003684 <wizchip_getinterruptmask>:

intr_kind wizchip_getinterruptmask(void)
{
    3684:	b570      	push	{r4, r5, r6, lr}
#elif _WIZCHIP_ == W5300
   ret = getIMR();
   imr = (uint8_t)(ret >> 8);
   simr = (uint8_t)ret;
#else
   imr  = getIMR();
    3686:	20b0      	movs	r0, #176	; 0xb0
    3688:	0140      	lsls	r0, r0, #5
    368a:	4d06      	ldr	r5, [pc, #24]	; (36a4 <wizchip_getinterruptmask+0x20>)
    368c:	47a8      	blx	r5
    368e:	0004      	movs	r4, r0
   simr = getSIMR();
    3690:	20c0      	movs	r0, #192	; 0xc0
    3692:	0140      	lsls	r0, r0, #5
    3694:	47a8      	blx	r5
   imr &= ~(1<<4); // IK_WOL
#endif
#if _WIZCHIP_ == W5200
   imr &= ~(1 << 6);  // IK_DEST_UNREACH
#endif
  ret = simr;
    3696:	b280      	uxth	r0, r0
  ret = (ret << 8) + imr;
    3698:	0200      	lsls	r0, r0, #8
    369a:	b280      	uxth	r0, r0
    369c:	b2a4      	uxth	r4, r4
    369e:	1900      	adds	r0, r0, r4
    36a0:	b280      	uxth	r0, r0
  return (intr_kind)ret;
}
    36a2:	bd70      	pop	{r4, r5, r6, pc}
    36a4:	00003065 	.word	0x00003065

000036a8 <wizphy_getphylink>:

int8_t wizphy_getphylink(void)
{
    36a8:	b510      	push	{r4, lr}
	   tmp = PHY_LINK_ON;
#elif   _WIZCHIP_ == W5200
   if(getPHYSTATUS() & PHYSTATUS_LINK)
      tmp = PHY_LINK_ON;
#elif _WIZCHIP_ == W5500
   if(getPHYCFGR() & PHYCFGR_LNK_ON)
    36aa:	20b8      	movs	r0, #184	; 0xb8
    36ac:	0180      	lsls	r0, r0, #6
    36ae:	4b04      	ldr	r3, [pc, #16]	; (36c0 <wizphy_getphylink+0x18>)
    36b0:	4798      	blx	r3
    36b2:	07c3      	lsls	r3, r0, #31
    36b4:	d501      	bpl.n	36ba <wizphy_getphylink+0x12>
      tmp = PHY_LINK_ON;
    36b6:	2001      	movs	r0, #1

#else
   tmp = -1;
#endif
   return tmp;
}
    36b8:	bd10      	pop	{r4, pc}
   int8_t tmp = PHY_LINK_OFF;
    36ba:	2000      	movs	r0, #0
    36bc:	e7fc      	b.n	36b8 <wizphy_getphylink+0x10>
    36be:	46c0      	nop			; (mov r8, r8)
    36c0:	00003065 	.word	0x00003065

000036c4 <wizphy_getphypmode>:

#if _WIZCHIP_ > W5100

int8_t wizphy_getphypmode(void)
{
    36c4:	b510      	push	{r4, lr}
      if(getPHYSTATUS() & PHYSTATUS_POWERDOWN)
         tmp = PHY_POWER_DOWN;
      else          
         tmp = PHY_POWER_NORM;
   #elif _WIZCHIP_ == 5500
      if((getPHYCFGR() & PHYCFGR_OPMDC_ALLA) == PHYCFGR_OPMDC_PDOWN)
    36c6:	20b8      	movs	r0, #184	; 0xb8
    36c8:	0180      	lsls	r0, r0, #6
    36ca:	4b05      	ldr	r3, [pc, #20]	; (36e0 <wizphy_getphypmode+0x1c>)
    36cc:	4798      	blx	r3
    36ce:	2338      	movs	r3, #56	; 0x38
    36d0:	4018      	ands	r0, r3
    36d2:	2830      	cmp	r0, #48	; 0x30
    36d4:	d001      	beq.n	36da <wizphy_getphypmode+0x16>
         tmp = PHY_POWER_DOWN;
      else 
         tmp = PHY_POWER_NORM;
    36d6:	2000      	movs	r0, #0
   #else
      tmp = -1;
   #endif
   return tmp;
}
    36d8:	bd10      	pop	{r4, pc}
         tmp = PHY_POWER_DOWN;
    36da:	382f      	subs	r0, #47	; 0x2f
    36dc:	e7fc      	b.n	36d8 <wizphy_getphypmode+0x14>
    36de:	46c0      	nop			; (mov r8, r8)
    36e0:	00003065 	.word	0x00003065

000036e4 <wizphy_reset>:
}

#endif
#if _WIZCHIP_ == W5500
void wizphy_reset(void)
{
    36e4:	b570      	push	{r4, r5, r6, lr}
   uint8_t tmp = getPHYCFGR();
    36e6:	24b8      	movs	r4, #184	; 0xb8
    36e8:	01a4      	lsls	r4, r4, #6
    36ea:	0020      	movs	r0, r4
    36ec:	4e07      	ldr	r6, [pc, #28]	; (370c <wizphy_reset+0x28>)
    36ee:	47b0      	blx	r6
   tmp &= PHYCFGR_RST;
    36f0:	217f      	movs	r1, #127	; 0x7f
    36f2:	4001      	ands	r1, r0
   setPHYCFGR(tmp);
    36f4:	0020      	movs	r0, r4
    36f6:	4d06      	ldr	r5, [pc, #24]	; (3710 <wizphy_reset+0x2c>)
    36f8:	47a8      	blx	r5
   tmp = getPHYCFGR();
    36fa:	0020      	movs	r0, r4
    36fc:	47b0      	blx	r6
   tmp |= ~PHYCFGR_RST;
    36fe:	2180      	movs	r1, #128	; 0x80
    3700:	4249      	negs	r1, r1
    3702:	4301      	orrs	r1, r0
    3704:	b2c9      	uxtb	r1, r1
   setPHYCFGR(tmp);
    3706:	0020      	movs	r0, r4
    3708:	47a8      	blx	r5
}
    370a:	bd70      	pop	{r4, r5, r6, pc}
    370c:	00003065 	.word	0x00003065
    3710:	000030c9 	.word	0x000030c9

00003714 <wizphy_setphyconf>:

void wizphy_setphyconf(wiz_PhyConf* phyconf)
{
    3714:	b510      	push	{r4, lr}
   uint8_t tmp = 0;
   if(phyconf->by == PHY_CONFBY_SW)
    3716:	7803      	ldrb	r3, [r0, #0]
    3718:	2b01      	cmp	r3, #1
    371a:	d010      	beq.n	373e <wizphy_setphyconf+0x2a>
      tmp |= PHYCFGR_OPMD;
   else
      tmp &= ~PHYCFGR_OPMD;
    371c:	2100      	movs	r1, #0
   if(phyconf->mode == PHY_MODE_AUTONEGO)
    371e:	7843      	ldrb	r3, [r0, #1]
    3720:	2b01      	cmp	r3, #1
    3722:	d00e      	beq.n	3742 <wizphy_setphyconf+0x2e>
      tmp |= PHYCFGR_OPMDC_ALLA;
   else
   {
      if(phyconf->duplex == PHY_DUPLEX_FULL)
    3724:	78c3      	ldrb	r3, [r0, #3]
    3726:	2b01      	cmp	r3, #1
    3728:	d00f      	beq.n	374a <wizphy_setphyconf+0x36>
         else
            tmp |= PHYCFGR_OPMDC_10F;
      }   
      else
      {
         if(phyconf->speed == PHY_SPEED_100)
    372a:	7883      	ldrb	r3, [r0, #2]
    372c:	2b01      	cmp	r3, #1
    372e:	d017      	beq.n	3760 <wizphy_setphyconf+0x4c>
            tmp |= PHYCFGR_OPMDC_100H;
         else
            tmp |= PHYCFGR_OPMDC_10H;
      }
   }
   setPHYCFGR(tmp);
    3730:	20b8      	movs	r0, #184	; 0xb8
    3732:	0180      	lsls	r0, r0, #6
    3734:	4b0c      	ldr	r3, [pc, #48]	; (3768 <wizphy_setphyconf+0x54>)
    3736:	4798      	blx	r3
   wizphy_reset();
    3738:	4b0c      	ldr	r3, [pc, #48]	; (376c <wizphy_setphyconf+0x58>)
    373a:	4798      	blx	r3
}
    373c:	bd10      	pop	{r4, pc}
      tmp |= PHYCFGR_OPMD;
    373e:	2140      	movs	r1, #64	; 0x40
    3740:	e7ed      	b.n	371e <wizphy_setphyconf+0xa>
      tmp |= PHYCFGR_OPMDC_ALLA;
    3742:	2338      	movs	r3, #56	; 0x38
    3744:	4319      	orrs	r1, r3
    3746:	b2c9      	uxtb	r1, r1
    3748:	e7f2      	b.n	3730 <wizphy_setphyconf+0x1c>
         if(phyconf->speed == PHY_SPEED_100)
    374a:	7883      	ldrb	r3, [r0, #2]
    374c:	2b01      	cmp	r3, #1
    374e:	d003      	beq.n	3758 <wizphy_setphyconf+0x44>
            tmp |= PHYCFGR_OPMDC_10F;
    3750:	2308      	movs	r3, #8
    3752:	4319      	orrs	r1, r3
    3754:	b2c9      	uxtb	r1, r1
    3756:	e7eb      	b.n	3730 <wizphy_setphyconf+0x1c>
            tmp |= PHYCFGR_OPMDC_100F;
    3758:	2318      	movs	r3, #24
    375a:	4319      	orrs	r1, r3
    375c:	b2c9      	uxtb	r1, r1
    375e:	e7e7      	b.n	3730 <wizphy_setphyconf+0x1c>
            tmp |= PHYCFGR_OPMDC_100H;
    3760:	2310      	movs	r3, #16
    3762:	4319      	orrs	r1, r3
    3764:	b2c9      	uxtb	r1, r1
    3766:	e7e3      	b.n	3730 <wizphy_setphyconf+0x1c>
    3768:	000030c9 	.word	0x000030c9
    376c:	000036e5 	.word	0x000036e5

00003770 <wizphy_getphyconf>:

void wizphy_getphyconf(wiz_PhyConf* phyconf)
{
    3770:	b510      	push	{r4, lr}
    3772:	0004      	movs	r4, r0
   uint8_t tmp = 0;
   tmp = getPHYCFGR();
    3774:	20b8      	movs	r0, #184	; 0xb8
    3776:	0180      	lsls	r0, r0, #6
    3778:	4b13      	ldr	r3, [pc, #76]	; (37c8 <wizphy_getphyconf+0x58>)
    377a:	4798      	blx	r3
   phyconf->by   = (tmp & PHYCFGR_OPMD) ? PHY_CONFBY_SW : PHY_CONFBY_HW;
    377c:	0982      	lsrs	r2, r0, #6
    377e:	2301      	movs	r3, #1
    3780:	4013      	ands	r3, r2
    3782:	7023      	strb	r3, [r4, #0]
    3784:	2338      	movs	r3, #56	; 0x38
    3786:	4018      	ands	r0, r3
   switch(tmp & PHYCFGR_OPMDC_ALLA)
    3788:	2820      	cmp	r0, #32
    378a:	d004      	beq.n	3796 <wizphy_getphyconf+0x26>
    378c:	2838      	cmp	r0, #56	; 0x38
    378e:	d002      	beq.n	3796 <wizphy_getphyconf+0x26>
      case PHYCFGR_OPMDC_ALLA:
      case PHYCFGR_OPMDC_100FA: 
         phyconf->mode = PHY_MODE_AUTONEGO;
         break;
      default:
         phyconf->mode = PHY_MODE_MANUAL;
    3790:	2300      	movs	r3, #0
    3792:	7063      	strb	r3, [r4, #1]
         break;
    3794:	e001      	b.n	379a <wizphy_getphyconf+0x2a>
         phyconf->mode = PHY_MODE_AUTONEGO;
    3796:	2301      	movs	r3, #1
    3798:	7063      	strb	r3, [r4, #1]
   }
   switch(tmp & PHYCFGR_OPMDC_ALLA)
    379a:	2818      	cmp	r0, #24
    379c:	d006      	beq.n	37ac <wizphy_getphyconf+0x3c>
    379e:	2820      	cmp	r0, #32
    37a0:	d004      	beq.n	37ac <wizphy_getphyconf+0x3c>
    37a2:	2810      	cmp	r0, #16
    37a4:	d002      	beq.n	37ac <wizphy_getphyconf+0x3c>
      case PHYCFGR_OPMDC_100F:
      case PHYCFGR_OPMDC_100H:
         phyconf->speed = PHY_SPEED_100;
         break;
      default:
         phyconf->speed = PHY_SPEED_10;
    37a6:	2300      	movs	r3, #0
    37a8:	70a3      	strb	r3, [r4, #2]
         break;
    37aa:	e001      	b.n	37b0 <wizphy_getphyconf+0x40>
         phyconf->speed = PHY_SPEED_100;
    37ac:	2301      	movs	r3, #1
    37ae:	70a3      	strb	r3, [r4, #2]
   }
   switch(tmp & PHYCFGR_OPMDC_ALLA)
    37b0:	2818      	cmp	r0, #24
    37b2:	d006      	beq.n	37c2 <wizphy_getphyconf+0x52>
    37b4:	2820      	cmp	r0, #32
    37b6:	d004      	beq.n	37c2 <wizphy_getphyconf+0x52>
    37b8:	2808      	cmp	r0, #8
    37ba:	d002      	beq.n	37c2 <wizphy_getphyconf+0x52>
      case PHYCFGR_OPMDC_100F:
      case PHYCFGR_OPMDC_10F:
         phyconf->duplex = PHY_DUPLEX_FULL;
         break;
      default:
         phyconf->duplex = PHY_DUPLEX_HALF;
    37bc:	2300      	movs	r3, #0
    37be:	70e3      	strb	r3, [r4, #3]
         break;
   }
}
    37c0:	bd10      	pop	{r4, pc}
         phyconf->duplex = PHY_DUPLEX_FULL;
    37c2:	2301      	movs	r3, #1
    37c4:	70e3      	strb	r3, [r4, #3]
         break;
    37c6:	e7fb      	b.n	37c0 <wizphy_getphyconf+0x50>
    37c8:	00003065 	.word	0x00003065

000037cc <wizphy_setphypmode>:
   phyconf->duplex = (tmp & PHYCFGR_DPX_FULL) ? PHY_DUPLEX_FULL : PHY_DUPLEX_HALF;
   phyconf->speed  = (tmp & PHYCFGR_SPD_100) ? PHY_SPEED_100 : PHY_SPEED_10;
}

int8_t wizphy_setphypmode(uint8_t pmode)
{
    37cc:	b570      	push	{r4, r5, r6, lr}
    37ce:	0004      	movs	r4, r0
   uint8_t tmp = 0;
   tmp = getPHYCFGR();
    37d0:	20b8      	movs	r0, #184	; 0xb8
    37d2:	0180      	lsls	r0, r0, #6
    37d4:	4b17      	ldr	r3, [pc, #92]	; (3834 <wizphy_setphypmode+0x68>)
    37d6:	4798      	blx	r3
   if((tmp & PHYCFGR_OPMD)== 0) return -1;
    37d8:	0643      	lsls	r3, r0, #25
    37da:	d527      	bpl.n	382c <wizphy_setphypmode+0x60>
   tmp &= ~PHYCFGR_OPMDC_ALLA;         
    37dc:	2338      	movs	r3, #56	; 0x38
    37de:	4398      	bics	r0, r3
    37e0:	b2c0      	uxtb	r0, r0
   if( pmode == PHY_POWER_DOWN)
    37e2:	2c01      	cmp	r4, #1
    37e4:	d013      	beq.n	380e <wizphy_setphypmode+0x42>
      tmp |= PHYCFGR_OPMDC_PDOWN;
   else
      tmp |= PHYCFGR_OPMDC_ALLA;
    37e6:	2138      	movs	r1, #56	; 0x38
    37e8:	4301      	orrs	r1, r0
    37ea:	b2c9      	uxtb	r1, r1
   setPHYCFGR(tmp);
    37ec:	25b8      	movs	r5, #184	; 0xb8
    37ee:	01ad      	lsls	r5, r5, #6
    37f0:	0028      	movs	r0, r5
    37f2:	4b11      	ldr	r3, [pc, #68]	; (3838 <wizphy_setphypmode+0x6c>)
    37f4:	4798      	blx	r3
   wizphy_reset();
    37f6:	4b11      	ldr	r3, [pc, #68]	; (383c <wizphy_setphypmode+0x70>)
    37f8:	4798      	blx	r3
   tmp = getPHYCFGR();
    37fa:	0028      	movs	r0, r5
    37fc:	4b0d      	ldr	r3, [pc, #52]	; (3834 <wizphy_setphypmode+0x68>)
    37fe:	4798      	blx	r3
   if( pmode == PHY_POWER_DOWN)
    3800:	2c01      	cmp	r4, #1
    3802:	d008      	beq.n	3816 <wizphy_setphypmode+0x4a>
   {
      if(tmp & PHYCFGR_OPMDC_PDOWN) return 0;
   }
   else
   {
      if(tmp & PHYCFGR_OPMDC_ALLA) return 0;
    3804:	2338      	movs	r3, #56	; 0x38
    3806:	4203      	tst	r3, r0
    3808:	d00d      	beq.n	3826 <wizphy_setphypmode+0x5a>
    380a:	2000      	movs	r0, #0
   }
   return -1;
}
    380c:	bd70      	pop	{r4, r5, r6, pc}
      tmp |= PHYCFGR_OPMDC_PDOWN;
    380e:	2130      	movs	r1, #48	; 0x30
    3810:	4301      	orrs	r1, r0
    3812:	b2c9      	uxtb	r1, r1
    3814:	e7ea      	b.n	37ec <wizphy_setphypmode+0x20>
      if(tmp & PHYCFGR_OPMDC_PDOWN) return 0;
    3816:	2330      	movs	r3, #48	; 0x30
    3818:	4203      	tst	r3, r0
    381a:	d001      	beq.n	3820 <wizphy_setphypmode+0x54>
    381c:	2000      	movs	r0, #0
    381e:	e7f5      	b.n	380c <wizphy_setphypmode+0x40>
   return -1;
    3820:	2001      	movs	r0, #1
    3822:	4240      	negs	r0, r0
    3824:	e7f2      	b.n	380c <wizphy_setphypmode+0x40>
    3826:	2001      	movs	r0, #1
    3828:	4240      	negs	r0, r0
    382a:	e7ef      	b.n	380c <wizphy_setphypmode+0x40>
   if((tmp & PHYCFGR_OPMD)== 0) return -1;
    382c:	2001      	movs	r0, #1
    382e:	4240      	negs	r0, r0
    3830:	e7ec      	b.n	380c <wizphy_setphypmode+0x40>
    3832:	46c0      	nop			; (mov r8, r8)
    3834:	00003065 	.word	0x00003065
    3838:	000030c9 	.word	0x000030c9
    383c:	000036e5 	.word	0x000036e5

00003840 <ctlwizchip>:
{
    3840:	b570      	push	{r4, r5, r6, lr}
    3842:	b082      	sub	sp, #8
    3844:	000c      	movs	r4, r1
   uint8_t* ptmp[2] = {0,0};
    3846:	2300      	movs	r3, #0
    3848:	9300      	str	r3, [sp, #0]
    384a:	9301      	str	r3, [sp, #4]
   switch(cwtype)
    384c:	280f      	cmp	r0, #15
    384e:	d803      	bhi.n	3858 <ctlwizchip+0x18>
    3850:	0080      	lsls	r0, r0, #2
    3852:	4b3f      	ldr	r3, [pc, #252]	; (3950 <ctlwizchip+0x110>)
    3854:	581b      	ldr	r3, [r3, r0]
    3856:	469f      	mov	pc, r3
         return -1;
    3858:	2001      	movs	r0, #1
    385a:	4240      	negs	r0, r0
    385c:	e070      	b.n	3940 <ctlwizchip+0x100>
         wizchip_sw_reset();
    385e:	4b3d      	ldr	r3, [pc, #244]	; (3954 <ctlwizchip+0x114>)
    3860:	4798      	blx	r3
   return 0;
    3862:	2000      	movs	r0, #0
         break;
    3864:	e06c      	b.n	3940 <ctlwizchip+0x100>
         if(arg != 0) 
    3866:	2900      	cmp	r1, #0
    3868:	d002      	beq.n	3870 <ctlwizchip+0x30>
            ptmp[0] = (uint8_t*)arg;
    386a:	9100      	str	r1, [sp, #0]
            ptmp[1] = ptmp[0] + _WIZCHIP_SOCK_NUM_;
    386c:	3408      	adds	r4, #8
    386e:	9401      	str	r4, [sp, #4]
         return wizchip_init(ptmp[0], ptmp[1]);
    3870:	9901      	ldr	r1, [sp, #4]
    3872:	9800      	ldr	r0, [sp, #0]
    3874:	4b38      	ldr	r3, [pc, #224]	; (3958 <ctlwizchip+0x118>)
    3876:	4798      	blx	r3
    3878:	e062      	b.n	3940 <ctlwizchip+0x100>
         wizchip_clrinterrupt(*((intr_kind*)arg));
    387a:	8808      	ldrh	r0, [r1, #0]
    387c:	4b37      	ldr	r3, [pc, #220]	; (395c <ctlwizchip+0x11c>)
    387e:	4798      	blx	r3
   return 0;
    3880:	2000      	movs	r0, #0
         break;
    3882:	e05d      	b.n	3940 <ctlwizchip+0x100>
        *((intr_kind*)arg) = wizchip_getinterrupt();
    3884:	4b36      	ldr	r3, [pc, #216]	; (3960 <ctlwizchip+0x120>)
    3886:	4798      	blx	r3
    3888:	8020      	strh	r0, [r4, #0]
   return 0;
    388a:	2000      	movs	r0, #0
         break;
    388c:	e058      	b.n	3940 <ctlwizchip+0x100>
         wizchip_setinterruptmask(*((intr_kind*)arg));
    388e:	8808      	ldrh	r0, [r1, #0]
    3890:	4b34      	ldr	r3, [pc, #208]	; (3964 <ctlwizchip+0x124>)
    3892:	4798      	blx	r3
   return 0;
    3894:	2000      	movs	r0, #0
         break;         
    3896:	e053      	b.n	3940 <ctlwizchip+0x100>
         *((intr_kind*)arg) = wizchip_getinterruptmask();
    3898:	4b33      	ldr	r3, [pc, #204]	; (3968 <ctlwizchip+0x128>)
    389a:	4798      	blx	r3
    389c:	8020      	strh	r0, [r4, #0]
   return 0;
    389e:	2000      	movs	r0, #0
         break;
    38a0:	e04e      	b.n	3940 <ctlwizchip+0x100>
         setINTLEVEL(*(uint16_t*)arg);
    38a2:	8809      	ldrh	r1, [r1, #0]
    38a4:	0a09      	lsrs	r1, r1, #8
    38a6:	2098      	movs	r0, #152	; 0x98
    38a8:	0140      	lsls	r0, r0, #5
    38aa:	4d30      	ldr	r5, [pc, #192]	; (396c <ctlwizchip+0x12c>)
    38ac:	47a8      	blx	r5
    38ae:	7821      	ldrb	r1, [r4, #0]
    38b0:	20a0      	movs	r0, #160	; 0xa0
    38b2:	0140      	lsls	r0, r0, #5
    38b4:	47a8      	blx	r5
   return 0;
    38b6:	2000      	movs	r0, #0
         break;
    38b8:	e042      	b.n	3940 <ctlwizchip+0x100>
         *(uint16_t*)arg = getINTLEVEL();
    38ba:	2098      	movs	r0, #152	; 0x98
    38bc:	0140      	lsls	r0, r0, #5
    38be:	4e2c      	ldr	r6, [pc, #176]	; (3970 <ctlwizchip+0x130>)
    38c0:	47b0      	blx	r6
    38c2:	b280      	uxth	r0, r0
    38c4:	0200      	lsls	r0, r0, #8
    38c6:	b285      	uxth	r5, r0
    38c8:	20a0      	movs	r0, #160	; 0xa0
    38ca:	0140      	lsls	r0, r0, #5
    38cc:	47b0      	blx	r6
    38ce:	b280      	uxth	r0, r0
    38d0:	182d      	adds	r5, r5, r0
    38d2:	8025      	strh	r5, [r4, #0]
   return 0;
    38d4:	2000      	movs	r0, #0
         break;
    38d6:	e033      	b.n	3940 <ctlwizchip+0x100>
         ((uint8_t*)arg)[0] = WIZCHIP.id[0];
    38d8:	4b26      	ldr	r3, [pc, #152]	; (3974 <ctlwizchip+0x134>)
    38da:	789a      	ldrb	r2, [r3, #2]
    38dc:	700a      	strb	r2, [r1, #0]
         ((uint8_t*)arg)[1] = WIZCHIP.id[1];
    38de:	78da      	ldrb	r2, [r3, #3]
    38e0:	704a      	strb	r2, [r1, #1]
         ((uint8_t*)arg)[2] = WIZCHIP.id[2];
    38e2:	791a      	ldrb	r2, [r3, #4]
    38e4:	708a      	strb	r2, [r1, #2]
         ((uint8_t*)arg)[3] = WIZCHIP.id[3];
    38e6:	795a      	ldrb	r2, [r3, #5]
    38e8:	70ca      	strb	r2, [r1, #3]
         ((uint8_t*)arg)[4] = WIZCHIP.id[4];
    38ea:	799a      	ldrb	r2, [r3, #6]
    38ec:	710a      	strb	r2, [r1, #4]
         ((uint8_t*)arg)[5] = WIZCHIP.id[5];
    38ee:	79db      	ldrb	r3, [r3, #7]
    38f0:	714b      	strb	r3, [r1, #5]
         ((uint8_t*)arg)[6] = 0;
    38f2:	2300      	movs	r3, #0
    38f4:	718b      	strb	r3, [r1, #6]
   return 0;
    38f6:	2000      	movs	r0, #0
         break;
    38f8:	e022      	b.n	3940 <ctlwizchip+0x100>
         wizphy_reset();
    38fa:	4b1f      	ldr	r3, [pc, #124]	; (3978 <ctlwizchip+0x138>)
    38fc:	4798      	blx	r3
   return 0;
    38fe:	2000      	movs	r0, #0
         break;
    3900:	e01e      	b.n	3940 <ctlwizchip+0x100>
         wizphy_setphyconf((wiz_PhyConf*)arg);
    3902:	0008      	movs	r0, r1
    3904:	4b1d      	ldr	r3, [pc, #116]	; (397c <ctlwizchip+0x13c>)
    3906:	4798      	blx	r3
   return 0;
    3908:	2000      	movs	r0, #0
         break;
    390a:	e019      	b.n	3940 <ctlwizchip+0x100>
         wizphy_getphyconf((wiz_PhyConf*)arg);
    390c:	0008      	movs	r0, r1
    390e:	4b1c      	ldr	r3, [pc, #112]	; (3980 <ctlwizchip+0x140>)
    3910:	4798      	blx	r3
   return 0;
    3912:	2000      	movs	r0, #0
         break;
    3914:	e014      	b.n	3940 <ctlwizchip+0x100>
         return wizphy_setphypmode(*(uint8_t*)arg);
    3916:	7808      	ldrb	r0, [r1, #0]
    3918:	4b1a      	ldr	r3, [pc, #104]	; (3984 <ctlwizchip+0x144>)
    391a:	4798      	blx	r3
    391c:	e010      	b.n	3940 <ctlwizchip+0x100>
         tmp = wizphy_getphypmode();
    391e:	4b1a      	ldr	r3, [pc, #104]	; (3988 <ctlwizchip+0x148>)
    3920:	4798      	blx	r3
    3922:	b2c0      	uxtb	r0, r0
         if((int8_t)tmp == -1) return -1;
    3924:	28ff      	cmp	r0, #255	; 0xff
    3926:	d00d      	beq.n	3944 <ctlwizchip+0x104>
         *(uint8_t*)arg = tmp;
    3928:	7020      	strb	r0, [r4, #0]
   return 0;
    392a:	2000      	movs	r0, #0
         break;
    392c:	e008      	b.n	3940 <ctlwizchip+0x100>
         tmp = wizphy_getphylink();
    392e:	4b17      	ldr	r3, [pc, #92]	; (398c <ctlwizchip+0x14c>)
    3930:	4798      	blx	r3
    3932:	b2c0      	uxtb	r0, r0
         if((int8_t)tmp == -1) return -1;
    3934:	28ff      	cmp	r0, #255	; 0xff
    3936:	d008      	beq.n	394a <ctlwizchip+0x10a>
         *(uint8_t*)arg = tmp;
    3938:	7020      	strb	r0, [r4, #0]
   return 0;
    393a:	2000      	movs	r0, #0
         break;
    393c:	e000      	b.n	3940 <ctlwizchip+0x100>
   return 0;
    393e:	2000      	movs	r0, #0
}
    3940:	b002      	add	sp, #8
    3942:	bd70      	pop	{r4, r5, r6, pc}
         if((int8_t)tmp == -1) return -1;
    3944:	2001      	movs	r0, #1
    3946:	4240      	negs	r0, r0
    3948:	e7fa      	b.n	3940 <ctlwizchip+0x100>
         if((int8_t)tmp == -1) return -1;
    394a:	2001      	movs	r0, #1
    394c:	4240      	negs	r0, r0
    394e:	e7f7      	b.n	3940 <ctlwizchip+0x100>
    3950:	00004b58 	.word	0x00004b58
    3954:	000034e1 	.word	0x000034e1
    3958:	0000355d 	.word	0x0000355d
    395c:	000035fd 	.word	0x000035fd
    3960:	00003641 	.word	0x00003641
    3964:	00003669 	.word	0x00003669
    3968:	00003685 	.word	0x00003685
    396c:	000030c9 	.word	0x000030c9
    3970:	00003065 	.word	0x00003065
    3974:	2000002c 	.word	0x2000002c
    3978:	000036e5 	.word	0x000036e5
    397c:	00003715 	.word	0x00003715
    3980:	00003771 	.word	0x00003771
    3984:	000037cd 	.word	0x000037cd
    3988:	000036c5 	.word	0x000036c5
    398c:	000036a9 	.word	0x000036a9

00003990 <wizchip_setnetinfo>:
#endif


void wizchip_setnetinfo(wiz_NetInfo* pnetinfo)
{
    3990:	b570      	push	{r4, r5, r6, lr}
    3992:	0004      	movs	r4, r0
   setSHAR(pnetinfo->mac);
    3994:	2206      	movs	r2, #6
    3996:	0001      	movs	r1, r0
    3998:	2090      	movs	r0, #144	; 0x90
    399a:	0100      	lsls	r0, r0, #4
    399c:	4d0f      	ldr	r5, [pc, #60]	; (39dc <wizchip_setnetinfo+0x4c>)
    399e:	47a8      	blx	r5
   setGAR(pnetinfo->gw);
    39a0:	0021      	movs	r1, r4
    39a2:	310e      	adds	r1, #14
    39a4:	2204      	movs	r2, #4
    39a6:	2080      	movs	r0, #128	; 0x80
    39a8:	0040      	lsls	r0, r0, #1
    39aa:	47a8      	blx	r5
   setSUBR(pnetinfo->sn);
    39ac:	0021      	movs	r1, r4
    39ae:	310a      	adds	r1, #10
    39b0:	2204      	movs	r2, #4
    39b2:	20a0      	movs	r0, #160	; 0xa0
    39b4:	00c0      	lsls	r0, r0, #3
    39b6:	47a8      	blx	r5
   setSIPR(pnetinfo->ip);
    39b8:	1da1      	adds	r1, r4, #6
    39ba:	2204      	movs	r2, #4
    39bc:	20f0      	movs	r0, #240	; 0xf0
    39be:	0100      	lsls	r0, r0, #4
    39c0:	47a8      	blx	r5
   _DNS_[0] = pnetinfo->dns[0];
    39c2:	7ca2      	ldrb	r2, [r4, #18]
    39c4:	4b06      	ldr	r3, [pc, #24]	; (39e0 <wizchip_setnetinfo+0x50>)
    39c6:	701a      	strb	r2, [r3, #0]
   _DNS_[1] = pnetinfo->dns[1];
    39c8:	7ce2      	ldrb	r2, [r4, #19]
    39ca:	705a      	strb	r2, [r3, #1]
   _DNS_[2] = pnetinfo->dns[2];
    39cc:	7d22      	ldrb	r2, [r4, #20]
    39ce:	709a      	strb	r2, [r3, #2]
   _DNS_[3] = pnetinfo->dns[3];
    39d0:	7d62      	ldrb	r2, [r4, #21]
    39d2:	70da      	strb	r2, [r3, #3]
   _DHCP_   = pnetinfo->dhcp;
    39d4:	7da2      	ldrb	r2, [r4, #22]
    39d6:	711a      	strb	r2, [r3, #4]
}
    39d8:	bd70      	pop	{r4, r5, r6, pc}
    39da:	46c0      	nop			; (mov r8, r8)
    39dc:	000031a9 	.word	0x000031a9
    39e0:	20000164 	.word	0x20000164

000039e4 <wizchip_getnetinfo>:

void wizchip_getnetinfo(wiz_NetInfo* pnetinfo)
{
    39e4:	b570      	push	{r4, r5, r6, lr}
    39e6:	0004      	movs	r4, r0
   getSHAR(pnetinfo->mac);
    39e8:	2206      	movs	r2, #6
    39ea:	0001      	movs	r1, r0
    39ec:	2090      	movs	r0, #144	; 0x90
    39ee:	0100      	lsls	r0, r0, #4
    39f0:	4d0f      	ldr	r5, [pc, #60]	; (3a30 <wizchip_getnetinfo+0x4c>)
    39f2:	47a8      	blx	r5
   getGAR(pnetinfo->gw);
    39f4:	0021      	movs	r1, r4
    39f6:	310e      	adds	r1, #14
    39f8:	2204      	movs	r2, #4
    39fa:	2080      	movs	r0, #128	; 0x80
    39fc:	0040      	lsls	r0, r0, #1
    39fe:	47a8      	blx	r5
   getSUBR(pnetinfo->sn);
    3a00:	0021      	movs	r1, r4
    3a02:	310a      	adds	r1, #10
    3a04:	2204      	movs	r2, #4
    3a06:	20a0      	movs	r0, #160	; 0xa0
    3a08:	00c0      	lsls	r0, r0, #3
    3a0a:	47a8      	blx	r5
   getSIPR(pnetinfo->ip);
    3a0c:	1da1      	adds	r1, r4, #6
    3a0e:	2204      	movs	r2, #4
    3a10:	20f0      	movs	r0, #240	; 0xf0
    3a12:	0100      	lsls	r0, r0, #4
    3a14:	47a8      	blx	r5
   pnetinfo->dns[0]= _DNS_[0];
    3a16:	4b07      	ldr	r3, [pc, #28]	; (3a34 <wizchip_getnetinfo+0x50>)
    3a18:	781a      	ldrb	r2, [r3, #0]
    3a1a:	74a2      	strb	r2, [r4, #18]
   pnetinfo->dns[1]= _DNS_[1];
    3a1c:	785a      	ldrb	r2, [r3, #1]
    3a1e:	74e2      	strb	r2, [r4, #19]
   pnetinfo->dns[2]= _DNS_[2];
    3a20:	789a      	ldrb	r2, [r3, #2]
    3a22:	7522      	strb	r2, [r4, #20]
   pnetinfo->dns[3]= _DNS_[3];
    3a24:	78da      	ldrb	r2, [r3, #3]
    3a26:	7562      	strb	r2, [r4, #21]
   pnetinfo->dhcp  = _DHCP_;
    3a28:	791b      	ldrb	r3, [r3, #4]
    3a2a:	75a3      	strb	r3, [r4, #22]
}
    3a2c:	bd70      	pop	{r4, r5, r6, pc}
    3a2e:	46c0      	nop			; (mov r8, r8)
    3a30:	00003129 	.word	0x00003129
    3a34:	20000164 	.word	0x20000164

00003a38 <wizchip_setnetmode>:

int8_t wizchip_setnetmode(netmode_type netmode)
{
    3a38:	b510      	push	{r4, lr}
    3a3a:	0004      	movs	r4, r0
   uint8_t tmp = 0;
#if _WIZCHIP_ != W5500
   if(netmode & ~(NM_WAKEONLAN | NM_PPPOE | NM_PINGBLOCK)) return -1;
#else
   if(netmode & ~(NM_WAKEONLAN | NM_PPPOE | NM_PINGBLOCK | NM_FORCEARP)) return -1;
    3a3c:	233a      	movs	r3, #58	; 0x3a
    3a3e:	0002      	movs	r2, r0
    3a40:	439a      	bics	r2, r3
    3a42:	d109      	bne.n	3a58 <wizchip_setnetmode+0x20>
#endif      
   tmp = getMR();
    3a44:	2000      	movs	r0, #0
    3a46:	4b06      	ldr	r3, [pc, #24]	; (3a60 <wizchip_setnetmode+0x28>)
    3a48:	4798      	blx	r3
   tmp |= (uint8_t)netmode;
    3a4a:	4304      	orrs	r4, r0
    3a4c:	b2e1      	uxtb	r1, r4
   setMR(tmp);
    3a4e:	2000      	movs	r0, #0
    3a50:	4b04      	ldr	r3, [pc, #16]	; (3a64 <wizchip_setnetmode+0x2c>)
    3a52:	4798      	blx	r3
   return 0;
    3a54:	2000      	movs	r0, #0
}
    3a56:	bd10      	pop	{r4, pc}
   if(netmode & ~(NM_WAKEONLAN | NM_PPPOE | NM_PINGBLOCK | NM_FORCEARP)) return -1;
    3a58:	2001      	movs	r0, #1
    3a5a:	4240      	negs	r0, r0
    3a5c:	e7fb      	b.n	3a56 <wizchip_setnetmode+0x1e>
    3a5e:	46c0      	nop			; (mov r8, r8)
    3a60:	00003065 	.word	0x00003065
    3a64:	000030c9 	.word	0x000030c9

00003a68 <wizchip_getnetmode>:

netmode_type wizchip_getnetmode(void)
{
    3a68:	b510      	push	{r4, lr}
   return (netmode_type) getMR();
    3a6a:	2000      	movs	r0, #0
    3a6c:	4b01      	ldr	r3, [pc, #4]	; (3a74 <wizchip_getnetmode+0xc>)
    3a6e:	4798      	blx	r3
}
    3a70:	bd10      	pop	{r4, pc}
    3a72:	46c0      	nop			; (mov r8, r8)
    3a74:	00003065 	.word	0x00003065

00003a78 <wizchip_settimeout>:

void wizchip_settimeout(wiz_NetTimeout* nettime)
{
    3a78:	b570      	push	{r4, r5, r6, lr}
    3a7a:	0005      	movs	r5, r0
   setRCR(nettime->retry_cnt);
    3a7c:	7801      	ldrb	r1, [r0, #0]
    3a7e:	20d8      	movs	r0, #216	; 0xd8
    3a80:	0140      	lsls	r0, r0, #5
    3a82:	4c06      	ldr	r4, [pc, #24]	; (3a9c <wizchip_settimeout+0x24>)
    3a84:	47a0      	blx	r4
   setRTR(nettime->time_100us);
    3a86:	8869      	ldrh	r1, [r5, #2]
    3a88:	0a09      	lsrs	r1, r1, #8
    3a8a:	20c8      	movs	r0, #200	; 0xc8
    3a8c:	0140      	lsls	r0, r0, #5
    3a8e:	47a0      	blx	r4
    3a90:	78a9      	ldrb	r1, [r5, #2]
    3a92:	20d0      	movs	r0, #208	; 0xd0
    3a94:	0140      	lsls	r0, r0, #5
    3a96:	47a0      	blx	r4
}
    3a98:	bd70      	pop	{r4, r5, r6, pc}
    3a9a:	46c0      	nop			; (mov r8, r8)
    3a9c:	000030c9 	.word	0x000030c9

00003aa0 <wizchip_gettimeout>:

void wizchip_gettimeout(wiz_NetTimeout* nettime)
{
    3aa0:	b570      	push	{r4, r5, r6, lr}
    3aa2:	0005      	movs	r5, r0
   nettime->retry_cnt = getRCR();
    3aa4:	20d8      	movs	r0, #216	; 0xd8
    3aa6:	0140      	lsls	r0, r0, #5
    3aa8:	4e07      	ldr	r6, [pc, #28]	; (3ac8 <wizchip_gettimeout+0x28>)
    3aaa:	47b0      	blx	r6
    3aac:	7028      	strb	r0, [r5, #0]
   nettime->time_100us = getRTR();
    3aae:	20c8      	movs	r0, #200	; 0xc8
    3ab0:	0140      	lsls	r0, r0, #5
    3ab2:	47b0      	blx	r6
    3ab4:	b280      	uxth	r0, r0
    3ab6:	0200      	lsls	r0, r0, #8
    3ab8:	b284      	uxth	r4, r0
    3aba:	20d0      	movs	r0, #208	; 0xd0
    3abc:	0140      	lsls	r0, r0, #5
    3abe:	47b0      	blx	r6
    3ac0:	b280      	uxth	r0, r0
    3ac2:	1824      	adds	r4, r4, r0
    3ac4:	806c      	strh	r4, [r5, #2]
}
    3ac6:	bd70      	pop	{r4, r5, r6, pc}
    3ac8:	00003065 	.word	0x00003065

00003acc <ctlnetwork>:
{
    3acc:	b510      	push	{r4, lr}
    3ace:	000c      	movs	r4, r1
   switch(cntype)
    3ad0:	2805      	cmp	r0, #5
    3ad2:	d820      	bhi.n	3b16 <ctlnetwork+0x4a>
    3ad4:	0080      	lsls	r0, r0, #2
    3ad6:	4b11      	ldr	r3, [pc, #68]	; (3b1c <ctlnetwork+0x50>)
    3ad8:	581b      	ldr	r3, [r3, r0]
    3ada:	469f      	mov	pc, r3
         wizchip_setnetinfo((wiz_NetInfo*)arg);
    3adc:	0008      	movs	r0, r1
    3ade:	4b10      	ldr	r3, [pc, #64]	; (3b20 <ctlnetwork+0x54>)
    3ae0:	4798      	blx	r3
   return 0;
    3ae2:	2000      	movs	r0, #0
}
    3ae4:	bd10      	pop	{r4, pc}
         wizchip_getnetinfo((wiz_NetInfo*)arg);
    3ae6:	0008      	movs	r0, r1
    3ae8:	4b0e      	ldr	r3, [pc, #56]	; (3b24 <ctlnetwork+0x58>)
    3aea:	4798      	blx	r3
   return 0;
    3aec:	2000      	movs	r0, #0
         break;
    3aee:	e7f9      	b.n	3ae4 <ctlnetwork+0x18>
         return wizchip_setnetmode(*(netmode_type*)arg);
    3af0:	7808      	ldrb	r0, [r1, #0]
    3af2:	4b0d      	ldr	r3, [pc, #52]	; (3b28 <ctlnetwork+0x5c>)
    3af4:	4798      	blx	r3
    3af6:	e7f5      	b.n	3ae4 <ctlnetwork+0x18>
         *(netmode_type*)arg = wizchip_getnetmode();
    3af8:	4b0c      	ldr	r3, [pc, #48]	; (3b2c <ctlnetwork+0x60>)
    3afa:	4798      	blx	r3
    3afc:	7020      	strb	r0, [r4, #0]
   return 0;
    3afe:	2000      	movs	r0, #0
         break;
    3b00:	e7f0      	b.n	3ae4 <ctlnetwork+0x18>
         wizchip_settimeout((wiz_NetTimeout*)arg);
    3b02:	0008      	movs	r0, r1
    3b04:	4b0a      	ldr	r3, [pc, #40]	; (3b30 <ctlnetwork+0x64>)
    3b06:	4798      	blx	r3
   return 0;
    3b08:	2000      	movs	r0, #0
         break;
    3b0a:	e7eb      	b.n	3ae4 <ctlnetwork+0x18>
         wizchip_gettimeout((wiz_NetTimeout*)arg);
    3b0c:	0008      	movs	r0, r1
    3b0e:	4b09      	ldr	r3, [pc, #36]	; (3b34 <ctlnetwork+0x68>)
    3b10:	4798      	blx	r3
   return 0;
    3b12:	2000      	movs	r0, #0
         break;
    3b14:	e7e6      	b.n	3ae4 <ctlnetwork+0x18>
         return -1;
    3b16:	2001      	movs	r0, #1
    3b18:	4240      	negs	r0, r0
    3b1a:	e7e3      	b.n	3ae4 <ctlnetwork+0x18>
    3b1c:	00004b98 	.word	0x00004b98
    3b20:	00003991 	.word	0x00003991
    3b24:	000039e5 	.word	0x000039e5
    3b28:	00003a39 	.word	0x00003a39
    3b2c:	00003a69 	.word	0x00003a69
    3b30:	00003a79 	.word	0x00003a79
    3b34:	00003aa1 	.word	0x00003aa1

00003b38 <main>:
uint8_t rx_tx_buff_sizes[]={2,2,2,2,2,2,2,2};
	
char http_ansver[128]="\0";	

int main(void)
{
    3b38:	b5f0      	push	{r4, r5, r6, r7, lr}
    3b3a:	46de      	mov	lr, fp
    3b3c:	4657      	mov	r7, sl
    3b3e:	464e      	mov	r6, r9
    3b40:	4645      	mov	r5, r8
    3b42:	b5e0      	push	{r5, r6, r7, lr}
    3b44:	b08b      	sub	sp, #44	; 0x2c
	/* Initializes MCU, drivers and middleware */
	//atmel_start_init();

	mcu_init();
    3b46:	4ba9      	ldr	r3, [pc, #676]	; (3dec <main+0x2b4>)
    3b48:	4798      	blx	r3
	reg_wizchip_cs_cbfunc(W5500_Select, W5500_Unselect);
    3b4a:	49a9      	ldr	r1, [pc, #676]	; (3df0 <main+0x2b8>)
    3b4c:	48a9      	ldr	r0, [pc, #676]	; (3df4 <main+0x2bc>)
    3b4e:	4baa      	ldr	r3, [pc, #680]	; (3df8 <main+0x2c0>)
    3b50:	4798      	blx	r3
	reg_wizchip_spi_cbfunc(W5500_ReadByte, W5500_Write_byte);
    3b52:	49aa      	ldr	r1, [pc, #680]	; (3dfc <main+0x2c4>)
    3b54:	48aa      	ldr	r0, [pc, #680]	; (3e00 <main+0x2c8>)
    3b56:	4bab      	ldr	r3, [pc, #684]	; (3e04 <main+0x2cc>)
    3b58:	4798      	blx	r3
	reg_wizchip_spiburst_cbfunc(W5500_ReadBuff, W5500_WriteBuff);
    3b5a:	49ab      	ldr	r1, [pc, #684]	; (3e08 <main+0x2d0>)
    3b5c:	48ab      	ldr	r0, [pc, #684]	; (3e0c <main+0x2d4>)
    3b5e:	4bac      	ldr	r3, [pc, #688]	; (3e10 <main+0x2d8>)
    3b60:	4798      	blx	r3
	wizphy_reset();
    3b62:	4bac      	ldr	r3, [pc, #688]	; (3e14 <main+0x2dc>)
    3b64:	4798      	blx	r3
	delay_ms(100);
    3b66:	2064      	movs	r0, #100	; 0x64
    3b68:	4bab      	ldr	r3, [pc, #684]	; (3e18 <main+0x2e0>)
    3b6a:	4798      	blx	r3
	wizchip_init(rx_tx_buff_sizes,rx_tx_buff_sizes);
    3b6c:	4cab      	ldr	r4, [pc, #684]	; (3e1c <main+0x2e4>)
    3b6e:	0021      	movs	r1, r4
    3b70:	0020      	movs	r0, r4
    3b72:	4bab      	ldr	r3, [pc, #684]	; (3e20 <main+0x2e8>)
    3b74:	4798      	blx	r3
	wizchip_setnetinfo(&netInfo);
    3b76:	3408      	adds	r4, #8
    3b78:	0020      	movs	r0, r4
    3b7a:	4baa      	ldr	r3, [pc, #680]	; (3e24 <main+0x2ec>)
    3b7c:	4798      	blx	r3
	ctlnetwork(CN_SET_NETINFO, (void*) &netInfo);
    3b7e:	0021      	movs	r1, r4
    3b80:	2000      	movs	r0, #0
    3b82:	4ba9      	ldr	r3, [pc, #676]	; (3e28 <main+0x2f0>)
    3b84:	4798      	blx	r3
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    3b86:	23c0      	movs	r3, #192	; 0xc0
    3b88:	05db      	lsls	r3, r3, #23
    3b8a:	2280      	movs	r2, #128	; 0x80
    3b8c:	03d2      	lsls	r2, r2, #15
    3b8e:	619a      	str	r2, [r3, #24]
    3b90:	2280      	movs	r2, #128	; 0x80
    3b92:	0052      	lsls	r2, r2, #1
    3b94:	619a      	str	r2, [r3, #24]
    3b96:	3201      	adds	r2, #1
    3b98:	32ff      	adds	r2, #255	; 0xff
    3b9a:	619a      	str	r2, [r3, #24]
	
	gpio_set_pin_level(DLDA, true);
	gpio_set_pin_level(O2, true);
	gpio_set_pin_level(O3, true);
	
	setIMR(0xff);
    3b9c:	21ff      	movs	r1, #255	; 0xff
    3b9e:	20b0      	movs	r0, #176	; 0xb0
    3ba0:	0140      	lsls	r0, r0, #5
    3ba2:	4ca2      	ldr	r4, [pc, #648]	; (3e2c <main+0x2f4>)
    3ba4:	47a0      	blx	r4
	setSIMR(0xff);
    3ba6:	21ff      	movs	r1, #255	; 0xff
    3ba8:	20c0      	movs	r0, #192	; 0xc0
    3baa:	0140      	lsls	r0, r0, #5
    3bac:	47a0      	blx	r4
	setINTLEVEL(1);
    3bae:	2100      	movs	r1, #0
    3bb0:	2098      	movs	r0, #152	; 0x98
    3bb2:	0140      	lsls	r0, r0, #5
    3bb4:	47a0      	blx	r4
    3bb6:	2101      	movs	r1, #1
    3bb8:	20a0      	movs	r0, #160	; 0xa0
    3bba:	0140      	lsls	r0, r0, #5
    3bbc:	47a0      	blx	r4
	for(uint8_t HTTP_SOCKET = 0; HTTP_SOCKET <= 7; HTTP_SOCKET++){
    3bbe:	2400      	movs	r4, #0
    3bc0:	2c07      	cmp	r4, #7
    3bc2:	d80c      	bhi.n	3bde <main+0xa6>
		//setINTLEVEL(500);
		
		//setSn_IMR(HTTP_SOCKET, 0x04);
		setSn_IMR(HTTP_SOCKET, 0x04);
    3bc4:	00a0      	lsls	r0, r4, #2
    3bc6:	3001      	adds	r0, #1
    3bc8:	00c0      	lsls	r0, r0, #3
    3bca:	23b0      	movs	r3, #176	; 0xb0
    3bcc:	019b      	lsls	r3, r3, #6
    3bce:	469c      	mov	ip, r3
    3bd0:	4460      	add	r0, ip
    3bd2:	2104      	movs	r1, #4
    3bd4:	4b95      	ldr	r3, [pc, #596]	; (3e2c <main+0x2f4>)
    3bd6:	4798      	blx	r3
	for(uint8_t HTTP_SOCKET = 0; HTTP_SOCKET <= 7; HTTP_SOCKET++){
    3bd8:	3401      	adds	r4, #1
    3bda:	b2e4      	uxtb	r4, r4
    3bdc:	e7f0      	b.n	3bc0 <main+0x88>
 */
static inline uint32_t _gpio_get_level(const enum gpio_port port)
{
	uint32_t tmp;

	CRITICAL_SECTION_ENTER();
    3bde:	a809      	add	r0, sp, #36	; 0x24
    3be0:	4b93      	ldr	r3, [pc, #588]	; (3e30 <main+0x2f8>)
    3be2:	4798      	blx	r3
	return ((Port *)hw)->Group[submodule_index].DIR.reg;
    3be4:	23c0      	movs	r3, #192	; 0xc0
    3be6:	05db      	lsls	r3, r3, #23
    3be8:	2280      	movs	r2, #128	; 0x80
    3bea:	589c      	ldr	r4, [r3, r2]
	return ((Port *)hw)->Group[submodule_index].IN.reg;
    3bec:	3220      	adds	r2, #32
    3bee:	4991      	ldr	r1, [pc, #580]	; (3e34 <main+0x2fc>)
    3bf0:	588a      	ldr	r2, [r1, r2]
	return ((Port *)hw)->Group[submodule_index].OUT.reg;
    3bf2:	2190      	movs	r1, #144	; 0x90
    3bf4:	585b      	ldr	r3, [r3, r1]

	uint32_t dir_tmp = hri_port_read_DIR_reg(PORT_IOBUS, port);

	tmp = hri_port_read_IN_reg(PORT, port) & ~dir_tmp;
	tmp |= hri_port_read_OUT_reg(PORT_IOBUS, port) & dir_tmp;
    3bf6:	4053      	eors	r3, r2
    3bf8:	401c      	ands	r4, r3
    3bfa:	4054      	eors	r4, r2

	CRITICAL_SECTION_LEAVE();
    3bfc:	a809      	add	r0, sp, #36	; 0x24
    3bfe:	4b8e      	ldr	r3, [pc, #568]	; (3e38 <main+0x300>)
    3c00:	4798      	blx	r3
	if (level) {
    3c02:	05e3      	lsls	r3, r4, #23
    3c04:	d420      	bmi.n	3c48 <main+0x110>
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    3c06:	2280      	movs	r2, #128	; 0x80
    3c08:	03d2      	lsls	r2, r2, #15
    3c0a:	23c0      	movs	r3, #192	; 0xc0
    3c0c:	05db      	lsls	r3, r3, #23
    3c0e:	619a      	str	r2, [r3, #24]
	//delay_ms(250);
	
	
	
	
	if(getSn_SR(UdpRxSockNum) == SOCK_CLOSED){
    3c10:	4b82      	ldr	r3, [pc, #520]	; (3e1c <main+0x2e4>)
    3c12:	7fd8      	ldrb	r0, [r3, #31]
    3c14:	0080      	lsls	r0, r0, #2
    3c16:	3001      	adds	r0, #1
    3c18:	00c0      	lsls	r0, r0, #3
    3c1a:	23c0      	movs	r3, #192	; 0xc0
    3c1c:	009b      	lsls	r3, r3, #2
    3c1e:	469c      	mov	ip, r3
    3c20:	4460      	add	r0, ip
    3c22:	4b86      	ldr	r3, [pc, #536]	; (3e3c <main+0x304>)
    3c24:	4798      	blx	r3
    3c26:	2800      	cmp	r0, #0
    3c28:	d014      	beq.n	3c54 <main+0x11c>
		socket(UdpRxSockNum, Sn_MR_UDP, UdpRxPort, SF_MULTI_ENABLE);
		listen(UdpRxSockNum);
	}
	
	if(getSn_IR(UdpRxSockNum)){ // & Sn_CR_RECV
    3c2a:	4b7c      	ldr	r3, [pc, #496]	; (3e1c <main+0x2e4>)
    3c2c:	7fd8      	ldrb	r0, [r3, #31]
    3c2e:	0080      	lsls	r0, r0, #2
    3c30:	3001      	adds	r0, #1
    3c32:	00c0      	lsls	r0, r0, #3
    3c34:	2380      	movs	r3, #128	; 0x80
    3c36:	009b      	lsls	r3, r3, #2
    3c38:	469c      	mov	ip, r3
    3c3a:	4460      	add	r0, ip
    3c3c:	4b7f      	ldr	r3, [pc, #508]	; (3e3c <main+0x304>)
    3c3e:	4798      	blx	r3
    3c40:	06c3      	lsls	r3, r0, #27
    3c42:	d112      	bne.n	3c6a <main+0x132>
			uint8_t rIP[4];
			getsockopt(HTTP_SOCKET, SO_DESTIP, rIP);
				
			uint16_t res_size = getSn_RX_RSR(HTTP_SOCKET);
			if (res_size > sizeof(TCP_RX_BUF)){
				res_size = sizeof(TCP_RX_BUF);
    3c44:	2703      	movs	r7, #3
    3c46:	e0aa      	b.n	3d9e <main+0x266>
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    3c48:	2280      	movs	r2, #128	; 0x80
    3c4a:	03d2      	lsls	r2, r2, #15
    3c4c:	23c0      	movs	r3, #192	; 0xc0
    3c4e:	05db      	lsls	r3, r3, #23
    3c50:	615a      	str	r2, [r3, #20]
    3c52:	e7dd      	b.n	3c10 <main+0xd8>
		socket(UdpRxSockNum, Sn_MR_UDP, UdpRxPort, SF_MULTI_ENABLE);
    3c54:	4c71      	ldr	r4, [pc, #452]	; (3e1c <main+0x2e4>)
    3c56:	8c22      	ldrh	r2, [r4, #32]
    3c58:	7fe0      	ldrb	r0, [r4, #31]
    3c5a:	2380      	movs	r3, #128	; 0x80
    3c5c:	2102      	movs	r1, #2
    3c5e:	4d78      	ldr	r5, [pc, #480]	; (3e40 <main+0x308>)
    3c60:	47a8      	blx	r5
		listen(UdpRxSockNum);
    3c62:	7fe0      	ldrb	r0, [r4, #31]
    3c64:	4b77      	ldr	r3, [pc, #476]	; (3e44 <main+0x30c>)
    3c66:	4798      	blx	r3
    3c68:	e7df      	b.n	3c2a <main+0xf2>
		uint16_t udp_size = getSn_RX_RSR(UdpRxSockNum);
    3c6a:	4b6c      	ldr	r3, [pc, #432]	; (3e1c <main+0x2e4>)
    3c6c:	7fd8      	ldrb	r0, [r3, #31]
    3c6e:	4b76      	ldr	r3, [pc, #472]	; (3e48 <main+0x310>)
    3c70:	4798      	blx	r3
    3c72:	1e04      	subs	r4, r0, #0
		if (udp_size > 0) {
    3c74:	d0e6      	beq.n	3c44 <main+0x10c>
			if (udp_size > TCP_RX_BUF) udp_size = TCP_RX_BUF;
    3c76:	4b75      	ldr	r3, [pc, #468]	; (3e4c <main+0x314>)
    3c78:	4298      	cmp	r0, r3
    3c7a:	d900      	bls.n	3c7e <main+0x146>
    3c7c:	b29c      	uxth	r4, r3
			memset(TCP_RX_BUF, 0, sizeof(TCP_RX_BUF));
    3c7e:	4e73      	ldr	r6, [pc, #460]	; (3e4c <main+0x314>)
    3c80:	2280      	movs	r2, #128	; 0x80
    3c82:	0112      	lsls	r2, r2, #4
    3c84:	2100      	movs	r1, #0
    3c86:	0030      	movs	r0, r6
    3c88:	4b71      	ldr	r3, [pc, #452]	; (3e50 <main+0x318>)
    3c8a:	4798      	blx	r3
			uint16_t ret = recvfrom(UdpRxSockNum, (uint8_t*)TCP_RX_BUF, udp_size, ip, &port);
    3c8c:	4d63      	ldr	r5, [pc, #396]	; (3e1c <main+0x2e4>)
    3c8e:	7fe8      	ldrb	r0, [r5, #31]
    3c90:	2316      	movs	r3, #22
    3c92:	aa02      	add	r2, sp, #8
    3c94:	4694      	mov	ip, r2
    3c96:	4463      	add	r3, ip
    3c98:	9300      	str	r3, [sp, #0]
    3c9a:	ab08      	add	r3, sp, #32
    3c9c:	0022      	movs	r2, r4
    3c9e:	0031      	movs	r1, r6
    3ca0:	4f6c      	ldr	r7, [pc, #432]	; (3e54 <main+0x31c>)
    3ca2:	47b8      	blx	r7
			result = socket(UdpTxSockNum, Sn_MR_UDP, UdpTxPort, SF_IO_NONBLOCK);
    3ca4:	8c6a      	ldrh	r2, [r5, #34]	; 0x22
    3ca6:	4b6c      	ldr	r3, [pc, #432]	; (3e58 <main+0x320>)
    3ca8:	4699      	mov	r9, r3
    3caa:	7818      	ldrb	r0, [r3, #0]
    3cac:	2301      	movs	r3, #1
    3cae:	2102      	movs	r1, #2
    3cb0:	4f63      	ldr	r7, [pc, #396]	; (3e40 <main+0x308>)
    3cb2:	47b8      	blx	r7
			result = sendto(UdpTxSockNum, TCP_RX_BUF, udp_size, ip, UdpTxPort);
    3cb4:	464b      	mov	r3, r9
    3cb6:	7818      	ldrb	r0, [r3, #0]
    3cb8:	8c6b      	ldrh	r3, [r5, #34]	; 0x22
    3cba:	9300      	str	r3, [sp, #0]
    3cbc:	ab08      	add	r3, sp, #32
    3cbe:	0022      	movs	r2, r4
    3cc0:	0031      	movs	r1, r6
    3cc2:	4c66      	ldr	r4, [pc, #408]	; (3e5c <main+0x324>)
    3cc4:	47a0      	blx	r4
			setSn_IR(UdpRxSockNum, 0x1F);	
    3cc6:	7fe8      	ldrb	r0, [r5, #31]
    3cc8:	0080      	lsls	r0, r0, #2
    3cca:	3001      	adds	r0, #1
    3ccc:	00c0      	lsls	r0, r0, #3
    3cce:	2380      	movs	r3, #128	; 0x80
    3cd0:	009b      	lsls	r3, r3, #2
    3cd2:	469c      	mov	ip, r3
    3cd4:	4460      	add	r0, ip
    3cd6:	211f      	movs	r1, #31
    3cd8:	4b54      	ldr	r3, [pc, #336]	; (3e2c <main+0x2f4>)
    3cda:	4798      	blx	r3
    3cdc:	e7b2      	b.n	3c44 <main+0x10c>
			getsockopt(HTTP_SOCKET, SO_DESTIP, rIP);
    3cde:	aa08      	add	r2, sp, #32
    3ce0:	2104      	movs	r1, #4
    3ce2:	0038      	movs	r0, r7
    3ce4:	4b5e      	ldr	r3, [pc, #376]	; (3e60 <main+0x328>)
    3ce6:	4798      	blx	r3
			uint16_t res_size = getSn_RX_RSR(HTTP_SOCKET);
    3ce8:	0038      	movs	r0, r7
    3cea:	4b57      	ldr	r3, [pc, #348]	; (3e48 <main+0x310>)
    3cec:	4798      	blx	r3
    3cee:	4681      	mov	r9, r0
			if (res_size > sizeof(TCP_RX_BUF)){
    3cf0:	2380      	movs	r3, #128	; 0x80
    3cf2:	011b      	lsls	r3, r3, #4
    3cf4:	4298      	cmp	r0, r3
    3cf6:	d900      	bls.n	3cfa <main+0x1c2>
				res_size = sizeof(TCP_RX_BUF);
    3cf8:	4699      	mov	r9, r3
				}
				
			memset(TCP_RX_BUF, 0, sizeof(DATA_BUFF_SIZE));
    3cfa:	2204      	movs	r2, #4
    3cfc:	2100      	movs	r1, #0
    3cfe:	4853      	ldr	r0, [pc, #332]	; (3e4c <main+0x314>)
    3d00:	4b53      	ldr	r3, [pc, #332]	; (3e50 <main+0x318>)
    3d02:	4798      	blx	r3
			sprintf(http_ansver ,"<p><span style=\"color: #00ff00;\"><strong>data</strong></span></p>\n\r");
    3d04:	4e54      	ldr	r6, [pc, #336]	; (3e58 <main+0x320>)
    3d06:	1d33      	adds	r3, r6, #4
    3d08:	001e      	movs	r6, r3
    3d0a:	2244      	movs	r2, #68	; 0x44
    3d0c:	4955      	ldr	r1, [pc, #340]	; (3e64 <main+0x32c>)
    3d0e:	0018      	movs	r0, r3
    3d10:	4b55      	ldr	r3, [pc, #340]	; (3e68 <main+0x330>)
    3d12:	4798      	blx	r3
			send(HTTP_SOCKET, (uint8_t*)http_ansver, strlen(http_ansver));    //Uncomment for TCP
    3d14:	0030      	movs	r0, r6
    3d16:	4b55      	ldr	r3, [pc, #340]	; (3e6c <main+0x334>)
    3d18:	469b      	mov	fp, r3
    3d1a:	4798      	blx	r3
    3d1c:	b282      	uxth	r2, r0
    3d1e:	0031      	movs	r1, r6
    3d20:	0038      	movs	r0, r7
    3d22:	4b53      	ldr	r3, [pc, #332]	; (3e70 <main+0x338>)
    3d24:	469a      	mov	sl, r3
    3d26:	4798      	blx	r3
			recv(HTTP_SOCKET, (uint8_t*)TCP_RX_BUF, res_size);
    3d28:	464a      	mov	r2, r9
    3d2a:	4948      	ldr	r1, [pc, #288]	; (3e4c <main+0x314>)
    3d2c:	0038      	movs	r0, r7
    3d2e:	4b51      	ldr	r3, [pc, #324]	; (3e74 <main+0x33c>)
    3d30:	4798      	blx	r3
			//}
			//uint8_t result;
			//result = socket(UdpTxSockNum, Sn_MR_UDP, UdpTxPort, SF_IO_NONBLOCK);
			//result = sendto(UdpTxSockNum, TCP_RX_BUF, res_size, UdpDestAddress, UdpTxPort);
						
			sprintf(http_ansver, "SOCKET NUM: %d;<br>RTC: %02d:%02d:%02d; \nRead bytes: %d<br>" , HTTP_SOCKET, 12, 11, 25,res_size);
    3d32:	464b      	mov	r3, r9
    3d34:	9302      	str	r3, [sp, #8]
    3d36:	2319      	movs	r3, #25
    3d38:	9301      	str	r3, [sp, #4]
    3d3a:	3b0e      	subs	r3, #14
    3d3c:	9300      	str	r3, [sp, #0]
    3d3e:	3301      	adds	r3, #1
    3d40:	002a      	movs	r2, r5
    3d42:	494d      	ldr	r1, [pc, #308]	; (3e78 <main+0x340>)
    3d44:	9605      	str	r6, [sp, #20]
    3d46:	0030      	movs	r0, r6
    3d48:	4e4c      	ldr	r6, [pc, #304]	; (3e7c <main+0x344>)
    3d4a:	46b1      	mov	r9, r6
    3d4c:	47b0      	blx	r6
			send(HTTP_SOCKET, (uint8_t*)http_ansver, strlen(http_ansver));	//Uncomment for TCP
    3d4e:	9e05      	ldr	r6, [sp, #20]
    3d50:	0030      	movs	r0, r6
    3d52:	47d8      	blx	fp
    3d54:	b282      	uxth	r2, r0
    3d56:	0031      	movs	r1, r6
    3d58:	0038      	movs	r0, r7
    3d5a:	47d0      	blx	sl
			sprintf(http_ansver ,"IP:%d.%d.%d.%d<br>", rIP[0],rIP[1],rIP[2],rIP[3]);
    3d5c:	a908      	add	r1, sp, #32
    3d5e:	780a      	ldrb	r2, [r1, #0]
    3d60:	784b      	ldrb	r3, [r1, #1]
    3d62:	7888      	ldrb	r0, [r1, #2]
    3d64:	78c9      	ldrb	r1, [r1, #3]
    3d66:	9101      	str	r1, [sp, #4]
    3d68:	9000      	str	r0, [sp, #0]
    3d6a:	4945      	ldr	r1, [pc, #276]	; (3e80 <main+0x348>)
    3d6c:	0030      	movs	r0, r6
    3d6e:	47c8      	blx	r9
			send(HTTP_SOCKET, (uint8_t*)http_ansver, strlen(http_ansver));	//Uncomment for TCP
    3d70:	0030      	movs	r0, r6
    3d72:	47d8      	blx	fp
    3d74:	b282      	uxth	r2, r0
    3d76:	0031      	movs	r1, r6
    3d78:	0038      	movs	r0, r7
    3d7a:	47d0      	blx	sl
					
			//send(HTTP_SOCKET, (uint8_t*)TCP_RX_BUF, strlen(TCP_RX_BUF));		//Uncomment for TCP
						
			char *get_request = strtok(TCP_RX_BUF, "\r");
    3d7c:	4941      	ldr	r1, [pc, #260]	; (3e84 <main+0x34c>)
    3d7e:	4833      	ldr	r0, [pc, #204]	; (3e4c <main+0x314>)
    3d80:	4b41      	ldr	r3, [pc, #260]	; (3e88 <main+0x350>)
    3d82:	4798      	blx	r3
				//}
			//sprintf(http_ansver ,"HTTP/1.0 200 OK\n\r");
			//send(HTTP_SOCKET, (uint8_t*)http_ansver, strlen(http_ansver));
			//}
				
			disconnect(HTTP_SOCKET);			//Uncomment for TCP
    3d84:	0038      	movs	r0, r7
    3d86:	4b41      	ldr	r3, [pc, #260]	; (3e8c <main+0x354>)
    3d88:	4798      	blx	r3
			close(HTTP_SOCKET);
    3d8a:	0038      	movs	r0, r7
    3d8c:	4b40      	ldr	r3, [pc, #256]	; (3e90 <main+0x358>)
    3d8e:	4798      	blx	r3
    3d90:	e015      	b.n	3dbe <main+0x286>
			}
					
			if(getSn_SR(HTTP_SOCKET) == SOCK_CLOSE_WAIT){
				disconnect(HTTP_SOCKET);
    3d92:	0038      	movs	r0, r7
    3d94:	4b3d      	ldr	r3, [pc, #244]	; (3e8c <main+0x354>)
    3d96:	4798      	blx	r3
    3d98:	e016      	b.n	3dc8 <main+0x290>
	for(uint8_t HTTP_SOCKET = 3; HTTP_SOCKET <= 7; HTTP_SOCKET++){
    3d9a:	3701      	adds	r7, #1
    3d9c:	b2ff      	uxtb	r7, r7
    3d9e:	2f07      	cmp	r7, #7
    3da0:	d900      	bls.n	3da4 <main+0x26c>
    3da2:	e71c      	b.n	3bde <main+0xa6>
		if(getSn_SR(HTTP_SOCKET) == SOCK_ESTABLISHED){
    3da4:	003d      	movs	r5, r7
    3da6:	00bc      	lsls	r4, r7, #2
    3da8:	3401      	adds	r4, #1
    3daa:	00e4      	lsls	r4, r4, #3
    3dac:	23c0      	movs	r3, #192	; 0xc0
    3dae:	009b      	lsls	r3, r3, #2
    3db0:	469c      	mov	ip, r3
    3db2:	4464      	add	r4, ip
    3db4:	0020      	movs	r0, r4
    3db6:	4b21      	ldr	r3, [pc, #132]	; (3e3c <main+0x304>)
    3db8:	4798      	blx	r3
    3dba:	2817      	cmp	r0, #23
    3dbc:	d08f      	beq.n	3cde <main+0x1a6>
			if(getSn_SR(HTTP_SOCKET) == SOCK_CLOSE_WAIT){
    3dbe:	0020      	movs	r0, r4
    3dc0:	4b1e      	ldr	r3, [pc, #120]	; (3e3c <main+0x304>)
    3dc2:	4798      	blx	r3
    3dc4:	281c      	cmp	r0, #28
    3dc6:	d0e4      	beq.n	3d92 <main+0x25a>
				//close(HTTP_SOCKET);
			}
					
			if(getSn_SR(HTTP_SOCKET) == SOCK_CLOSED){
    3dc8:	0020      	movs	r0, r4
    3dca:	4b1c      	ldr	r3, [pc, #112]	; (3e3c <main+0x304>)
    3dcc:	4798      	blx	r3
    3dce:	2800      	cmp	r0, #0
    3dd0:	d1e3      	bne.n	3d9a <main+0x262>
				socket(HTTP_SOCKET, Sn_MR_TCP, socketPort[HTTP_SOCKET], 0);
    3dd2:	006d      	lsls	r5, r5, #1
    3dd4:	4b11      	ldr	r3, [pc, #68]	; (3e1c <main+0x2e4>)
    3dd6:	195d      	adds	r5, r3, r5
    3dd8:	8caa      	ldrh	r2, [r5, #36]	; 0x24
    3dda:	2300      	movs	r3, #0
    3ddc:	2101      	movs	r1, #1
    3dde:	0038      	movs	r0, r7
    3de0:	4c17      	ldr	r4, [pc, #92]	; (3e40 <main+0x308>)
    3de2:	47a0      	blx	r4
				listen(HTTP_SOCKET);				
    3de4:	0038      	movs	r0, r7
    3de6:	4b17      	ldr	r3, [pc, #92]	; (3e44 <main+0x30c>)
    3de8:	4798      	blx	r3
    3dea:	e7d6      	b.n	3d9a <main+0x262>
    3dec:	00002271 	.word	0x00002271
    3df0:	00001ea5 	.word	0x00001ea5
    3df4:	00001e95 	.word	0x00001e95
    3df8:	00003459 	.word	0x00003459
    3dfc:	00001f15 	.word	0x00001f15
    3e00:	00001eed 	.word	0x00001eed
    3e04:	00003481 	.word	0x00003481
    3e08:	00001ed1 	.word	0x00001ed1
    3e0c:	00001eb5 	.word	0x00001eb5
    3e10:	000034b1 	.word	0x000034b1
    3e14:	000036e5 	.word	0x000036e5
    3e18:	00000199 	.word	0x00000199
    3e1c:	20000058 	.word	0x20000058
    3e20:	0000355d 	.word	0x0000355d
    3e24:	00003991 	.word	0x00003991
    3e28:	00003acd 	.word	0x00003acd
    3e2c:	000030c9 	.word	0x000030c9
    3e30:	0000017d 	.word	0x0000017d
    3e34:	41004400 	.word	0x41004400
    3e38:	0000018b 	.word	0x0000018b
    3e3c:	00003065 	.word	0x00003065
    3e40:	00002345 	.word	0x00002345
    3e44:	000024b9 	.word	0x000024b9
    3e48:	0000328d 	.word	0x0000328d
    3e4c:	20000334 	.word	0x20000334
    3e50:	0000405b 	.word	0x0000405b
    3e54:	000029a5 	.word	0x000029a5
    3e58:	2000016c 	.word	0x2000016c
    3e5c:	0000281d 	.word	0x0000281d
    3e60:	00002ed9 	.word	0x00002ed9
    3e64:	00004bb0 	.word	0x00004bb0
    3e68:	00004049 	.word	0x00004049
    3e6c:	000040b1 	.word	0x000040b1
    3e70:	000025c9 	.word	0x000025c9
    3e74:	00002711 	.word	0x00002711
    3e78:	00004bf4 	.word	0x00004bf4
    3e7c:	0000406d 	.word	0x0000406d
    3e80:	00004c30 	.word	0x00004c30
    3e84:	00004c54 	.word	0x00004c54
    3e88:	000040c1 	.word	0x000040c1
    3e8c:	00002535 	.word	0x00002535
    3e90:	000022cd 	.word	0x000022cd

00003e94 <__udivsi3>:
    3e94:	2200      	movs	r2, #0
    3e96:	0843      	lsrs	r3, r0, #1
    3e98:	428b      	cmp	r3, r1
    3e9a:	d374      	bcc.n	3f86 <__udivsi3+0xf2>
    3e9c:	0903      	lsrs	r3, r0, #4
    3e9e:	428b      	cmp	r3, r1
    3ea0:	d35f      	bcc.n	3f62 <__udivsi3+0xce>
    3ea2:	0a03      	lsrs	r3, r0, #8
    3ea4:	428b      	cmp	r3, r1
    3ea6:	d344      	bcc.n	3f32 <__udivsi3+0x9e>
    3ea8:	0b03      	lsrs	r3, r0, #12
    3eaa:	428b      	cmp	r3, r1
    3eac:	d328      	bcc.n	3f00 <__udivsi3+0x6c>
    3eae:	0c03      	lsrs	r3, r0, #16
    3eb0:	428b      	cmp	r3, r1
    3eb2:	d30d      	bcc.n	3ed0 <__udivsi3+0x3c>
    3eb4:	22ff      	movs	r2, #255	; 0xff
    3eb6:	0209      	lsls	r1, r1, #8
    3eb8:	ba12      	rev	r2, r2
    3eba:	0c03      	lsrs	r3, r0, #16
    3ebc:	428b      	cmp	r3, r1
    3ebe:	d302      	bcc.n	3ec6 <__udivsi3+0x32>
    3ec0:	1212      	asrs	r2, r2, #8
    3ec2:	0209      	lsls	r1, r1, #8
    3ec4:	d065      	beq.n	3f92 <__udivsi3+0xfe>
    3ec6:	0b03      	lsrs	r3, r0, #12
    3ec8:	428b      	cmp	r3, r1
    3eca:	d319      	bcc.n	3f00 <__udivsi3+0x6c>
    3ecc:	e000      	b.n	3ed0 <__udivsi3+0x3c>
    3ece:	0a09      	lsrs	r1, r1, #8
    3ed0:	0bc3      	lsrs	r3, r0, #15
    3ed2:	428b      	cmp	r3, r1
    3ed4:	d301      	bcc.n	3eda <__udivsi3+0x46>
    3ed6:	03cb      	lsls	r3, r1, #15
    3ed8:	1ac0      	subs	r0, r0, r3
    3eda:	4152      	adcs	r2, r2
    3edc:	0b83      	lsrs	r3, r0, #14
    3ede:	428b      	cmp	r3, r1
    3ee0:	d301      	bcc.n	3ee6 <__udivsi3+0x52>
    3ee2:	038b      	lsls	r3, r1, #14
    3ee4:	1ac0      	subs	r0, r0, r3
    3ee6:	4152      	adcs	r2, r2
    3ee8:	0b43      	lsrs	r3, r0, #13
    3eea:	428b      	cmp	r3, r1
    3eec:	d301      	bcc.n	3ef2 <__udivsi3+0x5e>
    3eee:	034b      	lsls	r3, r1, #13
    3ef0:	1ac0      	subs	r0, r0, r3
    3ef2:	4152      	adcs	r2, r2
    3ef4:	0b03      	lsrs	r3, r0, #12
    3ef6:	428b      	cmp	r3, r1
    3ef8:	d301      	bcc.n	3efe <__udivsi3+0x6a>
    3efa:	030b      	lsls	r3, r1, #12
    3efc:	1ac0      	subs	r0, r0, r3
    3efe:	4152      	adcs	r2, r2
    3f00:	0ac3      	lsrs	r3, r0, #11
    3f02:	428b      	cmp	r3, r1
    3f04:	d301      	bcc.n	3f0a <__udivsi3+0x76>
    3f06:	02cb      	lsls	r3, r1, #11
    3f08:	1ac0      	subs	r0, r0, r3
    3f0a:	4152      	adcs	r2, r2
    3f0c:	0a83      	lsrs	r3, r0, #10
    3f0e:	428b      	cmp	r3, r1
    3f10:	d301      	bcc.n	3f16 <__udivsi3+0x82>
    3f12:	028b      	lsls	r3, r1, #10
    3f14:	1ac0      	subs	r0, r0, r3
    3f16:	4152      	adcs	r2, r2
    3f18:	0a43      	lsrs	r3, r0, #9
    3f1a:	428b      	cmp	r3, r1
    3f1c:	d301      	bcc.n	3f22 <__udivsi3+0x8e>
    3f1e:	024b      	lsls	r3, r1, #9
    3f20:	1ac0      	subs	r0, r0, r3
    3f22:	4152      	adcs	r2, r2
    3f24:	0a03      	lsrs	r3, r0, #8
    3f26:	428b      	cmp	r3, r1
    3f28:	d301      	bcc.n	3f2e <__udivsi3+0x9a>
    3f2a:	020b      	lsls	r3, r1, #8
    3f2c:	1ac0      	subs	r0, r0, r3
    3f2e:	4152      	adcs	r2, r2
    3f30:	d2cd      	bcs.n	3ece <__udivsi3+0x3a>
    3f32:	09c3      	lsrs	r3, r0, #7
    3f34:	428b      	cmp	r3, r1
    3f36:	d301      	bcc.n	3f3c <__udivsi3+0xa8>
    3f38:	01cb      	lsls	r3, r1, #7
    3f3a:	1ac0      	subs	r0, r0, r3
    3f3c:	4152      	adcs	r2, r2
    3f3e:	0983      	lsrs	r3, r0, #6
    3f40:	428b      	cmp	r3, r1
    3f42:	d301      	bcc.n	3f48 <__udivsi3+0xb4>
    3f44:	018b      	lsls	r3, r1, #6
    3f46:	1ac0      	subs	r0, r0, r3
    3f48:	4152      	adcs	r2, r2
    3f4a:	0943      	lsrs	r3, r0, #5
    3f4c:	428b      	cmp	r3, r1
    3f4e:	d301      	bcc.n	3f54 <__udivsi3+0xc0>
    3f50:	014b      	lsls	r3, r1, #5
    3f52:	1ac0      	subs	r0, r0, r3
    3f54:	4152      	adcs	r2, r2
    3f56:	0903      	lsrs	r3, r0, #4
    3f58:	428b      	cmp	r3, r1
    3f5a:	d301      	bcc.n	3f60 <__udivsi3+0xcc>
    3f5c:	010b      	lsls	r3, r1, #4
    3f5e:	1ac0      	subs	r0, r0, r3
    3f60:	4152      	adcs	r2, r2
    3f62:	08c3      	lsrs	r3, r0, #3
    3f64:	428b      	cmp	r3, r1
    3f66:	d301      	bcc.n	3f6c <__udivsi3+0xd8>
    3f68:	00cb      	lsls	r3, r1, #3
    3f6a:	1ac0      	subs	r0, r0, r3
    3f6c:	4152      	adcs	r2, r2
    3f6e:	0883      	lsrs	r3, r0, #2
    3f70:	428b      	cmp	r3, r1
    3f72:	d301      	bcc.n	3f78 <__udivsi3+0xe4>
    3f74:	008b      	lsls	r3, r1, #2
    3f76:	1ac0      	subs	r0, r0, r3
    3f78:	4152      	adcs	r2, r2
    3f7a:	0843      	lsrs	r3, r0, #1
    3f7c:	428b      	cmp	r3, r1
    3f7e:	d301      	bcc.n	3f84 <__udivsi3+0xf0>
    3f80:	004b      	lsls	r3, r1, #1
    3f82:	1ac0      	subs	r0, r0, r3
    3f84:	4152      	adcs	r2, r2
    3f86:	1a41      	subs	r1, r0, r1
    3f88:	d200      	bcs.n	3f8c <__udivsi3+0xf8>
    3f8a:	4601      	mov	r1, r0
    3f8c:	4152      	adcs	r2, r2
    3f8e:	4610      	mov	r0, r2
    3f90:	4770      	bx	lr
    3f92:	e7ff      	b.n	3f94 <__udivsi3+0x100>
    3f94:	b501      	push	{r0, lr}
    3f96:	2000      	movs	r0, #0
    3f98:	f000 f806 	bl	3fa8 <__aeabi_idiv0>
    3f9c:	bd02      	pop	{r1, pc}
    3f9e:	46c0      	nop			; (mov r8, r8)

00003fa0 <__aeabi_uidivmod>:
    3fa0:	2900      	cmp	r1, #0
    3fa2:	d0f7      	beq.n	3f94 <__udivsi3+0x100>
    3fa4:	e776      	b.n	3e94 <__udivsi3>
    3fa6:	4770      	bx	lr

00003fa8 <__aeabi_idiv0>:
    3fa8:	4770      	bx	lr
    3faa:	46c0      	nop			; (mov r8, r8)

00003fac <__ffssi2>:
    3fac:	b510      	push	{r4, lr}
    3fae:	2300      	movs	r3, #0
    3fb0:	2800      	cmp	r0, #0
    3fb2:	d002      	beq.n	3fba <__ffssi2+0xe>
    3fb4:	f000 f804 	bl	3fc0 <__ctzsi2>
    3fb8:	1c43      	adds	r3, r0, #1
    3fba:	0018      	movs	r0, r3
    3fbc:	bd10      	pop	{r4, pc}
    3fbe:	46c0      	nop			; (mov r8, r8)

00003fc0 <__ctzsi2>:
    3fc0:	4241      	negs	r1, r0
    3fc2:	4008      	ands	r0, r1
    3fc4:	211c      	movs	r1, #28
    3fc6:	2301      	movs	r3, #1
    3fc8:	041b      	lsls	r3, r3, #16
    3fca:	4298      	cmp	r0, r3
    3fcc:	d301      	bcc.n	3fd2 <__ctzsi2+0x12>
    3fce:	0c00      	lsrs	r0, r0, #16
    3fd0:	3910      	subs	r1, #16
    3fd2:	0a1b      	lsrs	r3, r3, #8
    3fd4:	4298      	cmp	r0, r3
    3fd6:	d301      	bcc.n	3fdc <__ctzsi2+0x1c>
    3fd8:	0a00      	lsrs	r0, r0, #8
    3fda:	3908      	subs	r1, #8
    3fdc:	091b      	lsrs	r3, r3, #4
    3fde:	4298      	cmp	r0, r3
    3fe0:	d301      	bcc.n	3fe6 <__ctzsi2+0x26>
    3fe2:	0900      	lsrs	r0, r0, #4
    3fe4:	3904      	subs	r1, #4
    3fe6:	a202      	add	r2, pc, #8	; (adr r2, 3ff0 <__ctzsi2+0x30>)
    3fe8:	5c10      	ldrb	r0, [r2, r0]
    3fea:	1a40      	subs	r0, r0, r1
    3fec:	4770      	bx	lr
    3fee:	46c0      	nop			; (mov r8, r8)
    3ff0:	1d1d1c1b 	.word	0x1d1d1c1b
    3ff4:	1e1e1e1e 	.word	0x1e1e1e1e
    3ff8:	1f1f1f1f 	.word	0x1f1f1f1f
    3ffc:	1f1f1f1f 	.word	0x1f1f1f1f

00004000 <__libc_init_array>:
    4000:	b570      	push	{r4, r5, r6, lr}
    4002:	2600      	movs	r6, #0
    4004:	4d0c      	ldr	r5, [pc, #48]	; (4038 <__libc_init_array+0x38>)
    4006:	4c0d      	ldr	r4, [pc, #52]	; (403c <__libc_init_array+0x3c>)
    4008:	1b64      	subs	r4, r4, r5
    400a:	10a4      	asrs	r4, r4, #2
    400c:	42a6      	cmp	r6, r4
    400e:	d109      	bne.n	4024 <__libc_init_array+0x24>
    4010:	2600      	movs	r6, #0
    4012:	f000 fe6b 	bl	4cec <_init>
    4016:	4d0a      	ldr	r5, [pc, #40]	; (4040 <__libc_init_array+0x40>)
    4018:	4c0a      	ldr	r4, [pc, #40]	; (4044 <__libc_init_array+0x44>)
    401a:	1b64      	subs	r4, r4, r5
    401c:	10a4      	asrs	r4, r4, #2
    401e:	42a6      	cmp	r6, r4
    4020:	d105      	bne.n	402e <__libc_init_array+0x2e>
    4022:	bd70      	pop	{r4, r5, r6, pc}
    4024:	00b3      	lsls	r3, r6, #2
    4026:	58eb      	ldr	r3, [r5, r3]
    4028:	4798      	blx	r3
    402a:	3601      	adds	r6, #1
    402c:	e7ee      	b.n	400c <__libc_init_array+0xc>
    402e:	00b3      	lsls	r3, r6, #2
    4030:	58eb      	ldr	r3, [r5, r3]
    4032:	4798      	blx	r3
    4034:	3601      	adds	r6, #1
    4036:	e7f2      	b.n	401e <__libc_init_array+0x1e>
    4038:	00004cf8 	.word	0x00004cf8
    403c:	00004cf8 	.word	0x00004cf8
    4040:	00004cf8 	.word	0x00004cf8
    4044:	00004cfc 	.word	0x00004cfc

00004048 <memcpy>:
    4048:	2300      	movs	r3, #0
    404a:	b510      	push	{r4, lr}
    404c:	429a      	cmp	r2, r3
    404e:	d100      	bne.n	4052 <memcpy+0xa>
    4050:	bd10      	pop	{r4, pc}
    4052:	5ccc      	ldrb	r4, [r1, r3]
    4054:	54c4      	strb	r4, [r0, r3]
    4056:	3301      	adds	r3, #1
    4058:	e7f8      	b.n	404c <memcpy+0x4>

0000405a <memset>:
    405a:	0003      	movs	r3, r0
    405c:	1882      	adds	r2, r0, r2
    405e:	4293      	cmp	r3, r2
    4060:	d100      	bne.n	4064 <memset+0xa>
    4062:	4770      	bx	lr
    4064:	7019      	strb	r1, [r3, #0]
    4066:	3301      	adds	r3, #1
    4068:	e7f9      	b.n	405e <memset+0x4>
	...

0000406c <siprintf>:
    406c:	b40e      	push	{r1, r2, r3}
    406e:	b510      	push	{r4, lr}
    4070:	b09d      	sub	sp, #116	; 0x74
    4072:	a902      	add	r1, sp, #8
    4074:	9002      	str	r0, [sp, #8]
    4076:	6108      	str	r0, [r1, #16]
    4078:	480b      	ldr	r0, [pc, #44]	; (40a8 <siprintf+0x3c>)
    407a:	2482      	movs	r4, #130	; 0x82
    407c:	6088      	str	r0, [r1, #8]
    407e:	6148      	str	r0, [r1, #20]
    4080:	2001      	movs	r0, #1
    4082:	4240      	negs	r0, r0
    4084:	ab1f      	add	r3, sp, #124	; 0x7c
    4086:	81c8      	strh	r0, [r1, #14]
    4088:	4808      	ldr	r0, [pc, #32]	; (40ac <siprintf+0x40>)
    408a:	cb04      	ldmia	r3!, {r2}
    408c:	00a4      	lsls	r4, r4, #2
    408e:	6800      	ldr	r0, [r0, #0]
    4090:	9301      	str	r3, [sp, #4]
    4092:	818c      	strh	r4, [r1, #12]
    4094:	f000 f97e 	bl	4394 <_svfiprintf_r>
    4098:	2300      	movs	r3, #0
    409a:	9a02      	ldr	r2, [sp, #8]
    409c:	7013      	strb	r3, [r2, #0]
    409e:	b01d      	add	sp, #116	; 0x74
    40a0:	bc10      	pop	{r4}
    40a2:	bc08      	pop	{r3}
    40a4:	b003      	add	sp, #12
    40a6:	4718      	bx	r3
    40a8:	7fffffff 	.word	0x7fffffff
    40ac:	20000094 	.word	0x20000094

000040b0 <strlen>:
    40b0:	2300      	movs	r3, #0
    40b2:	5cc2      	ldrb	r2, [r0, r3]
    40b4:	3301      	adds	r3, #1
    40b6:	2a00      	cmp	r2, #0
    40b8:	d1fb      	bne.n	40b2 <strlen+0x2>
    40ba:	1e58      	subs	r0, r3, #1
    40bc:	4770      	bx	lr
	...

000040c0 <strtok>:
    40c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    40c2:	4b12      	ldr	r3, [pc, #72]	; (410c <strtok+0x4c>)
    40c4:	0006      	movs	r6, r0
    40c6:	681d      	ldr	r5, [r3, #0]
    40c8:	000f      	movs	r7, r1
    40ca:	6dac      	ldr	r4, [r5, #88]	; 0x58
    40cc:	2c00      	cmp	r4, #0
    40ce:	d116      	bne.n	40fe <strtok+0x3e>
    40d0:	2050      	movs	r0, #80	; 0x50
    40d2:	f000 f84b 	bl	416c <malloc>
    40d6:	65a8      	str	r0, [r5, #88]	; 0x58
    40d8:	6004      	str	r4, [r0, #0]
    40da:	6044      	str	r4, [r0, #4]
    40dc:	6084      	str	r4, [r0, #8]
    40de:	60c4      	str	r4, [r0, #12]
    40e0:	6104      	str	r4, [r0, #16]
    40e2:	6144      	str	r4, [r0, #20]
    40e4:	6184      	str	r4, [r0, #24]
    40e6:	6284      	str	r4, [r0, #40]	; 0x28
    40e8:	62c4      	str	r4, [r0, #44]	; 0x2c
    40ea:	6304      	str	r4, [r0, #48]	; 0x30
    40ec:	6344      	str	r4, [r0, #52]	; 0x34
    40ee:	6384      	str	r4, [r0, #56]	; 0x38
    40f0:	63c4      	str	r4, [r0, #60]	; 0x3c
    40f2:	6404      	str	r4, [r0, #64]	; 0x40
    40f4:	6444      	str	r4, [r0, #68]	; 0x44
    40f6:	6484      	str	r4, [r0, #72]	; 0x48
    40f8:	64c4      	str	r4, [r0, #76]	; 0x4c
    40fa:	7704      	strb	r4, [r0, #28]
    40fc:	6244      	str	r4, [r0, #36]	; 0x24
    40fe:	6daa      	ldr	r2, [r5, #88]	; 0x58
    4100:	0039      	movs	r1, r7
    4102:	0030      	movs	r0, r6
    4104:	2301      	movs	r3, #1
    4106:	f000 f803 	bl	4110 <__strtok_r>
    410a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    410c:	20000094 	.word	0x20000094

00004110 <__strtok_r>:
    4110:	b5f0      	push	{r4, r5, r6, r7, lr}
    4112:	2800      	cmp	r0, #0
    4114:	d104      	bne.n	4120 <__strtok_r+0x10>
    4116:	6810      	ldr	r0, [r2, #0]
    4118:	2800      	cmp	r0, #0
    411a:	d101      	bne.n	4120 <__strtok_r+0x10>
    411c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    411e:	0020      	movs	r0, r4
    4120:	000e      	movs	r6, r1
    4122:	7805      	ldrb	r5, [r0, #0]
    4124:	1c44      	adds	r4, r0, #1
    4126:	7837      	ldrb	r7, [r6, #0]
    4128:	2f00      	cmp	r7, #0
    412a:	d104      	bne.n	4136 <__strtok_r+0x26>
    412c:	2d00      	cmp	r5, #0
    412e:	d110      	bne.n	4152 <__strtok_r+0x42>
    4130:	6015      	str	r5, [r2, #0]
    4132:	0028      	movs	r0, r5
    4134:	e7f2      	b.n	411c <__strtok_r+0xc>
    4136:	3601      	adds	r6, #1
    4138:	42bd      	cmp	r5, r7
    413a:	d1f4      	bne.n	4126 <__strtok_r+0x16>
    413c:	2b00      	cmp	r3, #0
    413e:	d1ee      	bne.n	411e <__strtok_r+0xe>
    4140:	6014      	str	r4, [r2, #0]
    4142:	7003      	strb	r3, [r0, #0]
    4144:	e7ea      	b.n	411c <__strtok_r+0xc>
    4146:	0033      	movs	r3, r6
    4148:	e00e      	b.n	4168 <__strtok_r+0x58>
    414a:	3501      	adds	r5, #1
    414c:	001c      	movs	r4, r3
    414e:	2f00      	cmp	r7, #0
    4150:	d102      	bne.n	4158 <__strtok_r+0x48>
    4152:	000d      	movs	r5, r1
    4154:	7826      	ldrb	r6, [r4, #0]
    4156:	1c63      	adds	r3, r4, #1
    4158:	782f      	ldrb	r7, [r5, #0]
    415a:	42be      	cmp	r6, r7
    415c:	d1f5      	bne.n	414a <__strtok_r+0x3a>
    415e:	2e00      	cmp	r6, #0
    4160:	d0f1      	beq.n	4146 <__strtok_r+0x36>
    4162:	2400      	movs	r4, #0
    4164:	1e59      	subs	r1, r3, #1
    4166:	700c      	strb	r4, [r1, #0]
    4168:	6013      	str	r3, [r2, #0]
    416a:	e7d7      	b.n	411c <__strtok_r+0xc>

0000416c <malloc>:
    416c:	b510      	push	{r4, lr}
    416e:	4b03      	ldr	r3, [pc, #12]	; (417c <malloc+0x10>)
    4170:	0001      	movs	r1, r0
    4172:	6818      	ldr	r0, [r3, #0]
    4174:	f000 f84e 	bl	4214 <_malloc_r>
    4178:	bd10      	pop	{r4, pc}
    417a:	46c0      	nop			; (mov r8, r8)
    417c:	20000094 	.word	0x20000094

00004180 <_free_r>:
    4180:	b570      	push	{r4, r5, r6, lr}
    4182:	0005      	movs	r5, r0
    4184:	2900      	cmp	r1, #0
    4186:	d010      	beq.n	41aa <_free_r+0x2a>
    4188:	1f0c      	subs	r4, r1, #4
    418a:	6823      	ldr	r3, [r4, #0]
    418c:	2b00      	cmp	r3, #0
    418e:	da00      	bge.n	4192 <_free_r+0x12>
    4190:	18e4      	adds	r4, r4, r3
    4192:	0028      	movs	r0, r5
    4194:	f000 fbb9 	bl	490a <__malloc_lock>
    4198:	4a1d      	ldr	r2, [pc, #116]	; (4210 <_free_r+0x90>)
    419a:	6813      	ldr	r3, [r2, #0]
    419c:	2b00      	cmp	r3, #0
    419e:	d105      	bne.n	41ac <_free_r+0x2c>
    41a0:	6063      	str	r3, [r4, #4]
    41a2:	6014      	str	r4, [r2, #0]
    41a4:	0028      	movs	r0, r5
    41a6:	f000 fbb1 	bl	490c <__malloc_unlock>
    41aa:	bd70      	pop	{r4, r5, r6, pc}
    41ac:	42a3      	cmp	r3, r4
    41ae:	d909      	bls.n	41c4 <_free_r+0x44>
    41b0:	6821      	ldr	r1, [r4, #0]
    41b2:	1860      	adds	r0, r4, r1
    41b4:	4283      	cmp	r3, r0
    41b6:	d1f3      	bne.n	41a0 <_free_r+0x20>
    41b8:	6818      	ldr	r0, [r3, #0]
    41ba:	685b      	ldr	r3, [r3, #4]
    41bc:	1841      	adds	r1, r0, r1
    41be:	6021      	str	r1, [r4, #0]
    41c0:	e7ee      	b.n	41a0 <_free_r+0x20>
    41c2:	0013      	movs	r3, r2
    41c4:	685a      	ldr	r2, [r3, #4]
    41c6:	2a00      	cmp	r2, #0
    41c8:	d001      	beq.n	41ce <_free_r+0x4e>
    41ca:	42a2      	cmp	r2, r4
    41cc:	d9f9      	bls.n	41c2 <_free_r+0x42>
    41ce:	6819      	ldr	r1, [r3, #0]
    41d0:	1858      	adds	r0, r3, r1
    41d2:	42a0      	cmp	r0, r4
    41d4:	d10b      	bne.n	41ee <_free_r+0x6e>
    41d6:	6820      	ldr	r0, [r4, #0]
    41d8:	1809      	adds	r1, r1, r0
    41da:	1858      	adds	r0, r3, r1
    41dc:	6019      	str	r1, [r3, #0]
    41de:	4282      	cmp	r2, r0
    41e0:	d1e0      	bne.n	41a4 <_free_r+0x24>
    41e2:	6810      	ldr	r0, [r2, #0]
    41e4:	6852      	ldr	r2, [r2, #4]
    41e6:	1841      	adds	r1, r0, r1
    41e8:	6019      	str	r1, [r3, #0]
    41ea:	605a      	str	r2, [r3, #4]
    41ec:	e7da      	b.n	41a4 <_free_r+0x24>
    41ee:	42a0      	cmp	r0, r4
    41f0:	d902      	bls.n	41f8 <_free_r+0x78>
    41f2:	230c      	movs	r3, #12
    41f4:	602b      	str	r3, [r5, #0]
    41f6:	e7d5      	b.n	41a4 <_free_r+0x24>
    41f8:	6821      	ldr	r1, [r4, #0]
    41fa:	1860      	adds	r0, r4, r1
    41fc:	4282      	cmp	r2, r0
    41fe:	d103      	bne.n	4208 <_free_r+0x88>
    4200:	6810      	ldr	r0, [r2, #0]
    4202:	6852      	ldr	r2, [r2, #4]
    4204:	1841      	adds	r1, r0, r1
    4206:	6021      	str	r1, [r4, #0]
    4208:	6062      	str	r2, [r4, #4]
    420a:	605c      	str	r4, [r3, #4]
    420c:	e7ca      	b.n	41a4 <_free_r+0x24>
    420e:	46c0      	nop			; (mov r8, r8)
    4210:	200001f0 	.word	0x200001f0

00004214 <_malloc_r>:
    4214:	2303      	movs	r3, #3
    4216:	b570      	push	{r4, r5, r6, lr}
    4218:	1ccd      	adds	r5, r1, #3
    421a:	439d      	bics	r5, r3
    421c:	3508      	adds	r5, #8
    421e:	0006      	movs	r6, r0
    4220:	2d0c      	cmp	r5, #12
    4222:	d21e      	bcs.n	4262 <_malloc_r+0x4e>
    4224:	250c      	movs	r5, #12
    4226:	42a9      	cmp	r1, r5
    4228:	d81d      	bhi.n	4266 <_malloc_r+0x52>
    422a:	0030      	movs	r0, r6
    422c:	f000 fb6d 	bl	490a <__malloc_lock>
    4230:	4a25      	ldr	r2, [pc, #148]	; (42c8 <_malloc_r+0xb4>)
    4232:	6814      	ldr	r4, [r2, #0]
    4234:	0021      	movs	r1, r4
    4236:	2900      	cmp	r1, #0
    4238:	d119      	bne.n	426e <_malloc_r+0x5a>
    423a:	4c24      	ldr	r4, [pc, #144]	; (42cc <_malloc_r+0xb8>)
    423c:	6823      	ldr	r3, [r4, #0]
    423e:	2b00      	cmp	r3, #0
    4240:	d103      	bne.n	424a <_malloc_r+0x36>
    4242:	0030      	movs	r0, r6
    4244:	f000 fb32 	bl	48ac <_sbrk_r>
    4248:	6020      	str	r0, [r4, #0]
    424a:	0029      	movs	r1, r5
    424c:	0030      	movs	r0, r6
    424e:	f000 fb2d 	bl	48ac <_sbrk_r>
    4252:	1c43      	adds	r3, r0, #1
    4254:	d12c      	bne.n	42b0 <_malloc_r+0x9c>
    4256:	230c      	movs	r3, #12
    4258:	0030      	movs	r0, r6
    425a:	6033      	str	r3, [r6, #0]
    425c:	f000 fb56 	bl	490c <__malloc_unlock>
    4260:	e003      	b.n	426a <_malloc_r+0x56>
    4262:	2d00      	cmp	r5, #0
    4264:	dadf      	bge.n	4226 <_malloc_r+0x12>
    4266:	230c      	movs	r3, #12
    4268:	6033      	str	r3, [r6, #0]
    426a:	2000      	movs	r0, #0
    426c:	bd70      	pop	{r4, r5, r6, pc}
    426e:	680b      	ldr	r3, [r1, #0]
    4270:	1b5b      	subs	r3, r3, r5
    4272:	d41a      	bmi.n	42aa <_malloc_r+0x96>
    4274:	2b0b      	cmp	r3, #11
    4276:	d903      	bls.n	4280 <_malloc_r+0x6c>
    4278:	600b      	str	r3, [r1, #0]
    427a:	18cc      	adds	r4, r1, r3
    427c:	6025      	str	r5, [r4, #0]
    427e:	e003      	b.n	4288 <_malloc_r+0x74>
    4280:	428c      	cmp	r4, r1
    4282:	d10e      	bne.n	42a2 <_malloc_r+0x8e>
    4284:	6863      	ldr	r3, [r4, #4]
    4286:	6013      	str	r3, [r2, #0]
    4288:	0030      	movs	r0, r6
    428a:	f000 fb3f 	bl	490c <__malloc_unlock>
    428e:	0020      	movs	r0, r4
    4290:	2207      	movs	r2, #7
    4292:	300b      	adds	r0, #11
    4294:	1d23      	adds	r3, r4, #4
    4296:	4390      	bics	r0, r2
    4298:	1ac3      	subs	r3, r0, r3
    429a:	d0e7      	beq.n	426c <_malloc_r+0x58>
    429c:	425a      	negs	r2, r3
    429e:	50e2      	str	r2, [r4, r3]
    42a0:	e7e4      	b.n	426c <_malloc_r+0x58>
    42a2:	684b      	ldr	r3, [r1, #4]
    42a4:	6063      	str	r3, [r4, #4]
    42a6:	000c      	movs	r4, r1
    42a8:	e7ee      	b.n	4288 <_malloc_r+0x74>
    42aa:	000c      	movs	r4, r1
    42ac:	6849      	ldr	r1, [r1, #4]
    42ae:	e7c2      	b.n	4236 <_malloc_r+0x22>
    42b0:	2303      	movs	r3, #3
    42b2:	1cc4      	adds	r4, r0, #3
    42b4:	439c      	bics	r4, r3
    42b6:	42a0      	cmp	r0, r4
    42b8:	d0e0      	beq.n	427c <_malloc_r+0x68>
    42ba:	1a21      	subs	r1, r4, r0
    42bc:	0030      	movs	r0, r6
    42be:	f000 faf5 	bl	48ac <_sbrk_r>
    42c2:	1c43      	adds	r3, r0, #1
    42c4:	d1da      	bne.n	427c <_malloc_r+0x68>
    42c6:	e7c6      	b.n	4256 <_malloc_r+0x42>
    42c8:	200001f0 	.word	0x200001f0
    42cc:	200001f4 	.word	0x200001f4

000042d0 <__ssputs_r>:
    42d0:	b5f0      	push	{r4, r5, r6, r7, lr}
    42d2:	688e      	ldr	r6, [r1, #8]
    42d4:	b085      	sub	sp, #20
    42d6:	0007      	movs	r7, r0
    42d8:	000c      	movs	r4, r1
    42da:	9203      	str	r2, [sp, #12]
    42dc:	9301      	str	r3, [sp, #4]
    42de:	429e      	cmp	r6, r3
    42e0:	d839      	bhi.n	4356 <__ssputs_r+0x86>
    42e2:	2390      	movs	r3, #144	; 0x90
    42e4:	898a      	ldrh	r2, [r1, #12]
    42e6:	00db      	lsls	r3, r3, #3
    42e8:	421a      	tst	r2, r3
    42ea:	d034      	beq.n	4356 <__ssputs_r+0x86>
    42ec:	2503      	movs	r5, #3
    42ee:	6909      	ldr	r1, [r1, #16]
    42f0:	6823      	ldr	r3, [r4, #0]
    42f2:	1a5b      	subs	r3, r3, r1
    42f4:	9302      	str	r3, [sp, #8]
    42f6:	6963      	ldr	r3, [r4, #20]
    42f8:	9802      	ldr	r0, [sp, #8]
    42fa:	435d      	muls	r5, r3
    42fc:	0feb      	lsrs	r3, r5, #31
    42fe:	195d      	adds	r5, r3, r5
    4300:	9b01      	ldr	r3, [sp, #4]
    4302:	106d      	asrs	r5, r5, #1
    4304:	3301      	adds	r3, #1
    4306:	181b      	adds	r3, r3, r0
    4308:	42ab      	cmp	r3, r5
    430a:	d900      	bls.n	430e <__ssputs_r+0x3e>
    430c:	001d      	movs	r5, r3
    430e:	0553      	lsls	r3, r2, #21
    4310:	d532      	bpl.n	4378 <__ssputs_r+0xa8>
    4312:	0029      	movs	r1, r5
    4314:	0038      	movs	r0, r7
    4316:	f7ff ff7d 	bl	4214 <_malloc_r>
    431a:	1e06      	subs	r6, r0, #0
    431c:	d109      	bne.n	4332 <__ssputs_r+0x62>
    431e:	230c      	movs	r3, #12
    4320:	603b      	str	r3, [r7, #0]
    4322:	2340      	movs	r3, #64	; 0x40
    4324:	2001      	movs	r0, #1
    4326:	89a2      	ldrh	r2, [r4, #12]
    4328:	4240      	negs	r0, r0
    432a:	4313      	orrs	r3, r2
    432c:	81a3      	strh	r3, [r4, #12]
    432e:	b005      	add	sp, #20
    4330:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4332:	9a02      	ldr	r2, [sp, #8]
    4334:	6921      	ldr	r1, [r4, #16]
    4336:	f7ff fe87 	bl	4048 <memcpy>
    433a:	89a3      	ldrh	r3, [r4, #12]
    433c:	4a14      	ldr	r2, [pc, #80]	; (4390 <__ssputs_r+0xc0>)
    433e:	401a      	ands	r2, r3
    4340:	2380      	movs	r3, #128	; 0x80
    4342:	4313      	orrs	r3, r2
    4344:	81a3      	strh	r3, [r4, #12]
    4346:	9b02      	ldr	r3, [sp, #8]
    4348:	6126      	str	r6, [r4, #16]
    434a:	18f6      	adds	r6, r6, r3
    434c:	6026      	str	r6, [r4, #0]
    434e:	6165      	str	r5, [r4, #20]
    4350:	9e01      	ldr	r6, [sp, #4]
    4352:	1aed      	subs	r5, r5, r3
    4354:	60a5      	str	r5, [r4, #8]
    4356:	9b01      	ldr	r3, [sp, #4]
    4358:	42b3      	cmp	r3, r6
    435a:	d200      	bcs.n	435e <__ssputs_r+0x8e>
    435c:	001e      	movs	r6, r3
    435e:	0032      	movs	r2, r6
    4360:	9903      	ldr	r1, [sp, #12]
    4362:	6820      	ldr	r0, [r4, #0]
    4364:	f000 fabf 	bl	48e6 <memmove>
    4368:	68a3      	ldr	r3, [r4, #8]
    436a:	2000      	movs	r0, #0
    436c:	1b9b      	subs	r3, r3, r6
    436e:	60a3      	str	r3, [r4, #8]
    4370:	6823      	ldr	r3, [r4, #0]
    4372:	199e      	adds	r6, r3, r6
    4374:	6026      	str	r6, [r4, #0]
    4376:	e7da      	b.n	432e <__ssputs_r+0x5e>
    4378:	002a      	movs	r2, r5
    437a:	0038      	movs	r0, r7
    437c:	f000 fac7 	bl	490e <_realloc_r>
    4380:	1e06      	subs	r6, r0, #0
    4382:	d1e0      	bne.n	4346 <__ssputs_r+0x76>
    4384:	6921      	ldr	r1, [r4, #16]
    4386:	0038      	movs	r0, r7
    4388:	f7ff fefa 	bl	4180 <_free_r>
    438c:	e7c7      	b.n	431e <__ssputs_r+0x4e>
    438e:	46c0      	nop			; (mov r8, r8)
    4390:	fffffb7f 	.word	0xfffffb7f

00004394 <_svfiprintf_r>:
    4394:	b5f0      	push	{r4, r5, r6, r7, lr}
    4396:	b09f      	sub	sp, #124	; 0x7c
    4398:	9002      	str	r0, [sp, #8]
    439a:	9305      	str	r3, [sp, #20]
    439c:	898b      	ldrh	r3, [r1, #12]
    439e:	000f      	movs	r7, r1
    43a0:	0016      	movs	r6, r2
    43a2:	061b      	lsls	r3, r3, #24
    43a4:	d511      	bpl.n	43ca <_svfiprintf_r+0x36>
    43a6:	690b      	ldr	r3, [r1, #16]
    43a8:	2b00      	cmp	r3, #0
    43aa:	d10e      	bne.n	43ca <_svfiprintf_r+0x36>
    43ac:	2140      	movs	r1, #64	; 0x40
    43ae:	f7ff ff31 	bl	4214 <_malloc_r>
    43b2:	6038      	str	r0, [r7, #0]
    43b4:	6138      	str	r0, [r7, #16]
    43b6:	2800      	cmp	r0, #0
    43b8:	d105      	bne.n	43c6 <_svfiprintf_r+0x32>
    43ba:	230c      	movs	r3, #12
    43bc:	9a02      	ldr	r2, [sp, #8]
    43be:	3801      	subs	r0, #1
    43c0:	6013      	str	r3, [r2, #0]
    43c2:	b01f      	add	sp, #124	; 0x7c
    43c4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    43c6:	2340      	movs	r3, #64	; 0x40
    43c8:	617b      	str	r3, [r7, #20]
    43ca:	2300      	movs	r3, #0
    43cc:	ad06      	add	r5, sp, #24
    43ce:	616b      	str	r3, [r5, #20]
    43d0:	3320      	adds	r3, #32
    43d2:	766b      	strb	r3, [r5, #25]
    43d4:	3310      	adds	r3, #16
    43d6:	76ab      	strb	r3, [r5, #26]
    43d8:	0034      	movs	r4, r6
    43da:	7823      	ldrb	r3, [r4, #0]
    43dc:	2b00      	cmp	r3, #0
    43de:	d147      	bne.n	4470 <_svfiprintf_r+0xdc>
    43e0:	1ba3      	subs	r3, r4, r6
    43e2:	9304      	str	r3, [sp, #16]
    43e4:	d00d      	beq.n	4402 <_svfiprintf_r+0x6e>
    43e6:	1ba3      	subs	r3, r4, r6
    43e8:	0032      	movs	r2, r6
    43ea:	0039      	movs	r1, r7
    43ec:	9802      	ldr	r0, [sp, #8]
    43ee:	f7ff ff6f 	bl	42d0 <__ssputs_r>
    43f2:	1c43      	adds	r3, r0, #1
    43f4:	d100      	bne.n	43f8 <_svfiprintf_r+0x64>
    43f6:	e0b5      	b.n	4564 <_svfiprintf_r+0x1d0>
    43f8:	696a      	ldr	r2, [r5, #20]
    43fa:	9b04      	ldr	r3, [sp, #16]
    43fc:	4694      	mov	ip, r2
    43fe:	4463      	add	r3, ip
    4400:	616b      	str	r3, [r5, #20]
    4402:	7823      	ldrb	r3, [r4, #0]
    4404:	2b00      	cmp	r3, #0
    4406:	d100      	bne.n	440a <_svfiprintf_r+0x76>
    4408:	e0ac      	b.n	4564 <_svfiprintf_r+0x1d0>
    440a:	2201      	movs	r2, #1
    440c:	2300      	movs	r3, #0
    440e:	4252      	negs	r2, r2
    4410:	606a      	str	r2, [r5, #4]
    4412:	a902      	add	r1, sp, #8
    4414:	3254      	adds	r2, #84	; 0x54
    4416:	1852      	adds	r2, r2, r1
    4418:	3401      	adds	r4, #1
    441a:	602b      	str	r3, [r5, #0]
    441c:	60eb      	str	r3, [r5, #12]
    441e:	60ab      	str	r3, [r5, #8]
    4420:	7013      	strb	r3, [r2, #0]
    4422:	65ab      	str	r3, [r5, #88]	; 0x58
    4424:	4e58      	ldr	r6, [pc, #352]	; (4588 <_svfiprintf_r+0x1f4>)
    4426:	2205      	movs	r2, #5
    4428:	7821      	ldrb	r1, [r4, #0]
    442a:	0030      	movs	r0, r6
    442c:	f000 fa50 	bl	48d0 <memchr>
    4430:	1c62      	adds	r2, r4, #1
    4432:	2800      	cmp	r0, #0
    4434:	d120      	bne.n	4478 <_svfiprintf_r+0xe4>
    4436:	6829      	ldr	r1, [r5, #0]
    4438:	06cb      	lsls	r3, r1, #27
    443a:	d504      	bpl.n	4446 <_svfiprintf_r+0xb2>
    443c:	2353      	movs	r3, #83	; 0x53
    443e:	ae02      	add	r6, sp, #8
    4440:	3020      	adds	r0, #32
    4442:	199b      	adds	r3, r3, r6
    4444:	7018      	strb	r0, [r3, #0]
    4446:	070b      	lsls	r3, r1, #28
    4448:	d504      	bpl.n	4454 <_svfiprintf_r+0xc0>
    444a:	2353      	movs	r3, #83	; 0x53
    444c:	202b      	movs	r0, #43	; 0x2b
    444e:	ae02      	add	r6, sp, #8
    4450:	199b      	adds	r3, r3, r6
    4452:	7018      	strb	r0, [r3, #0]
    4454:	7823      	ldrb	r3, [r4, #0]
    4456:	2b2a      	cmp	r3, #42	; 0x2a
    4458:	d016      	beq.n	4488 <_svfiprintf_r+0xf4>
    445a:	2000      	movs	r0, #0
    445c:	210a      	movs	r1, #10
    445e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    4460:	7822      	ldrb	r2, [r4, #0]
    4462:	3a30      	subs	r2, #48	; 0x30
    4464:	2a09      	cmp	r2, #9
    4466:	d955      	bls.n	4514 <_svfiprintf_r+0x180>
    4468:	2800      	cmp	r0, #0
    446a:	d015      	beq.n	4498 <_svfiprintf_r+0x104>
    446c:	9309      	str	r3, [sp, #36]	; 0x24
    446e:	e013      	b.n	4498 <_svfiprintf_r+0x104>
    4470:	2b25      	cmp	r3, #37	; 0x25
    4472:	d0b5      	beq.n	43e0 <_svfiprintf_r+0x4c>
    4474:	3401      	adds	r4, #1
    4476:	e7b0      	b.n	43da <_svfiprintf_r+0x46>
    4478:	2301      	movs	r3, #1
    447a:	1b80      	subs	r0, r0, r6
    447c:	4083      	lsls	r3, r0
    447e:	6829      	ldr	r1, [r5, #0]
    4480:	0014      	movs	r4, r2
    4482:	430b      	orrs	r3, r1
    4484:	602b      	str	r3, [r5, #0]
    4486:	e7cd      	b.n	4424 <_svfiprintf_r+0x90>
    4488:	9b05      	ldr	r3, [sp, #20]
    448a:	1d18      	adds	r0, r3, #4
    448c:	681b      	ldr	r3, [r3, #0]
    448e:	9005      	str	r0, [sp, #20]
    4490:	2b00      	cmp	r3, #0
    4492:	db39      	blt.n	4508 <_svfiprintf_r+0x174>
    4494:	9309      	str	r3, [sp, #36]	; 0x24
    4496:	0014      	movs	r4, r2
    4498:	7823      	ldrb	r3, [r4, #0]
    449a:	2b2e      	cmp	r3, #46	; 0x2e
    449c:	d10b      	bne.n	44b6 <_svfiprintf_r+0x122>
    449e:	7863      	ldrb	r3, [r4, #1]
    44a0:	1c62      	adds	r2, r4, #1
    44a2:	2b2a      	cmp	r3, #42	; 0x2a
    44a4:	d13e      	bne.n	4524 <_svfiprintf_r+0x190>
    44a6:	9b05      	ldr	r3, [sp, #20]
    44a8:	3402      	adds	r4, #2
    44aa:	1d1a      	adds	r2, r3, #4
    44ac:	681b      	ldr	r3, [r3, #0]
    44ae:	9205      	str	r2, [sp, #20]
    44b0:	2b00      	cmp	r3, #0
    44b2:	db34      	blt.n	451e <_svfiprintf_r+0x18a>
    44b4:	9307      	str	r3, [sp, #28]
    44b6:	4e35      	ldr	r6, [pc, #212]	; (458c <_svfiprintf_r+0x1f8>)
    44b8:	7821      	ldrb	r1, [r4, #0]
    44ba:	2203      	movs	r2, #3
    44bc:	0030      	movs	r0, r6
    44be:	f000 fa07 	bl	48d0 <memchr>
    44c2:	2800      	cmp	r0, #0
    44c4:	d006      	beq.n	44d4 <_svfiprintf_r+0x140>
    44c6:	2340      	movs	r3, #64	; 0x40
    44c8:	1b80      	subs	r0, r0, r6
    44ca:	4083      	lsls	r3, r0
    44cc:	682a      	ldr	r2, [r5, #0]
    44ce:	3401      	adds	r4, #1
    44d0:	4313      	orrs	r3, r2
    44d2:	602b      	str	r3, [r5, #0]
    44d4:	7821      	ldrb	r1, [r4, #0]
    44d6:	2206      	movs	r2, #6
    44d8:	482d      	ldr	r0, [pc, #180]	; (4590 <_svfiprintf_r+0x1fc>)
    44da:	1c66      	adds	r6, r4, #1
    44dc:	7629      	strb	r1, [r5, #24]
    44de:	f000 f9f7 	bl	48d0 <memchr>
    44e2:	2800      	cmp	r0, #0
    44e4:	d046      	beq.n	4574 <_svfiprintf_r+0x1e0>
    44e6:	4b2b      	ldr	r3, [pc, #172]	; (4594 <_svfiprintf_r+0x200>)
    44e8:	2b00      	cmp	r3, #0
    44ea:	d12f      	bne.n	454c <_svfiprintf_r+0x1b8>
    44ec:	6829      	ldr	r1, [r5, #0]
    44ee:	9b05      	ldr	r3, [sp, #20]
    44f0:	2207      	movs	r2, #7
    44f2:	05c9      	lsls	r1, r1, #23
    44f4:	d528      	bpl.n	4548 <_svfiprintf_r+0x1b4>
    44f6:	189b      	adds	r3, r3, r2
    44f8:	4393      	bics	r3, r2
    44fa:	3308      	adds	r3, #8
    44fc:	9305      	str	r3, [sp, #20]
    44fe:	696b      	ldr	r3, [r5, #20]
    4500:	9a03      	ldr	r2, [sp, #12]
    4502:	189b      	adds	r3, r3, r2
    4504:	616b      	str	r3, [r5, #20]
    4506:	e767      	b.n	43d8 <_svfiprintf_r+0x44>
    4508:	425b      	negs	r3, r3
    450a:	60eb      	str	r3, [r5, #12]
    450c:	2302      	movs	r3, #2
    450e:	430b      	orrs	r3, r1
    4510:	602b      	str	r3, [r5, #0]
    4512:	e7c0      	b.n	4496 <_svfiprintf_r+0x102>
    4514:	434b      	muls	r3, r1
    4516:	3401      	adds	r4, #1
    4518:	189b      	adds	r3, r3, r2
    451a:	2001      	movs	r0, #1
    451c:	e7a0      	b.n	4460 <_svfiprintf_r+0xcc>
    451e:	2301      	movs	r3, #1
    4520:	425b      	negs	r3, r3
    4522:	e7c7      	b.n	44b4 <_svfiprintf_r+0x120>
    4524:	2300      	movs	r3, #0
    4526:	0014      	movs	r4, r2
    4528:	200a      	movs	r0, #10
    452a:	001a      	movs	r2, r3
    452c:	606b      	str	r3, [r5, #4]
    452e:	7821      	ldrb	r1, [r4, #0]
    4530:	3930      	subs	r1, #48	; 0x30
    4532:	2909      	cmp	r1, #9
    4534:	d903      	bls.n	453e <_svfiprintf_r+0x1aa>
    4536:	2b00      	cmp	r3, #0
    4538:	d0bd      	beq.n	44b6 <_svfiprintf_r+0x122>
    453a:	9207      	str	r2, [sp, #28]
    453c:	e7bb      	b.n	44b6 <_svfiprintf_r+0x122>
    453e:	4342      	muls	r2, r0
    4540:	3401      	adds	r4, #1
    4542:	1852      	adds	r2, r2, r1
    4544:	2301      	movs	r3, #1
    4546:	e7f2      	b.n	452e <_svfiprintf_r+0x19a>
    4548:	3307      	adds	r3, #7
    454a:	e7d5      	b.n	44f8 <_svfiprintf_r+0x164>
    454c:	ab05      	add	r3, sp, #20
    454e:	9300      	str	r3, [sp, #0]
    4550:	003a      	movs	r2, r7
    4552:	4b11      	ldr	r3, [pc, #68]	; (4598 <_svfiprintf_r+0x204>)
    4554:	0029      	movs	r1, r5
    4556:	9802      	ldr	r0, [sp, #8]
    4558:	e000      	b.n	455c <_svfiprintf_r+0x1c8>
    455a:	bf00      	nop
    455c:	9003      	str	r0, [sp, #12]
    455e:	9b03      	ldr	r3, [sp, #12]
    4560:	3301      	adds	r3, #1
    4562:	d1cc      	bne.n	44fe <_svfiprintf_r+0x16a>
    4564:	89bb      	ldrh	r3, [r7, #12]
    4566:	980b      	ldr	r0, [sp, #44]	; 0x2c
    4568:	065b      	lsls	r3, r3, #25
    456a:	d400      	bmi.n	456e <_svfiprintf_r+0x1da>
    456c:	e729      	b.n	43c2 <_svfiprintf_r+0x2e>
    456e:	2001      	movs	r0, #1
    4570:	4240      	negs	r0, r0
    4572:	e726      	b.n	43c2 <_svfiprintf_r+0x2e>
    4574:	ab05      	add	r3, sp, #20
    4576:	9300      	str	r3, [sp, #0]
    4578:	003a      	movs	r2, r7
    457a:	4b07      	ldr	r3, [pc, #28]	; (4598 <_svfiprintf_r+0x204>)
    457c:	0029      	movs	r1, r5
    457e:	9802      	ldr	r0, [sp, #8]
    4580:	f000 f87a 	bl	4678 <_printf_i>
    4584:	e7ea      	b.n	455c <_svfiprintf_r+0x1c8>
    4586:	46c0      	nop			; (mov r8, r8)
    4588:	00004cb8 	.word	0x00004cb8
    458c:	00004cbe 	.word	0x00004cbe
    4590:	00004cc2 	.word	0x00004cc2
    4594:	00000000 	.word	0x00000000
    4598:	000042d1 	.word	0x000042d1

0000459c <_printf_common>:
    459c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    459e:	0015      	movs	r5, r2
    45a0:	9301      	str	r3, [sp, #4]
    45a2:	688a      	ldr	r2, [r1, #8]
    45a4:	690b      	ldr	r3, [r1, #16]
    45a6:	9000      	str	r0, [sp, #0]
    45a8:	000c      	movs	r4, r1
    45aa:	4293      	cmp	r3, r2
    45ac:	da00      	bge.n	45b0 <_printf_common+0x14>
    45ae:	0013      	movs	r3, r2
    45b0:	0022      	movs	r2, r4
    45b2:	602b      	str	r3, [r5, #0]
    45b4:	3243      	adds	r2, #67	; 0x43
    45b6:	7812      	ldrb	r2, [r2, #0]
    45b8:	2a00      	cmp	r2, #0
    45ba:	d001      	beq.n	45c0 <_printf_common+0x24>
    45bc:	3301      	adds	r3, #1
    45be:	602b      	str	r3, [r5, #0]
    45c0:	6823      	ldr	r3, [r4, #0]
    45c2:	069b      	lsls	r3, r3, #26
    45c4:	d502      	bpl.n	45cc <_printf_common+0x30>
    45c6:	682b      	ldr	r3, [r5, #0]
    45c8:	3302      	adds	r3, #2
    45ca:	602b      	str	r3, [r5, #0]
    45cc:	2706      	movs	r7, #6
    45ce:	6823      	ldr	r3, [r4, #0]
    45d0:	401f      	ands	r7, r3
    45d2:	d027      	beq.n	4624 <_printf_common+0x88>
    45d4:	0023      	movs	r3, r4
    45d6:	3343      	adds	r3, #67	; 0x43
    45d8:	781b      	ldrb	r3, [r3, #0]
    45da:	1e5a      	subs	r2, r3, #1
    45dc:	4193      	sbcs	r3, r2
    45de:	6822      	ldr	r2, [r4, #0]
    45e0:	0692      	lsls	r2, r2, #26
    45e2:	d430      	bmi.n	4646 <_printf_common+0xaa>
    45e4:	0022      	movs	r2, r4
    45e6:	9901      	ldr	r1, [sp, #4]
    45e8:	3243      	adds	r2, #67	; 0x43
    45ea:	9800      	ldr	r0, [sp, #0]
    45ec:	9e08      	ldr	r6, [sp, #32]
    45ee:	47b0      	blx	r6
    45f0:	1c43      	adds	r3, r0, #1
    45f2:	d025      	beq.n	4640 <_printf_common+0xa4>
    45f4:	2306      	movs	r3, #6
    45f6:	6820      	ldr	r0, [r4, #0]
    45f8:	682a      	ldr	r2, [r5, #0]
    45fa:	68e1      	ldr	r1, [r4, #12]
    45fc:	4003      	ands	r3, r0
    45fe:	2500      	movs	r5, #0
    4600:	2b04      	cmp	r3, #4
    4602:	d103      	bne.n	460c <_printf_common+0x70>
    4604:	1a8d      	subs	r5, r1, r2
    4606:	43eb      	mvns	r3, r5
    4608:	17db      	asrs	r3, r3, #31
    460a:	401d      	ands	r5, r3
    460c:	68a3      	ldr	r3, [r4, #8]
    460e:	6922      	ldr	r2, [r4, #16]
    4610:	4293      	cmp	r3, r2
    4612:	dd01      	ble.n	4618 <_printf_common+0x7c>
    4614:	1a9b      	subs	r3, r3, r2
    4616:	18ed      	adds	r5, r5, r3
    4618:	2700      	movs	r7, #0
    461a:	42bd      	cmp	r5, r7
    461c:	d120      	bne.n	4660 <_printf_common+0xc4>
    461e:	2000      	movs	r0, #0
    4620:	e010      	b.n	4644 <_printf_common+0xa8>
    4622:	3701      	adds	r7, #1
    4624:	68e3      	ldr	r3, [r4, #12]
    4626:	682a      	ldr	r2, [r5, #0]
    4628:	1a9b      	subs	r3, r3, r2
    462a:	429f      	cmp	r7, r3
    462c:	dad2      	bge.n	45d4 <_printf_common+0x38>
    462e:	0022      	movs	r2, r4
    4630:	2301      	movs	r3, #1
    4632:	3219      	adds	r2, #25
    4634:	9901      	ldr	r1, [sp, #4]
    4636:	9800      	ldr	r0, [sp, #0]
    4638:	9e08      	ldr	r6, [sp, #32]
    463a:	47b0      	blx	r6
    463c:	1c43      	adds	r3, r0, #1
    463e:	d1f0      	bne.n	4622 <_printf_common+0x86>
    4640:	2001      	movs	r0, #1
    4642:	4240      	negs	r0, r0
    4644:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    4646:	2030      	movs	r0, #48	; 0x30
    4648:	18e1      	adds	r1, r4, r3
    464a:	3143      	adds	r1, #67	; 0x43
    464c:	7008      	strb	r0, [r1, #0]
    464e:	0021      	movs	r1, r4
    4650:	1c5a      	adds	r2, r3, #1
    4652:	3145      	adds	r1, #69	; 0x45
    4654:	7809      	ldrb	r1, [r1, #0]
    4656:	18a2      	adds	r2, r4, r2
    4658:	3243      	adds	r2, #67	; 0x43
    465a:	3302      	adds	r3, #2
    465c:	7011      	strb	r1, [r2, #0]
    465e:	e7c1      	b.n	45e4 <_printf_common+0x48>
    4660:	0022      	movs	r2, r4
    4662:	2301      	movs	r3, #1
    4664:	321a      	adds	r2, #26
    4666:	9901      	ldr	r1, [sp, #4]
    4668:	9800      	ldr	r0, [sp, #0]
    466a:	9e08      	ldr	r6, [sp, #32]
    466c:	47b0      	blx	r6
    466e:	1c43      	adds	r3, r0, #1
    4670:	d0e6      	beq.n	4640 <_printf_common+0xa4>
    4672:	3701      	adds	r7, #1
    4674:	e7d1      	b.n	461a <_printf_common+0x7e>
	...

00004678 <_printf_i>:
    4678:	b5f0      	push	{r4, r5, r6, r7, lr}
    467a:	b08b      	sub	sp, #44	; 0x2c
    467c:	9206      	str	r2, [sp, #24]
    467e:	000a      	movs	r2, r1
    4680:	3243      	adds	r2, #67	; 0x43
    4682:	9307      	str	r3, [sp, #28]
    4684:	9005      	str	r0, [sp, #20]
    4686:	9204      	str	r2, [sp, #16]
    4688:	7e0a      	ldrb	r2, [r1, #24]
    468a:	000c      	movs	r4, r1
    468c:	9b10      	ldr	r3, [sp, #64]	; 0x40
    468e:	2a6e      	cmp	r2, #110	; 0x6e
    4690:	d100      	bne.n	4694 <_printf_i+0x1c>
    4692:	e08f      	b.n	47b4 <_printf_i+0x13c>
    4694:	d817      	bhi.n	46c6 <_printf_i+0x4e>
    4696:	2a63      	cmp	r2, #99	; 0x63
    4698:	d02c      	beq.n	46f4 <_printf_i+0x7c>
    469a:	d808      	bhi.n	46ae <_printf_i+0x36>
    469c:	2a00      	cmp	r2, #0
    469e:	d100      	bne.n	46a2 <_printf_i+0x2a>
    46a0:	e099      	b.n	47d6 <_printf_i+0x15e>
    46a2:	2a58      	cmp	r2, #88	; 0x58
    46a4:	d054      	beq.n	4750 <_printf_i+0xd8>
    46a6:	0026      	movs	r6, r4
    46a8:	3642      	adds	r6, #66	; 0x42
    46aa:	7032      	strb	r2, [r6, #0]
    46ac:	e029      	b.n	4702 <_printf_i+0x8a>
    46ae:	2a64      	cmp	r2, #100	; 0x64
    46b0:	d001      	beq.n	46b6 <_printf_i+0x3e>
    46b2:	2a69      	cmp	r2, #105	; 0x69
    46b4:	d1f7      	bne.n	46a6 <_printf_i+0x2e>
    46b6:	6821      	ldr	r1, [r4, #0]
    46b8:	681a      	ldr	r2, [r3, #0]
    46ba:	0608      	lsls	r0, r1, #24
    46bc:	d523      	bpl.n	4706 <_printf_i+0x8e>
    46be:	1d11      	adds	r1, r2, #4
    46c0:	6019      	str	r1, [r3, #0]
    46c2:	6815      	ldr	r5, [r2, #0]
    46c4:	e025      	b.n	4712 <_printf_i+0x9a>
    46c6:	2a73      	cmp	r2, #115	; 0x73
    46c8:	d100      	bne.n	46cc <_printf_i+0x54>
    46ca:	e088      	b.n	47de <_printf_i+0x166>
    46cc:	d808      	bhi.n	46e0 <_printf_i+0x68>
    46ce:	2a6f      	cmp	r2, #111	; 0x6f
    46d0:	d029      	beq.n	4726 <_printf_i+0xae>
    46d2:	2a70      	cmp	r2, #112	; 0x70
    46d4:	d1e7      	bne.n	46a6 <_printf_i+0x2e>
    46d6:	2220      	movs	r2, #32
    46d8:	6809      	ldr	r1, [r1, #0]
    46da:	430a      	orrs	r2, r1
    46dc:	6022      	str	r2, [r4, #0]
    46de:	e003      	b.n	46e8 <_printf_i+0x70>
    46e0:	2a75      	cmp	r2, #117	; 0x75
    46e2:	d020      	beq.n	4726 <_printf_i+0xae>
    46e4:	2a78      	cmp	r2, #120	; 0x78
    46e6:	d1de      	bne.n	46a6 <_printf_i+0x2e>
    46e8:	0022      	movs	r2, r4
    46ea:	2178      	movs	r1, #120	; 0x78
    46ec:	3245      	adds	r2, #69	; 0x45
    46ee:	7011      	strb	r1, [r2, #0]
    46f0:	4a6c      	ldr	r2, [pc, #432]	; (48a4 <_printf_i+0x22c>)
    46f2:	e030      	b.n	4756 <_printf_i+0xde>
    46f4:	000e      	movs	r6, r1
    46f6:	681a      	ldr	r2, [r3, #0]
    46f8:	3642      	adds	r6, #66	; 0x42
    46fa:	1d11      	adds	r1, r2, #4
    46fc:	6019      	str	r1, [r3, #0]
    46fe:	6813      	ldr	r3, [r2, #0]
    4700:	7033      	strb	r3, [r6, #0]
    4702:	2301      	movs	r3, #1
    4704:	e079      	b.n	47fa <_printf_i+0x182>
    4706:	0649      	lsls	r1, r1, #25
    4708:	d5d9      	bpl.n	46be <_printf_i+0x46>
    470a:	1d11      	adds	r1, r2, #4
    470c:	6019      	str	r1, [r3, #0]
    470e:	2300      	movs	r3, #0
    4710:	5ed5      	ldrsh	r5, [r2, r3]
    4712:	2d00      	cmp	r5, #0
    4714:	da03      	bge.n	471e <_printf_i+0xa6>
    4716:	232d      	movs	r3, #45	; 0x2d
    4718:	9a04      	ldr	r2, [sp, #16]
    471a:	426d      	negs	r5, r5
    471c:	7013      	strb	r3, [r2, #0]
    471e:	4b62      	ldr	r3, [pc, #392]	; (48a8 <_printf_i+0x230>)
    4720:	270a      	movs	r7, #10
    4722:	9303      	str	r3, [sp, #12]
    4724:	e02f      	b.n	4786 <_printf_i+0x10e>
    4726:	6820      	ldr	r0, [r4, #0]
    4728:	6819      	ldr	r1, [r3, #0]
    472a:	0605      	lsls	r5, r0, #24
    472c:	d503      	bpl.n	4736 <_printf_i+0xbe>
    472e:	1d08      	adds	r0, r1, #4
    4730:	6018      	str	r0, [r3, #0]
    4732:	680d      	ldr	r5, [r1, #0]
    4734:	e005      	b.n	4742 <_printf_i+0xca>
    4736:	0640      	lsls	r0, r0, #25
    4738:	d5f9      	bpl.n	472e <_printf_i+0xb6>
    473a:	680d      	ldr	r5, [r1, #0]
    473c:	1d08      	adds	r0, r1, #4
    473e:	6018      	str	r0, [r3, #0]
    4740:	b2ad      	uxth	r5, r5
    4742:	4b59      	ldr	r3, [pc, #356]	; (48a8 <_printf_i+0x230>)
    4744:	2708      	movs	r7, #8
    4746:	9303      	str	r3, [sp, #12]
    4748:	2a6f      	cmp	r2, #111	; 0x6f
    474a:	d018      	beq.n	477e <_printf_i+0x106>
    474c:	270a      	movs	r7, #10
    474e:	e016      	b.n	477e <_printf_i+0x106>
    4750:	3145      	adds	r1, #69	; 0x45
    4752:	700a      	strb	r2, [r1, #0]
    4754:	4a54      	ldr	r2, [pc, #336]	; (48a8 <_printf_i+0x230>)
    4756:	9203      	str	r2, [sp, #12]
    4758:	681a      	ldr	r2, [r3, #0]
    475a:	6821      	ldr	r1, [r4, #0]
    475c:	1d10      	adds	r0, r2, #4
    475e:	6018      	str	r0, [r3, #0]
    4760:	6815      	ldr	r5, [r2, #0]
    4762:	0608      	lsls	r0, r1, #24
    4764:	d522      	bpl.n	47ac <_printf_i+0x134>
    4766:	07cb      	lsls	r3, r1, #31
    4768:	d502      	bpl.n	4770 <_printf_i+0xf8>
    476a:	2320      	movs	r3, #32
    476c:	4319      	orrs	r1, r3
    476e:	6021      	str	r1, [r4, #0]
    4770:	2710      	movs	r7, #16
    4772:	2d00      	cmp	r5, #0
    4774:	d103      	bne.n	477e <_printf_i+0x106>
    4776:	2320      	movs	r3, #32
    4778:	6822      	ldr	r2, [r4, #0]
    477a:	439a      	bics	r2, r3
    477c:	6022      	str	r2, [r4, #0]
    477e:	0023      	movs	r3, r4
    4780:	2200      	movs	r2, #0
    4782:	3343      	adds	r3, #67	; 0x43
    4784:	701a      	strb	r2, [r3, #0]
    4786:	6863      	ldr	r3, [r4, #4]
    4788:	60a3      	str	r3, [r4, #8]
    478a:	2b00      	cmp	r3, #0
    478c:	db5c      	blt.n	4848 <_printf_i+0x1d0>
    478e:	2204      	movs	r2, #4
    4790:	6821      	ldr	r1, [r4, #0]
    4792:	4391      	bics	r1, r2
    4794:	6021      	str	r1, [r4, #0]
    4796:	2d00      	cmp	r5, #0
    4798:	d158      	bne.n	484c <_printf_i+0x1d4>
    479a:	9e04      	ldr	r6, [sp, #16]
    479c:	2b00      	cmp	r3, #0
    479e:	d064      	beq.n	486a <_printf_i+0x1f2>
    47a0:	0026      	movs	r6, r4
    47a2:	9b03      	ldr	r3, [sp, #12]
    47a4:	3642      	adds	r6, #66	; 0x42
    47a6:	781b      	ldrb	r3, [r3, #0]
    47a8:	7033      	strb	r3, [r6, #0]
    47aa:	e05e      	b.n	486a <_printf_i+0x1f2>
    47ac:	0648      	lsls	r0, r1, #25
    47ae:	d5da      	bpl.n	4766 <_printf_i+0xee>
    47b0:	b2ad      	uxth	r5, r5
    47b2:	e7d8      	b.n	4766 <_printf_i+0xee>
    47b4:	6809      	ldr	r1, [r1, #0]
    47b6:	681a      	ldr	r2, [r3, #0]
    47b8:	0608      	lsls	r0, r1, #24
    47ba:	d505      	bpl.n	47c8 <_printf_i+0x150>
    47bc:	1d11      	adds	r1, r2, #4
    47be:	6019      	str	r1, [r3, #0]
    47c0:	6813      	ldr	r3, [r2, #0]
    47c2:	6962      	ldr	r2, [r4, #20]
    47c4:	601a      	str	r2, [r3, #0]
    47c6:	e006      	b.n	47d6 <_printf_i+0x15e>
    47c8:	0649      	lsls	r1, r1, #25
    47ca:	d5f7      	bpl.n	47bc <_printf_i+0x144>
    47cc:	1d11      	adds	r1, r2, #4
    47ce:	6019      	str	r1, [r3, #0]
    47d0:	6813      	ldr	r3, [r2, #0]
    47d2:	8aa2      	ldrh	r2, [r4, #20]
    47d4:	801a      	strh	r2, [r3, #0]
    47d6:	2300      	movs	r3, #0
    47d8:	9e04      	ldr	r6, [sp, #16]
    47da:	6123      	str	r3, [r4, #16]
    47dc:	e054      	b.n	4888 <_printf_i+0x210>
    47de:	681a      	ldr	r2, [r3, #0]
    47e0:	1d11      	adds	r1, r2, #4
    47e2:	6019      	str	r1, [r3, #0]
    47e4:	6816      	ldr	r6, [r2, #0]
    47e6:	2100      	movs	r1, #0
    47e8:	6862      	ldr	r2, [r4, #4]
    47ea:	0030      	movs	r0, r6
    47ec:	f000 f870 	bl	48d0 <memchr>
    47f0:	2800      	cmp	r0, #0
    47f2:	d001      	beq.n	47f8 <_printf_i+0x180>
    47f4:	1b80      	subs	r0, r0, r6
    47f6:	6060      	str	r0, [r4, #4]
    47f8:	6863      	ldr	r3, [r4, #4]
    47fa:	6123      	str	r3, [r4, #16]
    47fc:	2300      	movs	r3, #0
    47fe:	9a04      	ldr	r2, [sp, #16]
    4800:	7013      	strb	r3, [r2, #0]
    4802:	e041      	b.n	4888 <_printf_i+0x210>
    4804:	6923      	ldr	r3, [r4, #16]
    4806:	0032      	movs	r2, r6
    4808:	9906      	ldr	r1, [sp, #24]
    480a:	9805      	ldr	r0, [sp, #20]
    480c:	9d07      	ldr	r5, [sp, #28]
    480e:	47a8      	blx	r5
    4810:	1c43      	adds	r3, r0, #1
    4812:	d043      	beq.n	489c <_printf_i+0x224>
    4814:	6823      	ldr	r3, [r4, #0]
    4816:	2500      	movs	r5, #0
    4818:	079b      	lsls	r3, r3, #30
    481a:	d40f      	bmi.n	483c <_printf_i+0x1c4>
    481c:	9b09      	ldr	r3, [sp, #36]	; 0x24
    481e:	68e0      	ldr	r0, [r4, #12]
    4820:	4298      	cmp	r0, r3
    4822:	da3d      	bge.n	48a0 <_printf_i+0x228>
    4824:	0018      	movs	r0, r3
    4826:	e03b      	b.n	48a0 <_printf_i+0x228>
    4828:	0022      	movs	r2, r4
    482a:	2301      	movs	r3, #1
    482c:	3219      	adds	r2, #25
    482e:	9906      	ldr	r1, [sp, #24]
    4830:	9805      	ldr	r0, [sp, #20]
    4832:	9e07      	ldr	r6, [sp, #28]
    4834:	47b0      	blx	r6
    4836:	1c43      	adds	r3, r0, #1
    4838:	d030      	beq.n	489c <_printf_i+0x224>
    483a:	3501      	adds	r5, #1
    483c:	68e3      	ldr	r3, [r4, #12]
    483e:	9a09      	ldr	r2, [sp, #36]	; 0x24
    4840:	1a9b      	subs	r3, r3, r2
    4842:	429d      	cmp	r5, r3
    4844:	dbf0      	blt.n	4828 <_printf_i+0x1b0>
    4846:	e7e9      	b.n	481c <_printf_i+0x1a4>
    4848:	2d00      	cmp	r5, #0
    484a:	d0a9      	beq.n	47a0 <_printf_i+0x128>
    484c:	9e04      	ldr	r6, [sp, #16]
    484e:	0028      	movs	r0, r5
    4850:	0039      	movs	r1, r7
    4852:	f7ff fba5 	bl	3fa0 <__aeabi_uidivmod>
    4856:	9b03      	ldr	r3, [sp, #12]
    4858:	3e01      	subs	r6, #1
    485a:	5c5b      	ldrb	r3, [r3, r1]
    485c:	0028      	movs	r0, r5
    485e:	7033      	strb	r3, [r6, #0]
    4860:	0039      	movs	r1, r7
    4862:	f7ff fb17 	bl	3e94 <__udivsi3>
    4866:	1e05      	subs	r5, r0, #0
    4868:	d1f1      	bne.n	484e <_printf_i+0x1d6>
    486a:	2f08      	cmp	r7, #8
    486c:	d109      	bne.n	4882 <_printf_i+0x20a>
    486e:	6823      	ldr	r3, [r4, #0]
    4870:	07db      	lsls	r3, r3, #31
    4872:	d506      	bpl.n	4882 <_printf_i+0x20a>
    4874:	6863      	ldr	r3, [r4, #4]
    4876:	6922      	ldr	r2, [r4, #16]
    4878:	4293      	cmp	r3, r2
    487a:	dc02      	bgt.n	4882 <_printf_i+0x20a>
    487c:	2330      	movs	r3, #48	; 0x30
    487e:	3e01      	subs	r6, #1
    4880:	7033      	strb	r3, [r6, #0]
    4882:	9b04      	ldr	r3, [sp, #16]
    4884:	1b9b      	subs	r3, r3, r6
    4886:	6123      	str	r3, [r4, #16]
    4888:	9b07      	ldr	r3, [sp, #28]
    488a:	aa09      	add	r2, sp, #36	; 0x24
    488c:	9300      	str	r3, [sp, #0]
    488e:	0021      	movs	r1, r4
    4890:	9b06      	ldr	r3, [sp, #24]
    4892:	9805      	ldr	r0, [sp, #20]
    4894:	f7ff fe82 	bl	459c <_printf_common>
    4898:	1c43      	adds	r3, r0, #1
    489a:	d1b3      	bne.n	4804 <_printf_i+0x18c>
    489c:	2001      	movs	r0, #1
    489e:	4240      	negs	r0, r0
    48a0:	b00b      	add	sp, #44	; 0x2c
    48a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    48a4:	00004cda 	.word	0x00004cda
    48a8:	00004cc9 	.word	0x00004cc9

000048ac <_sbrk_r>:
    48ac:	2300      	movs	r3, #0
    48ae:	b570      	push	{r4, r5, r6, lr}
    48b0:	4c06      	ldr	r4, [pc, #24]	; (48cc <_sbrk_r+0x20>)
    48b2:	0005      	movs	r5, r0
    48b4:	0008      	movs	r0, r1
    48b6:	6023      	str	r3, [r4, #0]
    48b8:	f7fc f8c8 	bl	a4c <_sbrk>
    48bc:	1c43      	adds	r3, r0, #1
    48be:	d103      	bne.n	48c8 <_sbrk_r+0x1c>
    48c0:	6823      	ldr	r3, [r4, #0]
    48c2:	2b00      	cmp	r3, #0
    48c4:	d000      	beq.n	48c8 <_sbrk_r+0x1c>
    48c6:	602b      	str	r3, [r5, #0]
    48c8:	bd70      	pop	{r4, r5, r6, pc}
    48ca:	46c0      	nop			; (mov r8, r8)
    48cc:	20000b34 	.word	0x20000b34

000048d0 <memchr>:
    48d0:	b2c9      	uxtb	r1, r1
    48d2:	1882      	adds	r2, r0, r2
    48d4:	4290      	cmp	r0, r2
    48d6:	d101      	bne.n	48dc <memchr+0xc>
    48d8:	2000      	movs	r0, #0
    48da:	4770      	bx	lr
    48dc:	7803      	ldrb	r3, [r0, #0]
    48de:	428b      	cmp	r3, r1
    48e0:	d0fb      	beq.n	48da <memchr+0xa>
    48e2:	3001      	adds	r0, #1
    48e4:	e7f6      	b.n	48d4 <memchr+0x4>

000048e6 <memmove>:
    48e6:	b510      	push	{r4, lr}
    48e8:	4288      	cmp	r0, r1
    48ea:	d902      	bls.n	48f2 <memmove+0xc>
    48ec:	188b      	adds	r3, r1, r2
    48ee:	4298      	cmp	r0, r3
    48f0:	d308      	bcc.n	4904 <memmove+0x1e>
    48f2:	2300      	movs	r3, #0
    48f4:	429a      	cmp	r2, r3
    48f6:	d007      	beq.n	4908 <memmove+0x22>
    48f8:	5ccc      	ldrb	r4, [r1, r3]
    48fa:	54c4      	strb	r4, [r0, r3]
    48fc:	3301      	adds	r3, #1
    48fe:	e7f9      	b.n	48f4 <memmove+0xe>
    4900:	5c8b      	ldrb	r3, [r1, r2]
    4902:	5483      	strb	r3, [r0, r2]
    4904:	3a01      	subs	r2, #1
    4906:	d2fb      	bcs.n	4900 <memmove+0x1a>
    4908:	bd10      	pop	{r4, pc}

0000490a <__malloc_lock>:
    490a:	4770      	bx	lr

0000490c <__malloc_unlock>:
    490c:	4770      	bx	lr

0000490e <_realloc_r>:
    490e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4910:	0007      	movs	r7, r0
    4912:	000d      	movs	r5, r1
    4914:	0016      	movs	r6, r2
    4916:	2900      	cmp	r1, #0
    4918:	d105      	bne.n	4926 <_realloc_r+0x18>
    491a:	0011      	movs	r1, r2
    491c:	f7ff fc7a 	bl	4214 <_malloc_r>
    4920:	0004      	movs	r4, r0
    4922:	0020      	movs	r0, r4
    4924:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    4926:	2a00      	cmp	r2, #0
    4928:	d103      	bne.n	4932 <_realloc_r+0x24>
    492a:	f7ff fc29 	bl	4180 <_free_r>
    492e:	0034      	movs	r4, r6
    4930:	e7f7      	b.n	4922 <_realloc_r+0x14>
    4932:	f000 f812 	bl	495a <_malloc_usable_size_r>
    4936:	002c      	movs	r4, r5
    4938:	4286      	cmp	r6, r0
    493a:	d9f2      	bls.n	4922 <_realloc_r+0x14>
    493c:	0031      	movs	r1, r6
    493e:	0038      	movs	r0, r7
    4940:	f7ff fc68 	bl	4214 <_malloc_r>
    4944:	1e04      	subs	r4, r0, #0
    4946:	d0ec      	beq.n	4922 <_realloc_r+0x14>
    4948:	0029      	movs	r1, r5
    494a:	0032      	movs	r2, r6
    494c:	f7ff fb7c 	bl	4048 <memcpy>
    4950:	0029      	movs	r1, r5
    4952:	0038      	movs	r0, r7
    4954:	f7ff fc14 	bl	4180 <_free_r>
    4958:	e7e3      	b.n	4922 <_realloc_r+0x14>

0000495a <_malloc_usable_size_r>:
    495a:	1f0b      	subs	r3, r1, #4
    495c:	681b      	ldr	r3, [r3, #0]
    495e:	1f18      	subs	r0, r3, #4
    4960:	2b00      	cmp	r3, #0
    4962:	da01      	bge.n	4968 <_malloc_usable_size_r+0xe>
    4964:	580b      	ldr	r3, [r1, r0]
    4966:	18c0      	adds	r0, r0, r3
    4968:	4770      	bx	lr
    496a:	0000      	movs	r0, r0
    496c:	682f2e2e 	.word	0x682f2e2e
    4970:	732f6c61 	.word	0x732f6c61
    4974:	682f6372 	.word	0x682f6372
    4978:	695f6c61 	.word	0x695f6c61
    497c:	6d5f6332 	.word	0x6d5f6332
    4980:	6e79735f 	.word	0x6e79735f
    4984:	00632e63 	.word	0x00632e63
    4988:	682f2e2e 	.word	0x682f2e2e
    498c:	732f6c61 	.word	0x732f6c61
    4990:	682f6372 	.word	0x682f6372
    4994:	695f6c61 	.word	0x695f6c61
    4998:	00632e6f 	.word	0x00632e6f
    499c:	682f2e2e 	.word	0x682f2e2e
    49a0:	732f6c61 	.word	0x732f6c61
    49a4:	682f6372 	.word	0x682f6372
    49a8:	705f6c61 	.word	0x705f6c61
    49ac:	632e6d77 	.word	0x632e6d77
    49b0:	00000000 	.word	0x00000000
    49b4:	682f2e2e 	.word	0x682f2e2e
    49b8:	732f6c61 	.word	0x732f6c61
    49bc:	682f6372 	.word	0x682f6372
    49c0:	735f6c61 	.word	0x735f6c61
    49c4:	6d5f6970 	.word	0x6d5f6970
    49c8:	6e79735f 	.word	0x6e79735f
    49cc:	00632e63 	.word	0x00632e63
    49d0:	682f2e2e 	.word	0x682f2e2e
    49d4:	732f6c61 	.word	0x732f6c61
    49d8:	682f6372 	.word	0x682f6372
    49dc:	745f6c61 	.word	0x745f6c61
    49e0:	72656d69 	.word	0x72656d69
    49e4:	0000632e 	.word	0x0000632e
    49e8:	682f2e2e 	.word	0x682f2e2e
    49ec:	732f6c61 	.word	0x732f6c61
    49f0:	682f6372 	.word	0x682f6372
    49f4:	755f6c61 	.word	0x755f6c61
    49f8:	74726173 	.word	0x74726173
    49fc:	6e79735f 	.word	0x6e79735f
    4a00:	00632e63 	.word	0x00632e63
    4a04:	682f2e2e 	.word	0x682f2e2e
    4a08:	752f6c61 	.word	0x752f6c61
    4a0c:	736c6974 	.word	0x736c6974
    4a10:	6372732f 	.word	0x6372732f
    4a14:	6974752f 	.word	0x6974752f
    4a18:	6c5f736c 	.word	0x6c5f736c
    4a1c:	2e747369 	.word	0x2e747369
    4a20:	00000063 	.word	0x00000063

00004a24 <_map>:
    4a24:	00000008 00000028 682f2e2e 652f6c70     ....(...../hpl/e
    4a34:	682f6369 655f6c70 632e6369 00000000     ic/hpl_eic.c....
    4a44:	682f2e2e 722f6c70 682f6374 725f6c70     ../hpl/rtc/hpl_r
    4a54:	632e6374 00000000                       tc.c....

00004a5c <_usarts>:
    4a5c:	00000004 40010004 00030000 0000ff2e     .......@........

00004a6c <_i2cms>:
    4a6c:	00000002 00200014 00000100 000000ea     ...... .........
    4a7c:	000000d7 02dc6c00                       .....l..

00004a84 <_i2css>:
	...

00004a94 <sercomspi_regs>:
    4a94:	0020000c 00020000 00000000 000000fe     .. .............
    4aa4:	0020000c 00020000 00000000 030000fe     .. .............
    4ab4:	682f2e2e 732f6c70 6f637265 70682f6d     ../hpl/sercom/hp
    4ac4:	65735f6c 6d6f6372 0000632e 682f2e2e     l_sercom.c..../h
    4ad4:	742f6c70 70682f63 63745f6c 0000632e     pl/tc/hpl_tc.c..
    4ae4:	00002c68 00002c94 00002ca4 00002cc0     h,...,...,...,..
    4af4:	00002cdc 00002cfc 00002d18 00002d38     .,...,...-..8-..
    4b04:	00002eae 00002d9c 00002db4 00002dcc     .....-...-...-..
    4b14:	00002dee 00002e08 00002e2a 00002e84     .-......*.......
    4b24:	00002ef2 00002f06 00002f1e 00002f36     ...../.../..6/..
    4b34:	00002f5e 00002f78 00003038 00002fa0     ^/..x/..80.../..
    4b44:	00002fc4 00002fce 00002fd8 00002ff0     ./.../.../.../..
    4b54:	00003018 0000385e 00003866 00003884     .0..^8..f8...8..
    4b64:	0000387a 0000388e 00003898 000038a2     z8...8...8...8..
    4b74:	000038ba 000038d8 000038fa 00003902     .8...8...8...9..
    4b84:	0000390c 0000393e 00003916 0000391e     .9..>9...9...9..
    4b94:	0000392e 00003adc 00003ae6 00003af0     .9...:...:...:..
    4ba4:	00003af8 00003b02 00003b0c 3c3e703c     .:...;...;..<p><
    4bb4:	6e617073 79747320 223d656c 6f6c6f63     span style="colo
    4bc4:	23203a72 66663030 223b3030 74733c3e     r: #00ff00;"><st
    4bd4:	676e6f72 7461643e 732f3c61 6e6f7274     rong>data</stron
    4be4:	2f3c3e67 6e617073 702f3c3e 000d0a3e     g></span></p>...
    4bf4:	4b434f53 4e205445 203a4d55 3c3b6425     SOCKET NUM: %d;<
    4c04:	523e7262 203a4354 64323025 3230253a     br>RTC: %02d:%02
    4c14:	30253a64 203b6432 6165520a 79622064     d:%02d; .Read by
    4c24:	3a736574 3c642520 003e7262 253a5049     tes: %d<br>.IP:%
    4c34:	64252e64 2e64252e 623c6425 00003e72     d.%d.%d.%d<br>..
    4c44:	6e7a6957 53207465 20737961 0a216948     Wiznet Says Hi!.
    4c54:	0000000d                                ....

00004c58 <__sf_fake_stderr>:
	...

00004c78 <__sf_fake_stdin>:
	...

00004c98 <__sf_fake_stdout>:
	...
    4cb8:	2b302d23 6c680020 6665004c 47464567     #-0+ .hlL.efgEFG
    4cc8:	32313000 36353433 41393837 45444342     .0123456789ABCDE
    4cd8:	31300046 35343332 39383736 64636261     F.0123456789abcd
    4ce8:	00006665                                ef..

00004cec <_init>:
    4cec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4cee:	46c0      	nop			; (mov r8, r8)
    4cf0:	bcf8      	pop	{r3, r4, r5, r6, r7}
    4cf2:	bc08      	pop	{r3}
    4cf4:	469e      	mov	lr, r3
    4cf6:	4770      	bx	lr

00004cf8 <__init_array_start>:
    4cf8:	000000cd 	.word	0x000000cd

00004cfc <_fini>:
    4cfc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4cfe:	46c0      	nop			; (mov r8, r8)
    4d00:	bcf8      	pop	{r3, r4, r5, r6, r7}
    4d02:	bc08      	pop	{r3}
    4d04:	469e      	mov	lr, r3
    4d06:	4770      	bx	lr

00004d08 <__fini_array_start>:
    4d08:	000000a5 	.word	0x000000a5
